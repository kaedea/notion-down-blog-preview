<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kaede Akatsuki | 中二病也要开发 Android</title>

  
  <meta name="author" content="Kaede Akatsuki">
  

  
  <meta name="description" content="A TASTE OF ACG (Anime/Coding/Games).">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Kaede Akatsuki"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kaede Akatsuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Kaede Akatsuki</a>
    </h1>
    <p class="site-description">中二病也要开发 Android</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2021/08/14/android-apm-battery-stats-opt/"><span>Android App 电量统计原理与优化</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/08/14/android-apm-battery-stats-opt/" rel="bookmark">
        <time class="entry-date published" datetime="2021-08-14T00:00:00.000Z">
          2021-08-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <!-- changelog
2021-07-27
修订 2
Add: 

1. 项目使用效果

2021-07-21
修订 1
Add: 

1. 拓展阅读

2021-07-20
初稿
-->

<!-- draft

1. 背景
1. 耗电问题表现
1. 耗电统计原理
1. 计算公式
1. Android 硬件模块电量统计
    1. BatteryStatsService
1. Matrix BatteryCanary
    1. ProcStat
1. 线程池
1. UI 线程、Looper 线程
    1. EventSlice
    1. StackTrace
1. 案例
1. 其他耗电指标
1. 拓展阅读
    1. Benchmarks
1. 竞品

-->


<h2 id="App-“耗电综合征”"><a href="#App-“耗电综合征”" class="headerlink" title="App “耗电综合征”"></a>App “耗电综合征”</h2><p>当我们说一个 App 耗电的时候我们在说什么？</p>
<p>我们可能是指 App 吃 CPU 导致系统掉电快，也可能是在说系统告警 App 后台扫描频繁消耗电量，还可能是在说使用 App 时手机发烫严重…… 是的，相对于 Crash、ANR 等常见的 APM 指标，Android App 电量优化更像是一个综合性的问题。</p>
<p>一方面，造成 App 耗电的原因是多种多样的，比如 CPU/GPU Load、屏幕、传感器以及其他硬件开销等，每个分类的排查思路是大相径庭的，再加上 AOSP 没有 “官方” 的耗电异常检测框架，各个 OEM 厂商自家系统对 App 耗电的监控方案又各不相同（且没有充分的公开文档），所以检测方案需要结合具体 App 项目实际和用户反馈状况，针对具体的耗电类型做出考量和取舍。另一方面，耗电问题也经常是比较 “主观” 的，比如用户感觉 App 新版本掉电比较快了，或者在户外气温比较高的环境使用 App 时感觉设备发烫了，又或只是单纯的因为使用时间变长了导致系统耗电排行靠前了等等，这些通常都是一些比较微妙的主观感受，难以量化问题。</p>
<p>因此，** 如何检测各种类型的耗电异常，以及如何提炼耗电问题的规则（划红线）是优化电量指标的关键所在 **。微信 Android 项目在与 App 耗电异常这项 “疑难杂症” 日常斗智斗勇的过程中，产出了一些比较实用的工具和优化思路。本文针对 Anroid App 的耗电问题，具体分为 “App 电量统计原理”、“耗电异常监控方案”、以及相关的 “优化案例” 三部分进行解析和分享。</p>
        
          <p><a class="excerpt-btn" href="2021/08/14/android-apm-battery-stats-opt/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/APM/">APM</a><a href="/tags/电量优化/">电量优化</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2021/08/14/android-apm-battery-stats-opt/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/05/20/devops/notion-to-markdown-file-automating-solution/"><span>基于 Notion 的笔记写作和博客分享自动化方案</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/05/20/devops/notion-to-markdown-file-automating-solution/" rel="bookmark">
        <time class="entry-date published" datetime="2021-05-20T00:00:00.000Z">
          2021-05-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fwoodcuts_16.jpg" alt="Page Cover"></p>
<!-- draft

1. 背景
1. Notion
1. Solution & Workflows
1. 流程图
    1. refer：[https://github.com/soruly/trace.moe#overview](https://github.com/soruly/trace.moe#overview)
1. NotionDown

-->

<p>个人认为，笔记（Note）、写作（Writing）和分享（Share）是 <code>个人知识管理</code> 重要的组成部分。笔记是知识元素，写作是知识汇总，分享是知识升华。固然每个人具体实践的方式会尽不相同，不过大家应该都或多或少能对体会其中存在的一些割裂感：</p>
<p>其一，笔记存在多端同步编辑的刚需。不过随着云笔记解决方案越来越成熟后，这问题现在已经有许多解决方案。其二，笔记草稿和写作正文之间的同步存在许多机械的地方：同一篇文章经常需要在草稿和正文（终稿）之间来回修订，而大部分情况下这两者的同步是通过复制粘贴和人工比对来完成的，这个过场是写作体验主要的割裂感之一。其三，写作正文完成之后的文章分享（Publish）也是一个麻烦的流程，尽管现在许多静态博客可以通过自动化技术完成部署，不过文章正文内容和部署用的 MarkDown 源文件之间的数据同步也是个非常头疼的事情：如果正文和 MD 文件分开处理，两者之间只能手动同步；如果直接用 MD 文件来写正文，又不得不面临现在多数云笔记糟糕的 MD 文件编辑体验（而且 MD 文件能否导出还是个未知数）；如果干脆使用 gitbook 之类的方案来编辑 MD 文件，那基于 git 的笔记云同步方案体验也不会好到哪。</p>
<p>自从改用静态博客代替 WordPress 来发表自己的文章、文档后，我不得已采用” 云笔记写草稿，MD 文件保存文章正文，手动在草稿和正文之间同步 “这样的 <code>原始</code> 的写作方案，以上说的几种割裂感也是一直以来我感到非常困扰的地方。</p>
<p>几番苦寻更好的云笔记体验方案，未果。直到 ta 的出现：<code>Notion</code> 。</p>
        
          <p><a class="excerpt-btn" href="2021/05/20/devops/notion-to-markdown-file-automating-solution/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/DevOps/">DevOps</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Notion/">Notion</a><a href="/tags/知识管理/">知识管理</a><a href="/tags/NotionDown/">NotionDown</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2021/05/20/devops/notion-to-markdown-file-automating-solution/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/04/android-so-loading-2/"><span>动态下发 so 库在 Android APK 安装包瘦身方面的应用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/04/android-so-loading-2/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-04T00:00:00.000Z">
          2018-06-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>众所周知 Android 加载 so 文件本身就是一种运行时动态加载可执行代码的行为，所以把 so 做成动态下发的没有什么技术风险，不过要把这项技术稳定落地到实际生产项目中还是有不少麻烦的问题。本文根据实际项目经验，分享一些 so 动态化关键技术点和需要避免的坑。</p>
        
          <p><a class="excerpt-btn" href="2018/06/04/android-so-loading-2/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/so-库/">so 库</a><a href="/tags/动态加载/">动态加载</a><a href="/tags/插件化/">插件化</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/06/04/android-so-loading-2/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/04/01/devops/incremental-spa/"><span>增量静态检查（SPA）在代码合入检查里的应用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/04/01/devops/incremental-spa/" rel="bookmark">
        <time class="entry-date published" datetime="2018-04-01T00:00:00.000Z">
          2018-04-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <!-- draft
Android 静态代码扫描效率优化与实践 - 美团
[https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA](https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA)
1. 背景
2. 思考
3. 实践
4. 结果
5. 沉淀
6. 总结
文章源代码计划：
1. 高亮
2. 多渠道
3. 注释
-->



<p>静态程序分析，是指在不运行程序的情况下分析检查代码里存在的问题。这项技术在代码质量、漏洞扫描等领域有广泛的使用。常见分析工具包括 CheckStyle、Lint、FindBugs 等，也有商用的 Coverity。本文主要讲述为我们在 Android 项目 Merge Request 合入检查里对静态程序分析技术的应用，核心内容是增量代码的静态分析方案，至于各种检查工具的对比筛选，请参考文末提供的 References。</p>
        
          <p><a class="excerpt-btn" href="2018/04/01/devops/incremental-spa/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/DevOps/">DevOps</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/DevOps/">DevOps</a><a href="/tags/SPA/">SPA</a><a href="/tags/自动化，静态检查/">自动化，静态检查</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/04/01/devops/incremental-spa/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/04/09/android/global-accessing-context/"><span>一种Android应用内全局获取Context实例的装置</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/04/09/android/global-accessing-context/" rel="bookmark">
        <time class="entry-date published" datetime="2017-04-09T00:00:00.000Z">
          2017-04-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>哥白尼・罗斯福・马丁路德・李开复・嫁衣曾经说过</p>
<blockquote>
<p>Where there is an Android App, there is an Application context.</p>
</blockquote>
<p>没毛病，扎心了。App 运行的时候，肯定是存在至少一个 Application 实例的。同时，Context 我们再熟悉不过了，写代码的时候经常需要使用到 Context 实例，它一般是通过构造方法传递进来，通过方法的形式参数传递进来，或者是通过 attach 方法传递进我们需要用到的类。Context 实在是太重要了，以至于我经常恨不得着藏着掖着，随身带着，这样需要用到的时候就能立刻掏出来用用。但是换个角度想想，既然 App 运行的时候，Application 实例总是存在的，那么为何不设置一个全局可以访问的静态方法用于获取 Context 实例，这样以来就不需要上面那些繁琐的传递方式。</p>
<p>说到这里，有的人可能说想这不是我们经常干的好事吗，有必要说的这么玄乎？少侠莫急，请听吾辈徐徐道来。</p>
        
          <p><a class="excerpt-btn" href="2017/04/09/android/global-accessing-context/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/Context/">Context</a><a href="/tags/Hook/">Hook</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/04/09/android/global-accessing-context/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/21/android/naughty-proguard-tuduki/"><span>西方程序员跑得比谁都快</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/21/android/naughty-proguard-tuduki/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-21T00:00:00.000Z">
          2017-03-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>昨天刚刚发表了一篇文章（<a href="http://kaedea.com/2017/03/20/android/naughty-proguard/">ProGuard 又搞了个大新闻</a>），主要吐槽的是项目里面使用 ProGuard 工具导致的一个诡异的坑。其中根本的原因就是，ProGuard 混淆 Java 注解类的时候，把两个方法混淆成同样的名字，导致 dx 工具在打包 <code>.dex</code> 文件的时候报错。</p>
<p>本来以为这件事情算是告一段落了，没想到自己还是太 Naive 了。今天早上突然收到了 ProGuard 开发者发来的一份邮件，Exciting！邮件里谈到了这次的坑出现的真正原因 —— Java 源码和字节码（bytecode）里方法的重载（OverLoading）。</p>
        
          <p><a class="excerpt-btn" href="2017/03/21/android/naughty-proguard-tuduki/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/ProGuard/">ProGuard</a><a href="/tags/Annotation/">Annotation</a><a href="/tags/AGP/">AGP</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/21/android/naughty-proguard-tuduki/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/20/android/naughty-proguard/"><span>ProGuard 又搞了个大新闻</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/20/android/naughty-proguard/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-20T00:00:00.000Z">
          2017-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>一般情况下，Android 项目经常开启 ProGuard 功能来混淆代码，一方面可以降低应用被反编译后代码的友善度，增加被逆向的难度，另一方面开可以通过精简 Java API 的名字来减少代码的总量，从而精简应用编译后的体积。</p>
<p>ProGuard 有个比较坑爹的问题。在开发阶段，我们一般不启用 ProGuard，只有在构建 Release 包的时候才开启。因此，如果有一些 API 被混淆了会出现 BUG，那么在开发阶段我们往往无法察觉 BUG，只有在构建发布包的时候才发现，甚至要等发布到线上了才能发现，这种时候解决问题的成本就很大了。<br>不过今天被 ProGuard 坑的不是混淆 API 导致的 BUG，这货在之前相当长的一段时间里一直相安无事，最近突然又搞了个大新闻，而且问题排查起来相当蹊跷、诡异。</p>
        
          <p><a class="excerpt-btn" href="2017/03/20/android/naughty-proguard/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/ProGuard/">ProGuard</a><a href="/tags/Annotation/">Annotation</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/20/android/naughty-proguard/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="https://github.com/kaedea/comment-formatter" target="_blank"><span>IDEA 注释优化插件：Comment Formatter</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/01/tools/comment-formatter/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-01T00:00:00.000Z">
          2016-12-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//               +---------------------------------------------+</span></span><br><span class="line"><span class="comment">//               | public static final FiledA mFiledA; // xxx  |</span></span><br><span class="line"><span class="comment">//               | private static final FiledB mFiledB; // xxx |</span></span><br><span class="line"><span class="comment">//               | public FiledC mFiledC; // xxx               |</span></span><br><span class="line"><span class="comment">//               | protected final FiledD mFiledD; // xxx      |</span></span><br><span class="line"><span class="comment">//               | FiledE mFiledE; // xxx                      |</span></span><br><span class="line"><span class="comment">//               |                     |                       |</span></span><br><span class="line"><span class="comment">//               |                     v                       |</span></span><br><span class="line"><span class="comment">//               | public static final FiledA mFiledA;  // xxx |</span></span><br><span class="line"><span class="comment">//               | private static final FiledB mFiledB; // xxx |</span></span><br><span class="line"><span class="comment">//               | public FiledC mFiledC;               // xxx |</span></span><br><span class="line"><span class="comment">//               | protected final FiledD mFiledD;      // xxx |</span></span><br><span class="line"><span class="comment">//               | FiledE mFiledE;                      // xxx |</span></span><br><span class="line"><span class="comment">//               +---------------------------------------------+</span></span><br></pre></td></tr></table></figure>


<p>Comment Formatter is an IntelliJ IDEA plugin (also works in Android Studio) that formats comments as above. It will force all the comments to align to the longest one.</p>
<p><strong>Getting Started</strong></p>
<ol>
<li>Install <code>CommentFormatter</code> from <a href="https://github.com/kaedea/comment-formatter/releases" target="_blank" rel="noopener">release</a> or <a href="https://plugins.jetbrains.com/plugin/9337?pr=idea" target="_blank" rel="noopener">IntelliJ Plugin Repository</a>.</li>
<li>Select all the lines which you wanna format.</li>
<li>Select <code>Tool - Format comment</code> or toggle <code>Ctrl + Cmd + L</code> to format.</li>
</ol>
<p><a href="https://github.com/kaedea/comment-formatter" target="_blank" rel="noopener">Check it out</a>.</p>
<!-- Generated by HexoWriter
notion-down.version = 0.1.0
notion-down.revision = b'349007a'
Title = IDEA 注释优化插件：Comment Formatter
Date = 2016-12-01
Published = true
Category = Utility
Tag = ['生产工具', 'IDEA Plugin']
FileLocate = tools
FileName = comment-formatter
hexo.comments = true
hexo.layout = link
hexo.link = https://github.com/kaedea/comment-formatter
-->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Utility/">Utility</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/生产工具/">生产工具</a><a href="/tags/IDEA-Plugin/">IDEA Plugin</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/12/01/tools/comment-formatter/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/22/android/pre-multidex/"><span>通过预安装给 MultiDex 加速</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/22/android/pre-multidex/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-22T00:00:00.000Z">
          2016-11-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在 Android Kikat 及以前的 Android 系统上，构建或安装 Apk 会出现 “<strong>65535 方法数超标 **” 以及 “</strong>INSTALL_FAILED_DEXOPT**” 问题，MultiDex 是 Google 为了解决这个问题问题而开发的一个 Support 库。MultiDex 出现的具体背景、使用方式可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>，而 MultiDex Support 库的工作机制、源码分析可以参考 <a href="http://kaedea.com/2016/11/11/android/multidex-source-code/">MultiDex 工作原理分析和优化方案</a>。</p>
<p>MultiDex 的使用虽然很简单便捷，但是有个比较蛋疼的问题，就是在 App 第一次冷启动的时候会产生明显的卡顿现象。经过测试和统计，根据 Apk 包的大小、Android 系统版本的不同，这个卡顿时间一般是 2000 到 5000 毫秒左右，极端的情况下甚至可以到 20000 + 毫秒。通过之前的分析，我们知道具体的卡顿产生在 MultiDex 解压、优化 dex 这两个过程，而且只在第一次冷启动的时候才会触发这两个过程。那么优化的方式也很简单，在安装 Apk 前先对新版本的 Apk 做好解压和优化工作，就能在安装后第一次冷启动的时候避开这两个耗时的过程了。</p>
        
          <p><a class="excerpt-btn" href="2016/11/22/android/pre-multidex/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/APM/">APM</a><a href="/tags/MultiDex/">MultiDex</a><a href="/tags/启动速度/">启动速度</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/11/22/android/pre-multidex/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/11/android/multidex-source-code/"><span>MultiDex 工作原理分析和优化方案</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/11/android/multidex-source-code/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-11T00:00:00.000Z">
          2016-11-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>动态加载技术（插件化）系列已经坑了有一段时间了，不过 UP 主我并没有放弃治疗哈，相信在不就的未来就可以看到 “系统 Api Hook 模式” 和插件化框架 Frontia 的更新了。今天要讲的是动态加载技术的亲戚 —— MultiDex。他们的核心原理之一都是 dex 文件的加载。</p>
<p>MultiDex 是 Google 为了解决 “<strong>65535 方法数超标 **” 以及 “</strong>INSTALL_FAILED_DEXOPT**” 问题而开发的一个 Support 库，具体如何使用 MultiDex 现在市面已经有一大堆教程（可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>），这里不再赘述。这篇日志主要是配合源码分析 MultiDex 的工作原理，以及提供一些 MultiDex 优化的方案。</p>
        
          <p><a class="excerpt-btn" href="2016/11/11/android/multidex-source-code/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/源码分析/">源码分析</a><a href="/tags/MultiDex/">MultiDex</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/11/11/android/multidex-source-code/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Kaede Akatsuki
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'G-J38N5N288S', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>