<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ClassLoader 的工作机制 | Kaede Akatsuki | 中二病也要开发 Android</title>

  
  <meta name="author" content="Kaede Akatsuki">
  

  
  <meta name="description" content="A TASTE OF ACG (Anime/Coding/Games).">
  

  
  
  <meta name="keywords" content="Android,动态化,ClassLoader">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="ClassLoader 的工作机制"/>

  <meta property="og:site_name" content="Kaede Akatsuki"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kaede Akatsuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Kaede Akatsuki</a>
    </h1>
    <p class="site-description">中二病也要开发 Android</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>ClassLoader 的工作机制</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/07/android-dynamical-loading-02-classloader/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-07T00:00:00.000Z">
          2016-02-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>早期使用过 Eclipse 等 Java 编写的软件的同学可能比较熟悉，Eclipse 可以加载许多第三方的插件（或者叫扩展），这就是动态加载。这些插件大多是一些 Jar 包，而使用插件其实就是动态加载 Jar 包里的 Class 进行工作。这其实非常好理解，Java 代码都是写在 Class 里面的，程序运行在虚拟机上时，虚拟机需要把需要的 Class 加载进来才能创建实例对象并工作，而完成这一个加载工作的角色就是 ClassLoader。</p>
<a id="more"></a>

<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul>
<li>Author : <a href="https://github.com/kaedea" target="_blank" rel="noopener">Kaede</a><ul>
<li>Index : <a href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index">ANDROID 动态加载系列</a></li>
</ul>
</li>
<li>GitHub : <a href="https://github.com/kaedea/android-dynamical-loading" target="_blank" rel="noopener">kaedea/android-dynamical-loading</a></li>
</ul>
<h2 id="类加载器-ClassLoader"><a href="#类加载器-ClassLoader" class="headerlink" title="类加载器 ClassLoader"></a>类加载器 ClassLoader</h2><blockquote>
<p>对于 Java 程序来说，编写程序就是编写类，运行程序也就是运行类（编译得到的 class 文件），其中起到关键作用的就是类加载器 ClassLoader。</p>
</blockquote>
<p>Android 的 Dalvik/ART 虚拟机如同标准 JAVA 的 JVM 虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。因此，我们可以利用这一点，在程序运行时手动加载 Class，从而达到代码动态加载可执行文件的目的。Android 的 Dalvik/ART 虚拟机虽然与标准 Java 的 JVM 虚拟机不一样，ClassLoader 具体的加载细节不一样，但是工作机制是类似的，也就是说在 Android 中同样可以采用类似的动态加载插件的功能，只是在 Android 应用中动态加载一个插件的工作要比 Eclipse 加载一个插件复杂许多（这点后面在解释说明）。</p>
<h2 id="有几个-ClassLoader-实例？"><a href="#有几个-ClassLoader-实例？" class="headerlink" title="有几个 ClassLoader 实例？"></a>有几个 ClassLoader 实例？</h2><p>** 动态加载的基础是 ClassLoader*<em>，从名字也可以看出，ClassLoader 就是专门用来处理类加载工作的，所以这货也叫类加载器，而且一个运行中的 APP *</em> 不仅只有一个类加载器 **。<br>其实，在 Android 系统启动的时候会创建一个 Boot 类型的 ClassLoader 实例，用于加载一些系统 Framework 层级需要的类，我们的 Android 应用里也需要用到一些系统的类，所以 APP 启动的时候也会把这个 Boot 类型的 ClassLoader 传进来。<br>此外，APP 也有自己的类，这些类保存在 APK 的 dex 文件里面，所以 APP 启动的时候，也会创建一个自己的 ClassLoader 实例，用于加载自己 dex 文件中的类。下面我们在项目里验证看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	ClassLoader classLoader = getClassLoader();</span><br><span class="line">	<span class="keyword">if</span> (classLoader != <span class="keyword">null</span>)&#123;</span><br><span class="line">		Log.i(TAG, <span class="string">"[onCreate] classLoader "</span> + i + <span class="string">" : "</span> + classLoader.toString());</span><br><span class="line">		<span class="keyword">while</span> (classLoader.getParent()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			classLoader = classLoader.getParent();</span><br><span class="line">			Log.i(TAG,<span class="string">"[onCreate] classLoader "</span> + i + <span class="string">" : "</span> + classLoader.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果为</p>
<figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[onCreate] classLoader 1 : dalvik.system.PathClassLoader[DexPathList[[zip file &quot;&#x2F;data&#x2F;app&#x2F;me.kaede.anroidclassloadersample-1&#x2F;base.apk&quot;],nativeLibraryDirectories&#x3D;[&#x2F;vendor&#x2F;lib, &#x2F;system&#x2F;lib]]]</span><br><span class="line"></span><br><span class="line">[onCreate] classLoader 2 : java.lang.BootClassLoader@14af4e32</span><br></pre></td></tr></table></figure>


<p>可以看见有 2 个 Classloader 实例，一个是 BootClassLoader（系统启动的时候创建的），另一个是 PathClassLoader（应用启动时创建的，用于加载 “/data/app/me.kaede.anroidclassloadersample-1/base.apk” 里面的类）。由此也可以看出，** 一个运行的 Android 应用至少有 2 个 ClassLoader**。</p>
<h2 id="创建自己-ClassLoader-实例"><a href="#创建自己-ClassLoader-实例" class="headerlink" title="创建自己 ClassLoader 实例"></a>创建自己 ClassLoader 实例</h2><p>动态加载外部的 dex 文件的时候，我们也可以使用自己创建的 ClassLoader 实例来加载 dex 里面的 Class，不过 ClassLoader 的创建方式有点特殊，我们先看看它的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * constructor for the BootClassLoader which needs parent to be null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ClassLoader(ClassLoader parentLoader, <span class="keyword">boolean</span> nullAllowed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentLoader == <span class="keyword">null</span> &amp;&amp; !nullAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"parentLoader == null &amp;&amp; !nullAllowed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        parent = parentLoader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>创建一个 ClassLoader 实例的时候，需要使用一个现有的 ClassLoader 实例作为新创建的实例的 Parent。这样一来，一个 Android 应用，甚至整个 Android 系统里所有的 ClassLoader 实例都会被一棵树关联起来，这也是 ClassLoader 的 ** 双亲代理模型 **（Parent-Delegation Model）的特点。</p>
<h2 id="ClassLoader-双亲代理模型加载类的特点和作用"><a href="#ClassLoader-双亲代理模型加载类的特点和作用" class="headerlink" title="ClassLoader 双亲代理模型加载类的特点和作用"></a>ClassLoader 双亲代理模型加载类的特点和作用</h2><p>JVM 中 ClassLoader 通过 defineClass 方法加载 jar 里面的 Class，而 Android 中这个方法被弃用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="keyword">byte</span>[] classRep, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"can't load this type of class file"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>取而代之的是 loadClass 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            suppressed = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>从源码中我们也可以看出，loadClass 方法在加载一个类的实例的时候，</p>
<ol>
<li>会先查询当前 ClassLoader 实例是否加载过此类，有就返回；</li>
<li>如果没有。查询 Parent 是否已经加载过此类，如果已经加载过，就直接返回 Parent 加载的类；</li>
<li>如果继承路线上的 ClassLoader 都没有加载，才由 Child 执行类的加载工作；</li>
</ol>
<p>这样做有个明显的特点，如果一个类被位于树根的 ClassLoader 加载过，那么在以后整个系统的生命周期内，这个类永远不会被重新加载。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>首先是共享功能，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。<br>除此之外还有隔离功能，不同继承路线上的 ClassLoader 加载的类肯定不是同一个类，这样的限制避免了用户自己的代码冒充核心类库的类访问核心类库包可见成员的情况。这也好理解，一些系统层级的类会在系统初始化的时候被加载，比如 java.lang.String，如果在一个应用里面能够简单地用自定义的 String 类把这个系统的 String 类给替换掉，那将会有严重的安全问题。</p>
<h2 id="使用-ClassLoader-一些需要注意的问题"><a href="#使用-ClassLoader-一些需要注意的问题" class="headerlink" title="使用 ClassLoader 一些需要注意的问题"></a>使用 ClassLoader 一些需要注意的问题</h2><p>我们都知道，我们可以通过动态加载获得新的类，从而升级一些代码逻辑，这里有几个问题要注意一下。<br>如果你希望通过动态加载的方式，加载一个新版本的 dex 文件，使用里面的新类替换原有的旧类，从而修复原有类的 BUG，那么你必须保证在加载新类的时候，旧类还没有被加载，因为如果已经加载过旧类，那么 ClassLoader 会一直优先使用旧类。<br>如果旧类总是优先于新类被加载，我们也可以使用一个与加载旧类的 ClassLoader 没有树的继承关系的另一个 ClassLoader 来加载新类，因为 ClassLoader 只会检查其 Parent 有没有加载过当前要加载的类，如果两个 ClassLoader 没有继承关系，那么旧类和新类都能被加载。<br>不过这样一来又有另一个问题了，在 Java 中，只有当两个实例的类名、包名以及加载其的 ClassLoader 都相同，才会被认为是同一种类型。上面分别加载的新类和旧类，虽然包名和类名都完全一样，但是由于加载的 ClassLoader 不同，所以并不是同一种类型，在实际使用中可能会出现类型不符异常。</p>
<blockquote>
<p>同一个 Class = 相同的 ClassName + PackageName + ClassLoader</p>
</blockquote>
<p>以上问题在采用动态加载功能的开发中容易出现，请注意。</p>
<h2 id="DexClassLoader-和-PathClassLoader"><a href="#DexClassLoader-和-PathClassLoader" class="headerlink" title="DexClassLoader 和 PathClassLoader"></a>DexClassLoader 和 PathClassLoader</h2><p>在 Android 中，ClassLoader 是一个抽象类，实际开发过程中，我们一般是使用其具体的子类 DexClassLoader、PathClassLoader 这些类加载器来加载类的，它们的不同之处是：</p>
<ul>
<li>DexClassLoader 可以加载 jar/apk/dex，可以从 SD 卡中加载未安装的 apk；</li>
<li>PathClassLoader 只能加载系统中已经安装过的 apk；</li>
</ul>
<h2 id="类加载器的初始化"><a href="#类加载器的初始化" class="headerlink" title="类加载器的初始化"></a>类加载器的初始化</h2><p>平时开发的时候，使用 DexClassLoader 就够用了，但是我们不妨挖一下这两者具体细节上的区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DexClassLoader.javapublic class DexClassLoader extends BaseDexClassLoader &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PathClassLoader.javapublic class PathClassLoader extends BaseDexClassLoader &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, <span class="keyword">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PathClassLoader</span><span class="params">(String dexPath, String libraryPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">null</span>, libraryPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这两者只是简单的对 BaseDexClassLoader 做了一下封装，具体的实现还是在父类里。不过这里也可以看出，PathClassLoader 的 optimizedDirectory 只能是 null，进去 BaseDexClassLoader 看看这个参数是干什么的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.originalPath = dexPath;</span><br><span class="line">        <span class="keyword">this</span>.pathList = <span class="keyword">new</span> DexPathList(<span class="keyword">this</span>, dexPath, libraryPath, optimizedDirectory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>这里创建了一个 DexPathList 实例，进去看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,</span></span></span><br><span class="line"><span class="function"><span class="params">            String libraryPath, File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        ……</span><br><span class="line">        <span class="keyword">this</span>.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            ZipFile zip = <span class="keyword">null</span>;</span><br><span class="line">            DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                    || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">                zip = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">            &#125;</span><br><span class="line">            ……</span><br><span class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Converts a dex/jar file path and an output directory to an</span></span><br><span class="line"><span class="comment">     * output file path for an associated optimized dex file.</span></span><br><span class="line"><span class="comment">     */</span><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">optimizedPathFor</span><span class="params">(File path,</span></span></span><br><span class="line"><span class="function"><span class="params">            File optimizedDirectory)</span> </span>&#123;</span><br><span class="line">        String fileName = path.getName();</span><br><span class="line">        <span class="keyword">if</span> (!fileName.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">            <span class="keyword">int</span> lastDot = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">            <span class="keyword">if</span> (lastDot &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                fileName += DEX_SUFFIX;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder(lastDot + <span class="number">4</span>);</span><br><span class="line">                sb.append(fileName, <span class="number">0</span>, lastDot);</span><br><span class="line">                sb.append(DEX_SUFFIX);</span><br><span class="line">                fileName = sb.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        File result = <span class="keyword">new</span> File(optimizedDirectory, fileName);</span><br><span class="line">        <span class="keyword">return</span> result.getPath();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>看到这里我们明白了，optimizedDirectory 是用来缓存我们需要加载的 dex 文件的，并创建一个 DexFile 对象，如果它为 null，那么会直接使用 dex 文件原有的路径来创建 DexFile 对象。</p>
<p>optimizedDirectory 必须是一个内部存储路径，还记得我们之前说过的，无论哪种动态加载，加载的可执行文件一定要存放在内部存储。DexClassLoader 可以指定自己的 optimizedDirectory，所以它可以加载外部的 dex，因为这个 dex 会被复制到内部路径的 optimizedDirectory；而 PathClassLoader 没有 optimizedDirectory，所以它只能加载内部的 dex，这些大都是存在系统中已经安装过的 apk 里面的。</p>
<h2 id="加载类的过程"><a href="#加载类的过程" class="headerlink" title="加载类的过程"></a>加载类的过程</h2><p>上面还只是创建了类加载器的实例，其中创建了一个 DexFile 实例，用来保存 dex 文件，我们猜想这个实例就是用来加载类的。</p>
<p>Android 中，ClassLoader 用 loadClass 方法来加载我们需要的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">      <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              suppressed = e;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  clazz = findClass(className);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                  e.addSuppressed(suppressed);</span><br><span class="line">                  <span class="keyword">throw</span> e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clazz;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<p>loadClass 方法调用了 findClass 方法，而 BaseDexClassLoader 重载了这个方法，得到 BaseDexClassLoader 看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = pathList.findClass(name);</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>结果还是调用了 DexPathList 的 findClass</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class clazz = dex.loadClassBinaryName(name, definingContext);</span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里遍历了之前所有的 DexFile 实例，其实也就是遍历了所有加载过的 dex 文件，再调用 loadClassBinaryName 方法一个个尝试能不能加载想要的类，真是简单粗暴</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defineClass(name, loader, mCookie);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span>;</span><br></pre></td></tr></table></figure>


<p>看到这里想必大家都明白了，loadClassBinaryName 中调用了 Native 方法 defineClass 加载类。<br>至此，ClassLoader 的创建和加载类的过程的完成了。有趣的是，标准 JVM 中，ClassLoader 是用 defineClass 加载类的，而 Android 中 defineClass 被弃用了，改用了 loadClass 方法，而且加载类的过程也挪到了 DexFile 中，在 DexFile 中加载类的具体方法也叫 defineClass，不知道是 Google 故意写成这样的还是巧合。</p>
<h2 id="自定义-ClassLoader"><a href="#自定义-ClassLoader" class="headerlink" title="自定义 ClassLoader"></a>自定义 ClassLoader</h2><p>平时进行动态加载开发的时候，使用 DexClassLoader 就够了。但我们也可以创建自己的类去继承 ClassLoader，需要注意的是 loadClass 方法并不是 final 类型的，所以我们可以重载 loadClass 方法并改写类的加载逻辑。<br>通过前面我们分析知道，ClassLoader 双亲代理的实现很大一部分就是在 loadClass 方法里，我们可以通过重写 loadClass 方法避开双亲代理的框架，这样一来就可以在重新加载已经加载过的类，也可以在加载类的时候注入一些代码。这是一种 Hack 的开发方式，采用这种开发方式的程序稳定性可能比较差，但是却可以实现一些 “黑科技” 的功能。</p>
<h2 id="Android-程序比起一般-Java-程序在使用动态加载时麻烦在哪里"><a href="#Android-程序比起一般-Java-程序在使用动态加载时麻烦在哪里" class="headerlink" title="Android 程序比起一般 Java 程序在使用动态加载时麻烦在哪里"></a>Android 程序比起一般 Java 程序在使用动态加载时麻烦在哪里</h2><p>通过上面的分析，我们知道使用 ClassLoader 动态加载一个外部的类是非常容易的事情，所以很容易就能实现动态加载新的可执行代码的功能，但是比起一般的 Java 程序，在 Android 程序中使用动态加载主要有两个麻烦的问题：</p>
<ol>
<li>Android 中许多组件类（如 Activity、Service 等）是需要在 Manifest 文件里面注册后才能工作的（系统会检查该组件有没有注册），所以即使动态加载了一个新的组件类进来，没有注册的话还是无法工作；</li>
<li>Res 资源是 Android 开发中经常用到的，而 Android 是把这些资源用对应的 R.id 注册好，运行时通过这些 ID 从 Resource 实例中获取对应的资源。如果是运行时动态加载进来的新类，那类里面用到 R.id 的地方将会抛出找不到资源或者用错资源的异常，因为新类的资源 ID 根本和现有的 Resource 实例中保存的资源 ID 对不上；</li>
</ol>
<p>说到底，抛开虚拟机的差别不说，** 一个 Android 程序和标准的 Java 程序最大的区别就在于他们的上下文环境（Context）不同 **。Android 中，这个环境可以给程序提供组件需要用到的功能，也可以提供一些主题、Res 等资源，其实上面说到的两个问题都可以统一说是这个环境的问题，而现在的各种 Android 动态加载框架中，核心要解决的东西也正是 “如何给外部的新类提供上下文环境” 的问题。</p>
<!-- Generated by HexoWriter
notion-down.version = 0.1.0
notion-down.revision = b'349007a'
Title = ClassLoader 的工作机制
Date = 2016-02-07 00:00:00
Published = true
Category = Android
Tag = ['Android', '动态化', 'ClassLoader']
FileLocate = 
FileName = android-dynamical-loading-02-classloader
hexo.comments = true
hexo.metaAlignment = center
-->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/动态化/">动态化</a><a href="/tags/ClassLoader/">ClassLoader</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'kidhaibara';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Kaede Akatsuki
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>