<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>通过预安装给 MultiDex 加速 | Kaede Akatsuki | 中二病也要开发 Android</title>

  
  <meta name="author" content="Kaede Akatsuki">
  

  
  <meta name="description" content="A TASTE OF ACG (Anime/Coding/Games).">
  

  
  
  <meta name="keywords" content="Android,APM,MultiDex,启动速度">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="通过预安装给 MultiDex 加速">

  <meta property="og:site_name" content="Kaede Akatsuki">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kaede Akatsuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Kaede Akatsuki</a>
    </h1>
    <p class="site-description">中二病也要开发 Android</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>通过预安装给 MultiDex 加速</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/22/android/pre-multidex/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-22T00:00:00.000Z">
          2016-11-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在 Android Kikat 及以前的 Android 系统上，构建或安装 Apk 会出现 “<strong>65535 方法数超标 </strong>” 以及 “<strong>INSTALL_FAILED_DEXOPT</strong>” 问题，MultiDex 是 Google 为了解决这个问题问题而开发的一个 Support 库。MultiDex 出现的具体背景、使用方式可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>，而 MultiDex Support 库的工作机制、源码分析可以参考 <a href="http://kaedea.com/2016/11/11/android/multidex-source-code/">MultiDex 工作原理分析和优化方案</a>。</p>
<p>MultiDex 的使用虽然很简单便捷，但是有个比较蛋疼的问题，就是在 App 第一次冷启动的时候会产生明显的卡顿现象。经过测试和统计，根据 Apk 包的大小、Android 系统版本的不同，这个卡顿时间一般是 2000 到 5000 毫秒左右，极端的情况下甚至可以到 20000 + 毫秒。通过之前的分析，我们知道具体的卡顿产生在 MultiDex 解压、优化 dex 这两个过程，而且只在第一次冷启动的时候才会触发这两个过程。那么优化的方式也很简单，在安装 Apk 前先对新版本的 Apk 做好解压和优化工作，就能在安装后第一次冷启动的时候避开这两个耗时的过程了。</p>
<a id="more"></a>
<h2 id="MultiDex-是如何判断是否需要重新解压和优化-dex-的"><a href="#MultiDex-是如何判断是否需要重新解压和优化-dex-的" class="headerlink" title="MultiDex 是如何判断是否需要重新解压和优化 dex 的"></a>MultiDex 是如何判断是否需要重新解压和优化 dex 的</h2><p>在之前的章节里面讲到，MultiDex 在第一次做完解压和优化 dex 之后，会保留当前 Apk 的一些信息，下一次启动时候后读取这些配置信息再判断是否需要重新解压和优化 dex 文件。<br>这个判断主要是在 MultiDexExtractor#load (Context, ApplicationInfo, File, boolean) 方法里进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ...</span><br><span class="line">                files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                putStoredApkInfo(context,</span><br><span class="line">                        getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次调用这个方法的时候，forceReload 为 false，则不需要强制重新解压 dex。然后调用了 <code>isModified</code> 这个方法判断当前 App 的 Apk 包是否被修改过。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isModified</span><span class="params">(Context context, File archive, <span class="keyword">long</span> currentCrc)</span> </span>&#123;</span><br><span class="line">    SharedPreferences prefs = getMultiDexPreferences(context);</span><br><span class="line">    <span class="keyword">return</span> (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))</span><br><span class="line">            || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isModified</code> 方法主要是判断当前 App 的 Apk 包的 CRC 值是否和上一次解压 dex 时记录的 Apk 包 CRC 一样（CRC 值可以认为是一个稀疏的 MD5 算法，它的时间复杂度低很多，但是计算结果容易产生冲突），以及 Apk 文件的修改时间（文件的 Last Modified Time）是否一致。如果这两项都一致的话就认为 Apk 文件没有产生变化（没有覆盖安装过），因此上一次解压和优化 dex 得到的缓存文件可以复用。</p>
<p>当然，光 Apk 包没有修改过这一项条件还不够，接下来调用了这个判断主要是在 MultiDexExtractor#loadExistingExtractions (Context, File, File)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">loadExistingExtractions</span><span class="params">(Context context, File sourceApk, File dexDir)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line">    <span class="keyword">int</span> totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;File&gt;(totalDexNumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> secondaryNumber = <span class="number">2</span>; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">        File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">        <span class="keyword">if</span> (extractedFile.isFile()) &#123;</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line">            <span class="keyword">if</span> (!verifyZipFile(extractedFile)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Invalid ZIP file."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing extracted secondary dex file '"</span> +</span><br><span class="line">                    extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先通过 SharePreference 读取上一次 MultiDex 保存的 Apk 包的 dex 数量 totalDexNumber，然后挨个加载预定的文件路径上的 dex 文件，加载文件的的同时还通过 <code>verifyZipFile</code> 方法判断 dex 文件的合法性。如果这个过程出现异常就认为获取上一次缓存的 dex 文件失败，需要重新解压。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyZipFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zipFile.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to close zip file: "</span> + file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZipException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"File "</span> + file.getAbsolutePath() + <span class="string">" is not a valid zip file."</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Got an IOException trying to open zip file: "</span> + file.getAbsolutePath(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>verifyZipFile</code> 这个方法非常简单，解压 dex 文件的时候，解压出来的文件被保存成 Zip 包，这个方法这是检查缓存的 dex 文件是否是 Zip 包。感觉不靠谱，虽然检查 MD5 值比较耗时不适合这种情景，不过好歹也像检查 Apk 包的 CRC 值和修改时间一样，检查 dex 缓存文件的 CRC 和修改时间啊。不过读取 SharePreference 配置是一个 IO 操作，如果保存的数值太多的话，也是有增加耗时和 IO 异常的风险的。</p>
<p>到这里我们的方案就清晰了：</p>
<ol>
<li>在安装新 Apk 前，先做好 dex 的解压和优化，得到 dex 压缩包（.zip）列表和 dexopt 后的 odex 文件（.dex）列表。</li>
<li>把 dex/odex 文件保存到一个内部存储路径 PATH_A，同时使用 SP 记录新版本 Apk 的 CRC、dex 数量，以及解压出来的每一个 dex 的 CRC 值。</li>
<li>安装新版本 Apk 后，启动时在执行 MultiDex 前，把 PATH_A 路径上的缓存文件移动（rename）到 MultiDex 的缓存路径 PATH_B 上，同时保存当前 Apk 的 CRC、修改时间以及 dex 数量到 MultiDex 对应的 SP 配置上。</li>
<li>执行原有 MultiDex 逻辑，让 MultiDex 以为之前已经做过解压和优化 dex 工作，从而绕开第一次 MultiDex 时候的耗时。</li>
<li>第一次成功启动新 Apk 后，对 dex 进行校验工作，如果校验失败则清除 dex 缓存，强制让 App 在下一次启动的时候再执行一遍 MultiDex。</li>
</ol>
<h2 id="预解压（PreMultiDex）详细的流程图"><a href="#预解压（PreMultiDex）详细的流程图" class="headerlink" title="预解压（PreMultiDex）详细的流程图"></a>预解压（PreMultiDex）详细的流程图</h2><p>注：</p>
<ol>
<li>流程图的绿色部分为文件锁（FileLock）操作，主要是为了多进程同步。</li>
<li>红色部分为耗时的操作。</li>
<li>Dex 路径为 MultiDex 过程中用于存储解压出来的 dex 文件的路径（/data/data//code_cache）。</li>
<li>PreDex 路径为存储预解压得到的缓存文件的内部路径（/data/data//code_cache_pre）。</li>
<li>MultiDex 从 Apk 包解压出来的 dex 文件会被压缩成 Zip 包（.zip），而执行 dexopt 操作后生成的 odex 文件文件名为.dex，这两个容易搞混。</li>
</ol>
<h3 id="安装新-Apk-前先解压和优化-dex"><a href="#安装新-Apk-前先解压和优化-dex" class="headerlink" title="安装新 Apk 前先解压和优化 dex"></a>安装新 Apk 前先解压和优化 dex</h3><p>这个环节必须在升级 Apk 前，由旧版本的 Apk 进行，也就是要求 App 拥有 <strong> 自主更新 </strong> 的逻辑。</p>
<p><img src="/assets/006y8lvagw1fam9ukwfv1j30jr0vvgpm.jpg" alt></p>
<h3 id="第一次运行新-Apk-时，移动预先安装好的-dex-文件"><a href="#第一次运行新-Apk-时，移动预先安装好的-dex-文件" class="headerlink" title="第一次运行新 Apk 时，移动预先安装好的 dex 文件"></a>第一次运行新 Apk 时，移动预先安装好的 dex 文件</h3><p>从旧版的 Apk 覆盖安装新的 Apk 后，第一次运行 App 时 MultiDex 主要的耗时过程。这时需要把在旧版本 Apk 预安装得到的 dex 缓存文件移动到 MultiDex 使用的存储路径上。</p>
<p><img src="/assets/006y8lvagw1fam9pz6n4rj30kr19aq9o.jpg" alt></p>
<h3 id="第一次运行新-Apk-后，检查-dex-文件是否正确"><a href="#第一次运行新-Apk-后，检查-dex-文件是否正确" class="headerlink" title="第一次运行新 Apk 后，检查 dex 文件是否正确"></a>第一次运行新 Apk 后，检查 dex 文件是否正确</h3><p>原有的 MultiDex，dex 文件时同步从 Apk 包里解压出来的，所以不存在 dex 文件和 Apk 版本对不上的问题。而 <strong>PreMultiDex</strong> 的方案的一个问题 ui 是，解压 dex 文件和使用 dex 文件这两个过程是分开的，无论版本控制做得再精确，理论上也存在版本出错的问题（比如从 A 版本解压得到了 dex 文件，而用户却选择覆盖安装了 B 版本，这时候由于代码逻辑的不严谨导致 B 版本的 Apk 使用了 A 版本解压出来的 dex 文件）。如果想要确保 dex 文件的正确性，需要对 Apk 包里面的 dex 文件和解压出来的 dex 文件做一下 MD5 值校验，而这个过程比较耗时，不适合在 App 启动的时候做，不然 <strong>PreMultiDex</strong> 就失去了意义。因此，需要在第一次运行新 Apk 后，启动 dex 的校验工作，在 Worker 线程对 dex 进行校验，如果校验失败则清除 dex 缓存，强制让 App 在下一次启动的时候再执行一遍 MultiDex。</p>
<p><img src="/assets/006y8lvagw1fam9polrlrj30k313jwjf.jpg" alt></p>
<h3 id="恢复-MultiDex"><a href="#恢复-MultiDex" class="headerlink" title="恢复 MultiDex"></a>恢复 MultiDex</h3><p>在 MultiDex 校验失败后，需要清空 MultiDex 的缓存文件，禁用 <strong>PreMultiDex</strong> 功能，并且强制让 App 在下一次启动的时候再执行一遍 MultiDex。</p>
<p><img src="/assets/006y8lvagw1fam9pce8p3j30dt0lognc.jpg" alt></p>
<h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><h3 id="dex-文件、odex-文件？"><a href="#dex-文件、odex-文件？" class="headerlink" title="dex 文件、odex 文件？"></a>dex 文件、odex 文件？</h3><p>dex 文件是 Android 虚拟机使用的可执行文件（从 Java 类编译得到），相当于 JVM 虚拟机用的 class 文件。但是与 class 文件不同，Android 系统并不能直接使用 dex 文件，需要先使用 dexopt 工具对 dex 文件进行一次优化工作（Optimize），优化得到的 odex 文件才能被虚拟机加载。不同的 Android 设备需要不同格式的 odex 文件，所以这个过程只能在 Android 设备上进行，而不能在构建 Apk 的时候就处理好。</p>
<p>dex 文件在 Apk 包里的文件后缀名是 <strong>.dex</strong>，MultiDex 从 Apk 包里解压出 dex 文件后会压缩成 Zip 包，文件后缀名是 <strong>.zip</strong>。对 dex 文件进行 dexopt 操作后，会生成相同文件名的 odex 文件，后缀名是 <strong>.dex</strong>，odex 文件会比 dex 文件大许多，不要搞混这些文件。</p>
<p>至于为什么 MultiDex 解压 dex 文件时会进行压缩工作，可能是因为压缩后的压缩包会占用比较小的内部存储空间，因为 MultiDex 本来就是给旧版本的 Android 系统使用，一些早期的 Android 设备拥有的内部存储空间非常有限，而这些 dex 文件对于 App 的运行时必须的，所以才需要尽量压缩 dex 的体积。压缩过程会有明显的耗时，经过测试，如果不进行压缩，直接从 Apk 里解压 dex 文件，则 MultiDex 过程会有大约 <strong>1/3</strong> 的加速效果。</p>
<h3 id="dexopt-缓存"><a href="#dexopt-缓存" class="headerlink" title="dexopt 缓存"></a>dexopt 缓存</h3><p>MultiDex 其实并没有刻意保留 dexopt 后的缓存，如果只保留 dex 文件，而不保留 odex 文件，那么下一次启动执行 MultiDex 的时候，不需要重新解压 dex 文件，但是依然需要 dexopt 并产生 odex 文件，这个过程大概会占用 MultiDex 总耗时的一般左右。如果 odex 文件存在，但是已经损坏了，或者是一个非法的 odex 文件，依然会触发 dexopt 工作。也就是说，加载 dex 文件并创建 DexFile 对象的时候，Android 系统会判断 odex 的缓存，以及缓存文件是否正确，具体过程在 <a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a> 里实现，有兴趣的同学可以找找 dex 文件结构分析的文章，这里就不挖坑了。</p>
<h3 id="关于-dex-文件校验"><a href="#关于-dex-文件校验" class="headerlink" title="关于 dex 文件校验"></a>关于 dex 文件校验</h3><p>其实，如果 dex 文件和 Apk 的版本对不上的话，一般在启动 App 的时候就会出现 ClassNotFound 异常而导致 App 崩溃，接着再次启动由于没有重新 MultiDex 也会继续崩溃。而崩溃的时候，可能 App 崩溃上报系统还没来得及初始化，所以没有办法发现崩溃的问题。</p>
<p>为了防止这种问题，可以开发一个 <strong> 恢复模式 </strong> 或者 <strong> 安全模式 </strong> 的功能，当 App 出现连续的崩溃的时候，会进入恢复模式的状态，清空一些可能导致异常的数据（比如 PreMultiDex 的缓存），这样就能避免 App 因为连续崩溃而不能使用。至于怎么实现恢复，这已经是另一个领域的功能了，这里不再展开。<br>参考链接： <a href="https://android.googlesource.com/platform/frameworks/multidex/" target="_blank" rel="noopener">Google Multidex</a></p>
<!-- Generated by HexoWriter
notion-down.version = 0.1.0
notion-down.revision = b'074303e'
Title = 通过预安装给 MultiDex 加速
Date = 2016-11-22 00:00:00
Published = true
Category = Android
Tag = ['Android', 'MultiDex', 'APM', '启动速度']
FileLocate = android
FileName = pre-multidex
hexo.comments = true
-->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/APM/">APM</a><a href="/tags/MultiDex/">MultiDex</a><a href="/tags/启动速度/">启动速度</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'kidhaibara';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">NotionDown</a> and
    Theme by <a href="https://github.com/kaedea/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Kaede Akatsuki
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'G-J38N5N288S', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>