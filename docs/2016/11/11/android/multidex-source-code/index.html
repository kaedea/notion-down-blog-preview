<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MultiDex 工作原理分析和优化方案 | Kaede Akatsuki | 中二病也要开发 Android</title>

  
  <meta name="author" content="Kaede Akatsuki">
  

  
  <meta name="description" content="A TASTE OF ACG (Anime/Coding/Games).">
  

  
  
  <meta name="keywords" content="Android,源码分析,MultiDex">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="MultiDex 工作原理分析和优化方案"/>

  <meta property="og:site_name" content="Kaede Akatsuki"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kaede Akatsuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Kaede Akatsuki</a>
    </h1>
    <p class="site-description">中二病也要开发 Android</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>MultiDex 工作原理分析和优化方案</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/11/android/multidex-source-code/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-11T00:00:00.000Z">
          2016-11-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>动态加载技术（插件化）系列已经坑了有一段时间了，不过 UP 主我并没有放弃治疗哈，相信在不就的未来就可以看到 “系统 Api Hook 模式” 和插件化框架 Frontia 的更新了。今天要讲的是动态加载技术的亲戚 —— MultiDex。他们的核心原理之一都是 dex 文件的加载。</p>
<p>MultiDex 是 Google 为了解决 “<strong>65535 方法数超标 **” 以及 “</strong>INSTALL_FAILED_DEXOPT**” 问题而开发的一个 Support 库，具体如何使用 MultiDex 现在市面已经有一大堆教程（可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>），这里不再赘述。这篇日志主要是配合源码分析 MultiDex 的工作原理，以及提供一些 MultiDex 优化的方案。</p>
<a id="more"></a>

<h2 id="Dex-的工作机制"><a href="#Dex-的工作机制" class="headerlink" title="Dex 的工作机制"></a>Dex 的工作机制</h2><p>等等，这个章节讲的不是 MultiDex 吗，怎么变成 Dex 了？没错哈，没有 Dex，哪来的 MultiDex。在 Android 中，对 Dex 文件操作对应的类叫做 DexFile。在 <a href="http://kaedea.com/2016/02/07/android-dynamical-loading-02-classloader/">CLASSLOADER 的工作机制</a> 中，我们说到：</p>
<blockquote>
<p>对于 Java 程序来说，编写程序就是编写类，运行程序也就是运行类（编译得到的 class 文件），其中起到关键作用的就是类加载器 ClassLoader。</p>
</blockquote>
<p>Android 程序的每一个 Class 都是由 ClassLoader#loadClass 方法加载进内存的，更准确来说，** 一个 ClassLoader 实例会有一个或者多个 DexFile 实例 **，调用了 ClassLoader#loadClass 之后，ClassLoader 会通过类名，在自己的 DexFile 数组里面查找有没有那个 DexFile 对象里面存在这个类，如果都没有就抛 ClassNotFound 异常。ClassLoader 通过调用 DexFile 的一个叫 defineClass 的 Native 方法去加载指定的类，这点与 JVM 略有不同，后者是直接调用 ClassLoader#defineCLass 方法，反正最后实际加载类的方法都叫 defineClass 就没错了🌝。</p>
<h3 id="创建-DexFile-对象"><a href="#创建-DexFile-对象" class="headerlink" title="创建 DexFile 对象"></a>创建 DexFile 对象</h3><p>首先来看看造 DexFile 对象的构方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCookie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mFileName;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(file.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mCookie = openDexFile(fileName, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        mFileName = fileName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">        mFileName = sourceName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        String slashName = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">return</span> loadClassBinaryName(slashName, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(<span class="keyword">byte</span>[] fileContents)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>


<p>通过以前分析过的源码，我们知道 ClassLoader 主要是通过 DexFile.loadDex 这个静态方法来创建它需要的 DexFile 实例的，这里创建 DexFile 的时候，保存了 Dex 文件的文件路径 mFileName，** 同时调用了 openDexFile 的 Native 方法打开 Dex 文件 ** 并返回了一个 mCookie 的整型变量（我不知道这个干啥用的，我猜它是一个 C++ 用的资源句柄，用于 Native 层访问具体的 Dex 文件）。在 Native 层的 openDexFile 方法里，主要做了检查当前创建来的 Dex 文件是否是有效的 Dex 文件，还是是一个带有 Dex 文件的压缩包，还是一个无效的 Dex 文件。</p>
<h3 id="加载-Dex-文件里的类"><a href="#加载-Dex-文件里的类" class="headerlink" title="加载 Dex 文件里的类"></a>加载 Dex 文件里的类</h3><p>加载类的时候，ClassLoader 又是通过 DexFile#loadClass 这个方法来完成的，这个方法里调用了 defineClass 这个 Native 方法，** 看来 DexFile 才是加载 Class 的具体 API，加载 Dex 文件和加载具体 Class 都是通过 Native 方法完成 **，ClassLoader 有点名不副实啊。</p>
<h2 id="MultiDex-的工作机制"><a href="#MultiDex-的工作机制" class="headerlink" title="MultiDex 的工作机制"></a>MultiDex 的工作机制</h2><p>当一个 Dex 文件太肥的时候（方法数目太多、文件太大），在打包 Apk 文件的时候就会出问题，就算打包的时候不出问题，在 Android 5.0 以下设备上安装或运行 Apk 也会出问题（具体原因可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>）。既然一个 Dex 文件不行的话，那就把这个硕大的 Dex 文件拆分成若干个小的 Dex 文件，刚好一个 ClassLoader 可以有多个 DexFile，这就是 MultiDex 的基本设计思路。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>MultiDex 的工作流程具体分为两个部分，一个部分是打包构建 Apk 的时候，将 Dex 文件拆分成若干个小的 Dex 文件，这个 Android Studio 已经帮我们做了（设置 “multiDexEnabled true”），另一部分就是在启动 Apk 的时候，同时加载多个 Dex 文件（具体是加载 Dex 文件优化后的 Odex 文件，不过文件名还是.dex），这一部分工作从 Android 5.0 开始系统已经帮我们做了，但是在 Android 5.0 以前还是需要通过 MultiDex Support 库来支持（MultiDex.install (Context)）。</p>
<p>所以我们需要关心的是第二部分，这个过程的简单示意流程图如下。</p>
<p><img src="/assets/4d91c7cd_4563_4391_a0a2_9ef1d8624c9c_untitled.png" alt=""></p>
<p>（图中红色部分为耗时比较大的地方）</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>现在官方已经部署的 MultiDex Support 版本是 <code>com.android.support:multidex:1.0.1</code>，但是现在仓库的 master 分支已经有了许多新的提交（其中最明显的区别是加入了 FileLock 来控制多进程同步问题），所以这里分析的源码都是最新的 master 分支上的。</p>
<p>MultiDex Support 的入口是 <code>MultiDex.install (Context)</code>，先从这里入手吧。（这次我把具体的分析都写在代码的注释了，这样看是不是更简洁明了些？）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"install"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判读是否需要执行MultiDex。if (IS_VM_MULTIDEX_CAPABLE) &#123;</span></span><br><span class="line">            Log.i(TAG, <span class="string">"VM has multidex support, MultiDex support library is disabled."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + Build.VERSION.SDK_INT</span><br><span class="line">                    + <span class="string">" is unsupported. Min SDK version is "</span> + MIN_SDK_VERSION + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ApplicationInfo applicationInfo = getApplicationInfo(context);</span><br><span class="line">            <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Looks like running on a test Context, so just return without patching.return;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果这个方法已经调用过一次，就不能再调用了。synchronized (installedApk) &#123;</span></span><br><span class="line">                String apkPath = applicationInfo.sourceDir;</span><br><span class="line">                <span class="keyword">if</span> (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                installedApk.add(apkPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果当前Android版本已经自身支持了MultiDex，依然可以执行MultiDex操作，// 但是会有警告。if (Build.VERSION.SDK_INT &gt; MAX_SUPPORTED_SDK_VERSION) &#123;</span></span><br><span class="line">                    Log.w(TAG, <span class="string">"MultiDex is not guaranteed to work in SDK version "</span></span><br><span class="line">                            + Build.VERSION.SDK_INT + <span class="string">": SDK version higher than "</span></span><br><span class="line">                            + MAX_SUPPORTED_SDK_VERSION + <span class="string">" should be backed by "</span></span><br><span class="line">                            + <span class="string">"runtime with built-in multidex capabilty but it's not the "</span></span><br><span class="line">                            + <span class="string">"case here: java.vm.version=\""</span></span><br><span class="line">                            + System.getProperty(<span class="string">"java.vm.version"</span>) + <span class="string">"\""</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取当前的ClassLoader实例，后面要做的工作，就是把其他dex文件加载后，// 把其DexFile对象添加到这个ClassLoader实例里就完事了。</span></span><br><span class="line">                ClassLoader loader;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    loader = context.getClassLoader();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Failure while trying to obtain Context class loader. "</span> +</span><br><span class="line">                            <span class="string">"Must be running in test mode. Skip patching."</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.e(TAG,</span><br><span class="line">                            <span class="string">"Context class loader is null. Must be running in test mode. "</span></span><br><span class="line">                            + <span class="string">"Skip patching."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 5. 清除旧的dex文件，注意这里不是清除上次加载的dex文件缓存。// 获取dex缓存目录是，会优先获取/data/data/&lt;package&gt;/code-cache作为缓存目录。// 如果获取失败，则使用/data/data/&lt;package&gt;/files/code-cache目录。// 这里清除的是第二个目录。</span></span><br><span class="line">                  clearOldDexDir(context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  Log.w(TAG, <span class="string">"Something went wrong when trying to clear old MultiDex extraction, "</span></span><br><span class="line">                      + <span class="string">"continuing without cleaning."</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 获取缓存目录（/data/data/&lt;package&gt;/code-cache）。</span></span><br><span class="line">                File dexDir = getDexDir(context, applicationInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 加载缓存文件（如果有）。</span></span><br><span class="line">                List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 检查缓存的dex是否安全if (checkValidZipFiles(files)) &#123;</span></span><br><span class="line"><span class="comment">// 9. 安装缓存的dex</span></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 9. 从apk压缩包里面提取dex文件</span></span><br><span class="line">                    Log.w(TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line"><span class="comment">// 10. 安装提取的dex</span></span><br><span class="line">                        installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Multidex installation failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + e.getMessage() + <span class="string">")."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"install done"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>具体代码的分析已经在上面代码的注释里给出了，从这里我们也可以看出，整个 MultiDex.install (Context) 的过程中，关键的步骤就是 <code>MultiDexExtractor#load</code> 方法和 <code>MultiDex#installSecondaryDexes</code> 方法。</p>
<p>（这部分是题外话）其中有个 <strong>MultiDex#clearOldDexDir (Context)</strong><strong>方法，这个方法的作用是删除</strong><strong>/data/data//files/code-cache</strong>，一开始我以为这个方法是删除上一次执行 MultiDex 后的缓存文件，不过这明显不对，不可能每次 MultiDex 都重新解压 dex 文件一边，这样每次启动会很耗时，** 只有第一次冷启动的时候才需要解压 dex 文件 <strong>。后来我又想是不是以前旧版的 MultiDex 曾经把缓存文件放在这个目录里，现在新版本只是清除以前旧版的遗留文件？但是我找遍了整个 MultiDex Repo 的提交也没有见过类似的旧版本代码。后面我仔细看 **MultiDex#getDexDir</strong> 这个方法才发现，原来 MultiDex 在获取 dex 缓存目录是，会优先获取 <strong>/data/data//code-cache</strong> 作为缓存目录，如果获取失败，则使用 <strong>/data/data//files/code-cache</strong> 目录，而后者的缓存文件会在每次 App 重新启动的时候被清除。感觉 MultiDex 获取缓存目录的逻辑不是很严谨，而获取缓存目录失败也是 MultiDex 工作工程中少数有重试机制的地方，看来 MultiDex 真的是一个临时的兼容方案，Google 也许并不打算认真处理这些历史的黑锅。</p>
<p>接下来再看看 MultiDexExtractor#load 这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"MultiDexExtractor.load("</span> + applicationInfo.sourceDir + <span class="string">", "</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">final</span> File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取当前Apk文件的crc值。long currentCrc = getZipCrc(sourceApk);</span></span><br><span class="line"><span class="comment">// Validity check and extraction must be done only while the lock file has been taken.</span></span><br><span class="line">        File lockFile = <span class="keyword">new</span> File(dexDir, LOCK_FILENAME);</span><br><span class="line">        RandomAccessFile lockRaf = <span class="keyword">new</span> RandomAccessFile(lockFile, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel lockChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileLock cacheLock = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;File&gt; files;</span><br><span class="line">        IOException releaseLockException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lockChannel = lockRaf.getChannel();</span><br><span class="line">            Log.i(TAG, <span class="string">"Blocking on lock "</span> + lockFile.getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 加上文件锁，防止多进程冲突。</span></span><br><span class="line">            cacheLock = lockChannel.lock();</span><br><span class="line">            Log.i(TAG, lockFile.getPath() + <span class="string">" locked"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 先判断是否强制重新解压，这里第一次会优先使用已解压过的dex文件，如果加载失败就强制重新解压。// 此外，通过crc和文件修改时间，判断如果Apk文件已经被修改（覆盖安装），就会跳过缓存重新解压dex文件。if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 加载缓存的dex文件</span></span><br><span class="line">                    files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Failed to reload existing extracted secondary dex files,"</span></span><br><span class="line">                            + <span class="string">" falling back to fresh extraction"</span>, ioe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 加载失败的话重新解压，并保存解压出来的dex文件的信息。</span></span><br><span class="line">                    files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                    putStoredApkInfo(context,</span><br><span class="line">                            getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 4. 重新解压，并保存解压出来的dex文件的信息。</span></span><br><span class="line">                Log.i(TAG, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">                files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cacheLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cacheLock.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"Failed to release lock on "</span> + lockFile.getPath());</span><br><span class="line"><span class="comment">// Exception while releasing the lock is bad, we want to report it, but not at// the price of overriding any already pending exception.</span></span><br><span class="line">                    releaseLockException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lockChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closeQuietly(lockChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            closeQuietly(lockRaf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releaseLockException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> releaseLockException;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"load found "</span> + files.size() + <span class="string">" secondary dex files"</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>这个过程主要是获取可以安装的 dex 文件列表，可以是上次解压出来的缓存文件，也可以是重新从 Apk 包里面提取出来的。需要注意的时，如果是重新解压，这里会有明显的耗时，而且解压出来的 dex 文件，会被压缩成.zip 压缩包，压缩的过程也会有明显的耗时（这里压缩 dex 文件可能是问了节省空间）。</p>
<p>如果 dex 文件是重新解压出来的，则会保存 dex 文件的信息，包括解压的 apk 文件的 crc 值、修改时间以及 dex 文件的数目，以便下一次启动直接使用已经解压过的 dex 缓存文件，而不是每一次都重新解压。</p>
<p>需要特别提到的是，里面的 <strong>FileLock</strong> 是最新的 master 分支里面新加进去的功能，现在最新的 <code>1.0.1</code> 版本里面是没有的。</p>
<p>无论是通过使用缓存的 dex 文件，还是重新从 apk 中解压 dex 文件，获取 dex 文件列表后，下一步就是安装（或者说加载）这些 dex 文件了。最后的工作在 <code>MultiDex#installSecondaryDexes</code> 这个方法里面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span></span><br><span class="line"><span class="function">        InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>因为在不同的 SDK 版本上，ClassLoader（更准确来说是 DexClassLoader）加载 dex 文件的方式有所不同，所以这里做了 V4/V14/V19 的兼容（Magic Code）。</p>
<p>Build.VERSION.SDK_INT &lt; 14</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 4 to 13.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V4</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> extraSize = additionalClassPathEntries.size();</span><br><span class="line">            Field pathField = findField(loader, <span class="string">"path"</span>);</span><br><span class="line">            StringBuilder path = <span class="keyword">new</span> StringBuilder((String) pathField.get(loader));</span><br><span class="line">            String[] extraPaths = <span class="keyword">new</span> String[extraSize];</span><br><span class="line">            File[] extraFiles = <span class="keyword">new</span> File[extraSize];</span><br><span class="line">            ZipFile[] extraZips = <span class="keyword">new</span> ZipFile[extraSize];</span><br><span class="line">            DexFile[] extraDexs = <span class="keyword">new</span> DexFile[extraSize];</span><br><span class="line">            <span class="keyword">for</span> (ListIterator&lt;File&gt; iterator = additionalClassPathEntries.listIterator();</span><br><span class="line">                    iterator.hasNext();) &#123;</span><br><span class="line">                File additionalEntry = iterator.next();</span><br><span class="line">                String entryPath = additionalEntry.getAbsolutePath();</span><br><span class="line">                path.append(<span class="string">':'</span>).append(entryPath);</span><br><span class="line">                <span class="keyword">int</span> index = iterator.previousIndex();</span><br><span class="line">                extraPaths[index] = entryPath;</span><br><span class="line">                extraFiles[index] = additionalEntry;</span><br><span class="line">                extraZips[index] = <span class="keyword">new</span> ZipFile(additionalEntry);</span><br><span class="line">                extraDexs[index] = DexFile.loadDex(entryPath, entryPath + <span class="string">".dex"</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本是最简单的。// 只需要创建DexFile对象后，使用反射的方法分别扩展ClassLoader实例的以下字段即可。</span></span><br><span class="line">            pathField.set(loader, path.toString());</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mPaths"</span>, extraPaths);</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mFiles"</span>, extraFiles);</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mZips"</span>, extraZips);</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mDexs"</span>, extraDexs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>14 &lt;= Build.VERSION.SDK_INT &lt; 19</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 14, 15, 16, 17 and 18.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V14</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展ClassLoader实例的"pathList"字段。</span></span><br><span class="line">            Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">                Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory)</span><br><span class="line">                        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</span><br><span class="line">                        NoSuchMethodException &#123;</span><br><span class="line">            Method makeDexElements =</span><br><span class="line">                    findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">File</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>从 API14 开始，DexClassLoader 会使用一个 DexpDexPathList 类来封装 DexFile 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JAR_SUFFIX = <span class="string">".jar"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_SUFFIX = <span class="string">".zip"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            ZipFile zip = <span class="keyword">null</span>;</span><br><span class="line">            DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line"><span class="comment">// Raw dex file (not inside a zip/jar).try &#123;</span></span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                    || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zip = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to open zip file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.logW(<span class="string">"Unknown file type for: "</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过调用 <strong>DexPathList#makeDexElements</strong> 方法，可以加载我们上面解压得到的 dex 文件，从代码也可以看出，<strong>DexPathList#makeDexElements</strong> 其实也是通过调用 <strong>DexFile#loadDex</strong> 来加载 dex 文件并创建 DexFile 对象的。V14 中，通过反射调用 <strong>DexPathList#makeDexElements</strong> 方法加载我们需要的 dex 文件，在把加载得到的数组扩展到 ClassLoader 实例的 “pathList” 字段，从而完成 dex 文件的安装。</p>
<p>从 DexPathList 的代码中我们也可以看出，ClassLoader 是支持直接加载.dex/.zip/.jar/.apk 的 dex 文件包的（我记得以前在哪篇日志中好像提到过类似的问题…）。</p>
<p>19 &lt;= Build.VERSION.SDK_INT</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 19.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">            expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                    suppressedExceptions));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                Field suppressedExceptionsField =</span><br><span class="line">                        findField(dexPathList, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">                IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                        (IOException[]) suppressedExceptionsField.get(dexPathList);</span><br><span class="line">                <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dexElementsSuppressedExceptions =</span><br><span class="line">                            suppressedExceptions.toArray(</span><br><span class="line">                                    <span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    IOException[] combined =</span><br><span class="line">                            <span class="keyword">new</span> IOException[suppressedExceptions.size() +</span><br><span class="line">                                            dexElementsSuppressedExceptions.length];</span><br><span class="line">                    suppressedExceptions.toArray(combined);</span><br><span class="line">                    System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined,</span><br><span class="line">                            suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                    dexElementsSuppressedExceptions = combined;</span><br><span class="line">                &#125;</span><br><span class="line">                suppressedExceptionsField.set(dexPathList, dexElementsSuppressedExceptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">                Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">                        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</span><br><span class="line">                        NoSuchMethodException &#123;</span><br><span class="line">            Method makeDexElements =</span><br><span class="line">                    findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">File</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ArrayList</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory,</span><br><span class="line">                    suppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>V19 与 V14 差别不大，只不过 <strong>DexPathList#makeDexElements</strong> 方法多了一个 ArrayList 参数，如果在执行 <strong>DexPathList#makeDexElements</strong> 方法的过程中出现异常，后面使用反射的方式把这些异常记录进 DexPathList 的 <strong>dexElementsSuppressedExceptions</strong> 字段里面。</p>
<p>无论是 V4/V14 还是 V19，在创建 DexFile 对象的时候，都需要通过 DexFile 的 Native 方法 <strong>openDexFile</strong> 来打开 dex 文件，其具体细节暂不讨论（涉及到 dex 的文件结构，很烦，有兴趣请阅读 <a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a>），这个过程的主要目的是给当前的 dex 文件做 Optimize 优化处理并生成相同文件名的 odex 文件，App 实际加载类的时候，都是通过 odex 文件进行的。因为每个设备对 odex 格式的要求都不一样，所以这个优化的操作只能放在安装 Apk 的时候处理，主 dex 的优化我们已经在安装 apk 的时候搞定了，其余的 dex 就是在 <code>MultiDex#installSecondaryDexes</code> 里面优化的，而后者也是 MultiDex 过程中，另外一个耗时比较多的操作。（在 MultiDex 中，提取出来的 dex 文件被压缩成.zip 文件，又优化后的 odex 文件则被保存为.dex 文件。）</p>
<p>到这里，MultiDex 的工作流程就结束了。怎么样，是不是觉得和以前谈到动态加载技术（插件化）的时候说的很像？没错，谁叫它们的核心都是 dex 文件呢。Java 老师第一节课就说 “** 类就是编程 **”，搞定类你就能搞定整个世界啊！</p>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>MultiDex 有个比较蛋疼的问题，就是会产生明显的卡顿现象，通过上面的分析，我们知道具体的卡顿产生在 ** 解压 dex 文件 ** 以及 ** 优化 dex** 两个步骤。不过好在，在 Application#attachBaseContext (Context) 中，UI 线程的阻塞是不会引发 ANR 的，只不过这段长时间的卡顿（白屏）还是会影响用户体验。<br>目前，优化方案能想到的有两种。</p>
<h3 id="PreMultiDex-方案"><a href="#PreMultiDex-方案" class="headerlink" title="PreMultiDex 方案"></a>PreMultiDex 方案</h3><p>大致思路是，在安装一个新的 apk 的时候，先在 Worker 线程里做好 MultiDex 的解压和 Optimize 工作，安装 apk 并启动后，直接使用之前 Optimize 产生的 odex 文件，这样就可以避免第一次启动时候的 Optimize 工作。</p>
<p><img src="/assets/02dd6659_1487_4691_a0a6_d9c1ad849079_untitled.png" alt=""></p>
<p>安装 dex 的时候，核心是创建 DexFile 对象并使用其 Native 方法对 dex 文件进行 opt 处理，同时生产一个与 dex 文件（.zip）同名的已经 opt 过的 dex 文件（.dex）。如果安装 dex 的时候，这个 opt 过的 dex 文件已经存在，则跳过这个过程，这会节省许多耗时。所以优化的思路就是，下载 Apk 完成的时候，预先解压 dex 文件，并预先触发安装 dex 文件以生产 opt 过的 dex 文件。这样覆盖安装 Apk 并启动的时候，如果 MultiDex 能命中解压好的 dex 和 odex 文件，则能避开耗时最大的两个操作。</p>
<p>不过这个方案的缺点也是明显的，第一次安装的 apk 没有作用，而且事先需要使用内置的 apk 更新功能把新版本的 apk 文件下载下来后，才能做 PreMultiDex 工作。</p>
<h3 id="异步-MultiDex-方案"><a href="#异步-MultiDex-方案" class="headerlink" title="异步 MultiDex 方案"></a>异步 MultiDex 方案</h3><p>这种方案也是目前比较流行的 *<em>Dex 手动分包方案 *</em>，启动 App 的时候，先显示一个简单的 Splash 闪屏界面，然后启动 Worker 线程执行 MultiDex#install (Context) 工作，就可以避免 UI 线程阻塞。不过要确保启动以及启动 MultiDex#install (Context) 所需要的类都在主 dex 里面（手动分包），而且需要处理好进程同步问题。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="noopener">Configure Apps with Over 64K Methods</a></li>
<li><a href="https://android.googlesource.com/platform/frameworks/multidex/" target="_blank" rel="noopener">Google Multidex</a></li>
<li><a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a></li>
</ul>
<!-- Generated by HexoWriter
notion-down.version = 0.1.0
notion-down.revision = b'3de8526'
Title = MultiDex 工作原理分析和优化方案
Date = 2016-11-11 00:00:00
Published = true
Category = Android
Tag = ['Android', 'MultiDex', '源码分析']
FileLocate = android
FileName = multidex-source-code
hexo.comments = true
-->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/源码分析/">源码分析</a><a href="/tags/MultiDex/">MultiDex</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'kidhaibara';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">NotionDown</a> and
    Theme by <a href="https://github.com/kaedea/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 Kaede Akatsuki
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'G-J38N5N288S', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>