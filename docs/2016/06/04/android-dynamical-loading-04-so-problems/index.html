<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>使用 so 库时要注意的一些问题 | Kaede Akatsuki | 中二病也要开发 Android</title>

  
  <meta name="author" content="Kaede Akatsuki">
  

  
  <meta name="description" content="A TASTE OF ACG (Anime/Coding/Games).">
  

  
  
  <meta name="keywords" content="Android,动态化,so 库">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="使用 so 库时要注意的一些问题">

  <meta property="og:site_name" content="Kaede Akatsuki">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kaede Akatsuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <link href="https://fonts.lug.ustc.edu.cn/css?family=Lato|Rubik" rel="stylesheet">
  <script src="/js/pangu-407.min.js"></script>
</head>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    pangu.autoSpacingPage();
  });
</script>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Kaede Akatsuki</a>
    </h1>
    <p class="site-description">中二病也要开发 Android</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>使用 so 库时要注意的一些问题</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/04/android-dynamical-loading-04-so-problems/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-04T00:00:00.000Z">
          2016-06-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        

<script type="text/javascript">
    function convertRemToPixels(rem) {    
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    window.onscroll = function() {
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > convertRemToPixels(40)) {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'visible';
        } else {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'hidden';
        }
    }
</script>


<div id="toc" class="toc-article">
      <div class="toc-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本信息"><span class="toc-text">基本信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SO-库类型和-CPU-架构类型"><span class="toc-text">SO 库类型和 CPU 架构类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-SO-库时要注意的一些问题"><span class="toc-text">使用 SO 库时要注意的一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-别把-SO-库放错地方"><span class="toc-text">1. 别把 SO 库放错地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-尽可能提供-CPU-支持的最优-SO-库"><span class="toc-text">2. 尽可能提供 CPU 支持的最优 SO 库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-注意-SO-库的编译版本"><span class="toc-text">3. 注意 SO 库的编译版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-尽可能为每种-CPU-类型都提供对应的-SO-库"><span class="toc-text">4. 尽可能为每种 CPU 类型都提供对应的 SO 库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-不要通过-“减少其他-CPU-类型支持的-SO-库”-来减少-APK-的体积"><span class="toc-text">5. 不要通过 “减少其他 CPU 类型支持的 SO 库” 来减少 APK 的体积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#减少-SO-库体积的正确姿势"><span class="toc-text">减少 SO 库体积的正确姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-构建特定-ABI-支持的-APK"><span class="toc-text">1. 构建特定 ABI 支持的 APK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-从网络下载当前设备支持的-SO-库"><span class="toc-text">2. 从网络下载当前设备支持的 SO 库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol>
      </div>
</div>
<style>
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>



        <p>正好动态加载系列文章谈到了加载 SO 库的地方，我觉得这里可以顺便谈谈使用 SO 库时需要注意的一些问题。或许这些问题对于经常和 SO 库开发打交道的同学来说已经是老生长谈，但是既然要讨论一整个动态加载系列，我想还是有必要说说使用 SO 库时的一些问题。</p>
<p>在项目里使用 SO 库非常简单，在 <a href="https://file+.vscode-resource.vscode-webview.net/Users/Kaede/Repository/Kaede/cosmos/hexo/hexo-kaedea/source/_posts/android-dynamical-loading-04-so-problems.md#" target="_blank" rel="noopener">加载 SD 卡中的 SO 库</a> 中也有谈到，只需要把需要用到的 SO 库拷贝进 <strong>jniLibs (或者 Eclipse 项目里面的 libs)</strong> 中，然后在 JAVA 代码中调用 <strong>System.loadLibrary (“xxx”)</strong> 加载对应的 SO 库，就可以使用 JNI 语句调用 SO 库里面的 Native 方法了。</p>
<p>但是有同学注意到了，SO 库文件可以随便改文件名，却不能任意修改文件夹路径，而是 “armeabi”、“armeabi-v7a”、“x86” 等文件夹名有着严格的要求，这些文件夹名有什么意义么？</p>
<a id="more"></a>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul>
<li>Author : <a href="https://github.com/kaedea" target="_blank" rel="noopener">Kaede</a><ul>
<li>Index : <a href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index">ANDROID 动态加载系列</a></li>
</ul>
</li>
<li>GitHub : <a href="https://github.com/kaedea/android-dynamical-loading" target="_blank" rel="noopener">kaedea/android-dynamical-loading</a></li>
</ul>
<h2 id="SO-库类型和-CPU-架构类型"><a href="#SO-库类型和-CPU-架构类型" class="headerlink" title="SO 库类型和 CPU 架构类型"></a>SO 库类型和 CPU 架构类型</h2><p>原因很简单，不同 CPU 架构的设备需要用不同类型 SO 库（从文件名也可以猜出来个大概嘛 ╮(￣▽￣”)╭）。<br>记得还在学校的时候，提及 ARM 处理器时，老师说以后移动设备的 CPU 基本就是 ARM 类型的了。老师不曾欺我，早期的 Android 系统几乎只支持 ARM 的 CPU 架构，不过现在至少支持以下七种不同的 CPU 架构：ARMv5，ARMv7，x86，MIPS，ARMv8，MIPS64 和 x86_64。每一种 CPU 类型都对应一种 ABI（Application Binary Interface），“armeabi-v7a” 文件夹前面的 “armeabi” 指的就是 ARM 这种类型的 ABI，后面的 “v7a” 指的是 ARMv7。这 7 种 CPU 类型对应的 SO 库的文件夹名是：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。<br>不同类型的移动设备在运行 APP 时，需要加载自己支持的类型的 SO 库，不然就 GG 了。通过 <strong>Build.SUPPORTED_ABIS</strong> 我们可以判断当前设备支持的 ABI，不过一般情况下，不需要开发者自己去判断 ABI，Android 系统在安装 APK 的时候，不会安装 APK 里面全部的 SO 库文件，而是会根据当前 CPU 类型支持的 ABI，从 APK 里面拷贝最合适的 SO 库，并保存在 APP 的内部存储路径的 <strong>libs</strong> 下面。（这里说一般情况，是因为有例外的情况存在，比如我们动态加载外部的 SO 库的时候，就需要自己判断 ABI 类型了。）</p>
<blockquote>
<p>一种 CPU 架构　=　一种对应的 ABI 参数　=　 一种对应类型的 SO 库</p>
</blockquote>
<p>到这里，我们发现使用 SO 库的逻辑还是比较简单的，但是 Android 系统加载 SO 库的逻辑还是给我们留下了一些坑。</p>
<h2 id="使用-SO-库时要注意的一些问题"><a href="#使用-SO-库时要注意的一些问题" class="headerlink" title="使用 SO 库时要注意的一些问题"></a>使用 SO 库时要注意的一些问题</h2><h3 id="1-别把-SO-库放错地方"><a href="#1-别把-SO-库放错地方" class="headerlink" title="1. 别把 SO 库放错地方"></a>1. 别把 SO 库放错地方</h3><p>SO 库其实都是 APP 运行时加载的，也就是说 APP 只有在运行的时候才知道 SO 库文件的存在，这就无法通过静态代码检查或者在编译 APP 时检查 SO 库文件是否正常。所以，Android 开发对 SO 库的存放路径有严格的要求。<br>使用 SO 库的时候，除了 “armeabi-v7a” 等文件夹名需要严格按照规定的来自外，SO 库要放在项目的哪个文件夹下也要按照套路来，以下是一些总结：</p>
<ul>
<li>Android Studio 工程放在 <strong>jniLibs/xxxabi</strong> 目录中（当然也可以通过在 build.gradle 文件中的设置 jniLibs.srcDir 属性自己指定）；</li>
<li>Eclipse 工程放在 <strong>libs/xxxabi</strong> 目录中（这也是使用 ndk-build 命令生成 SO 库的默认目录）；</li>
<li>aar 依赖包中位于 <strong>jni/ABI</strong> 目录中（SO 库会自动包含到引用 AAR 压缩包到 APK 中）；</li>
<li>最终构建出来的 APK 文件中，SO 库存在 <strong>lib/xxxabi</strong> 目录中（也就是说无论你用什么方式构建，只要保证 APK 包里 SO 库的这个路径没错就没问题）；</li>
<li>通过 PackageManager 安装后，在小于 Android 5.0 的系统中，SO 库位于 APP 的 <strong>nativeLibraryPath</strong> 目录中；在大于等于 Android 5.0 的系统中，SO 库位于 APP 的 <strong>nativeLibraryRootDir/CPU_ARCH</strong> 目录中；</li>
</ul>
<p>既然扯到了这里，顺便说一下，我在使用 Android Studio 1.5 构建 APK 的时候，发现 Gradle 插件只会默认打包 application 类型的 module 的 jniLibs 下面的 SO 库文件，而不会打包 aar 依赖包的 SO 库，所以会导致最终构建出来的 APK 里的 SO 库文件缺失。暂时的解决方案是把所有的 SO 库都放在 application 模块中（这显然不是很好的解决方案），不知道这是不是 Studio 的 BUG，同事的解决方案是通过修改 Gradle 插件来增加对 aar 依赖包的 SO 库的打包支持（GitHub 有开源的第三方 Gradle 插件项目，使用 Java 和 Groovy 语言开发）。</p>
<h3 id="2-尽可能提供-CPU-支持的最优-SO-库"><a href="#2-尽可能提供-CPU-支持的最优-SO-库" class="headerlink" title="2. 尽可能提供 CPU 支持的最优 SO 库"></a>2. 尽可能提供 CPU 支持的最优 SO 库</h3><p>当一个应用安装在设备上，只有该设备支持的 CPU 架构对应的 SO 库会被安装。但是，有时候，设备支持的 SO 库类型不止一种，比如大多的 X86 设备除了支持 X86 类型的 SO 库，还兼容 ARM 类型的 SO 库（目前应用市场上大部分的 APP 只适配了 ARM 类型的 SO 库，X86 类型的设备如果不能兼容 ARM 类型的 SO 库的话，大概要嗝屁了吧）。<br>所以如果你的 APK 只适配了 ARM 类型的 SO 库的话，还是能以兼容的模式在 X86 类型的设备上运行（比如华硕的平板），但是这不意味着你就不用适配 X86 类型的 SO 库了，因为 X86 的 CPU 使用兼容模式运行 ARM 类型的 SO 库会异常卡顿（试着回想几年前你开始学习 Android 开发的时候，在 PC 上使用 AVD 模拟器的那种感觉）。</p>
<h3 id="3-注意-SO-库的编译版本"><a href="#3-注意-SO-库的编译版本" class="headerlink" title="3. 注意 SO 库的编译版本"></a>3. 注意 SO 库的编译版本</h3><p>除了要注意使用了正确 CPU 类型的 SO 库，也要注意 SO 库的编译版本的问题。虽然现在的 Android Studio 支持在项目中直接编译 SO 库，但是更多的时候我们还是选择使用事先编译好的 SO 库，这时就要注意了，编译 APK 的时候，我们总是希望使用最新版本的 build-tools 来编译，因为 Android SDK 最新版本会帮我们做出最优的向下兼容工作。<br>但是这对于编译 SO 库来说就不一样了，因为 NDK 平台不是向下兼容的，而是向上兼容的。应该使用 app 的 minSdkVersion 对应的版本的 NDK 标本来编译 SO 库文件，如果使用了太高版本的 NDK，可能会导致 APP 性能低下，或者引发一些 SO 库相关的运行时异常，比如 “UnsatisfiedLinkError”，“dlopen: failed” 以及其他类型的 Crash。<br>一般情况下，我们都是使用编译好的 SO 库文件，所以当你引入一个预编译好的 SO 库时，你需要检查它被编译所用的平台版本。</p>
<h3 id="4-尽可能为每种-CPU-类型都提供对应的-SO-库"><a href="#4-尽可能为每种-CPU-类型都提供对应的-SO-库" class="headerlink" title="4. 尽可能为每种 CPU 类型都提供对应的 SO 库"></a>4. 尽可能为每种 CPU 类型都提供对应的 SO 库</h3><p>比如有时候，因为业务的需求，我们的 APP 不需要支持 AMR64 的设备，但这不意味着我们就不用编译 ARM64 对应的 SO 库。举个例子，我们的 APP 只支持 armeabi-v7a 和 x86 架构，然后我们的 APP 使用了一个第三方的 Library，而这个 Library 提供了 AMR64 等更多类型 CPU 架构的支持，构建 APK 的时候，这些 ARM64 的 SO 库依然会被打包进 APK 里面，也就是说我们自己的 SO 库没有对应的 ARM64 的 SO 库，而第三方的 Library 却有。这时候，某些 ARM64 的设备安装该 APK 的时候，发现我们的 APK 里带有 ARM64 的 SO 库，会误以为我们的 APP 已经做好了 AMR64 的适配工作，所以只会选择安装 APK 里面 ARM64 类型的 SO 库，这样会导致我们自己项目的 SO 库没有被正确安装（虽然 armeabi-v7a 和 x86 类型的 SO 库确实存在 APK 包里面）。<br>这时正确的做法是，给我们自己的 SO 库也提供 AMR64 支持，或者不打包第三方 Library 项目的 ARM64 的 SO 库。使用第二种方案时，可以把 APK 里面不需要支持的 ABI 文件夹给删除，然后重新打包，而在 Android Studio 下，则可以通过以下的构建方式指定需要类型的 SO 库。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">    flavor1 &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">"armeabi-v7a"</span></span><br><span class="line">            abiFilters <span class="string">"x86"</span></span><br><span class="line">            abiFilters <span class="string">"armeabi"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    flavor2 &#123;</span><br><span class="line">        ndk &#123;</span><br><span class="line">            abiFilters <span class="string">"armeabi-v7a"</span></span><br><span class="line">            abiFilters <span class="string">"x86"</span></span><br><span class="line">            abiFilters <span class="string">"armeabi"</span></span><br><span class="line">            abiFilters <span class="string">"arm64-v8a"</span></span><br><span class="line">            abiFilters <span class="string">"x86_64"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，如果我们的项目是 SDK 项目，我们最好提供全平台类型的 SO 库支持，因为 APP 能支持的设备 CPU 类型的数量，就是项目中所有 SO 库支持的最少 CPU 类型的数量（使用我们 SDK 的 APP 能支持的 CPU 类型只能少于等于我们 SDK 支持的类型）。</p>
<h3 id="5-不要通过-“减少其他-CPU-类型支持的-SO-库”-来减少-APK-的体积"><a href="#5-不要通过-“减少其他-CPU-类型支持的-SO-库”-来减少-APK-的体积" class="headerlink" title="5. 不要通过 “减少其他 CPU 类型支持的 SO 库” 来减少 APK 的体积"></a>5. 不要通过 “减少其他 CPU 类型支持的 SO 库” 来减少 APK 的体积</h3><p>确实，所有的 x86/x86_64/armeabi-v7a/arm64-v8a 设备都支持 armeabi 架构的 SO 库，因此似乎移除其他 ABIs 的 SO 库是一个减少 APK 大小的好办法。但事实上并不是，这不只影响到函数库的性能和兼容性。<br>X86 设备能够很好的运行 ARM 类型函数库，但并不保证 100% 不发生 crash，特别是对旧设备，兼容只是一种保底方案。64 位设备（arm64-v8a, x86_64, mips64）能够运行 32 位的函数库，但是以 32 位模式运行，在 64 位平台上运行 32 位版本的 ART 和 Android 组件，将丢失专为 64 位优化过的性能（ART，webview，media 等等）。<br>过减少其他 CPU 类型支持的 SO 库来减少 APK 的体积不是很明智的做法，如果真的需要通过减少 SO 库来做 APK 瘦身，我们也有其他办法。</p>
<h2 id="减少-SO-库体积的正确姿势"><a href="#减少-SO-库体积的正确姿势" class="headerlink" title="减少 SO 库体积的正确姿势"></a>减少 SO 库体积的正确姿势</h2><h3 id="1-构建特定-ABI-支持的-APK"><a href="#1-构建特定-ABI-支持的-APK" class="headerlink" title="1. 构建特定 ABI 支持的 APK"></a>1. 构建特定 ABI 支持的 APK</h3><p>我们可以构建一个 APK，它支持所有的 CPU 类型。但是反过来，我们可以为每个 CPU 类型都单独构建一个 APK，然后不同 CPU 类型的设备安装对应的 APK 即可，当然前提是应用市场得提供用户设备 CPU 类型设别的支持，就目前来说，至少 PLAY 市场是支持的。<br>Gradle 可以通过以下配置生成不同 ABI 支持的 APK（引用自别的文章，没实际使用过）：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    splits &#123;</span><br><span class="line">        abi &#123;</span><br><span class="line">            enable <span class="literal">true</span></span><br><span class="line">            reset()</span><br><span class="line">            include <span class="string">'x86'</span>, <span class="string">'x86_64'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'arm64-v8a'</span><span class="comment">//select ABIs to build APKs for</span></span><br><span class="line">            universalApk <span class="literal">true</span><span class="comment">//generate an additional APK that contains all the ABIs</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map for the version code</span></span><br><span class="line">    project.ext.versionCodes = [<span class="string">'armeabi'</span>: <span class="number">1</span>, <span class="string">'armeabi-v7a'</span>: <span class="number">2</span>, <span class="string">'arm64-v8a'</span>: <span class="number">3</span>, <span class="string">'mips'</span>: <span class="number">5</span>, <span class="string">'mips64'</span>: <span class="number">6</span>, <span class="string">'x86'</span>: <span class="number">8</span>, <span class="string">'x86_64'</span>: <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">    android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line"><span class="comment">// assign different version code for each output</span></span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            output.versionCodeOverride =</span><br><span class="line">                    project.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), <span class="number">0</span>) * <span class="number">1000000</span> + android.defaultConfig.versionCode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-从网络下载当前设备支持的-SO-库"><a href="#2-从网络下载当前设备支持的-SO-库" class="headerlink" title="2. 从网络下载当前设备支持的 SO 库"></a>2. 从网络下载当前设备支持的 SO 库</h3><p>说到这里，总算回到动态加载的主题了。⊙﹏⊙<br>使用 Android 的动态加载技术，可以加载外部的 SO 库，所以我们可以从网络下载 SO 库文件并加载了。我们可以下载所有类型的 SO 库文件，然后加载对应类型的 SO 库，也可以下载对应类型的 SO 库然后加载，不过无论哪种方式，我们最好都在加载 SO 库前，对 SO 库文件的类型做一下判断。<br>我个人的方案是，存储在服务器的 SO 库依然按照 APK 包的压缩方式打包，也就是，SO 库存放在 APK 包的 <strong>libs/xxxabi</strong> 路径下面，下载完带有 SO 库的 APK 包后，我们可以遍历 libs 路径下的所有 SO 库，选择加载对应类型的 SO 库。<br>具体实现代码看上去像是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将一个SO库复制到指定路径，会先检查改SO库是否与当前CPU兼容</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sourceDir     SO库所在目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> so            SO库名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> destDir       目标根目录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nativeLibName 目标SO库目录名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">copySoLib</span><span class="params">(File sourceDir, String so, String destDir, String nativeLibName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LogUtil.d(TAG, <span class="string">"[copySo] 开始处理so文件"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">            String[] abis = Build.SUPPORTED_ABIS;</span><br><span class="line">            <span class="keyword">if</span> (abis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String abi : abis) &#123;</span><br><span class="line">                    LogUtil.d(TAG, <span class="string">"[copySo] try supported abi:"</span> + abi);</span><br><span class="line">                    String name = <span class="string">"lib"</span> + File.separator + abi + File.separator + so;</span><br><span class="line">                    File sourceFile = <span class="keyword">new</span> File(sourceDir, name);</span><br><span class="line">                    <span class="keyword">if</span> (sourceFile.exists()) &#123;</span><br><span class="line">                        LogUtil.i(TAG, <span class="string">"[copySo] copy so: "</span> + sourceFile.getAbsolutePath());</span><br><span class="line">                        isSuccess = FileUtil.copyFile(sourceFile.getAbsolutePath(), destDir + File.separator + nativeLibName + File.separator + so);</span><br><span class="line"><span class="comment">//api21 64位系统的目录可能有些不同//copyFile(sourceFile.getAbsolutePath(), destDir + File.separator +  name);break;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LogUtil.e(TAG, <span class="string">"[copySo] get abis == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LogUtil.d(TAG, <span class="string">"[copySo] supported api:"</span> + Build.CPU_ABI + <span class="string">" "</span> + Build.CPU_ABI2);</span><br><span class="line"></span><br><span class="line">            String name = <span class="string">"lib"</span> + File.separator + Build.CPU_ABI + File.separator + so;</span><br><span class="line">            File sourceFile = <span class="keyword">new</span> File(sourceDir, name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!sourceFile.exists() &amp;&amp; Build.CPU_ABI2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                name = <span class="string">"lib"</span> + File.separator + Build.CPU_ABI2 + File.separator + so;</span><br><span class="line">                sourceFile = <span class="keyword">new</span> File(sourceDir, name);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!sourceFile.exists()) &#123;</span><br><span class="line">                    name = <span class="string">"lib"</span> + File.separator + <span class="string">"armeabi"</span> + File.separator + so;</span><br><span class="line">                    sourceFile = <span class="keyword">new</span> File(sourceDir, name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sourceFile.exists()) &#123;</span><br><span class="line">                LogUtil.i(TAG, <span class="string">"[copySo] copy so: "</span> + sourceFile.getAbsolutePath());</span><br><span class="line">                isSuccess = FileUtil.copyFile(sourceFile.getAbsolutePath(), destDir + File.separator + nativeLibName + File.separator + so);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">            LogUtil.e(TAG, <span class="string">"[copySo] 安装 "</span> + so + <span class="string">" 失败 : NO_MATCHING_ABIS"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"install "</span> + so + <span class="string">" fail : NO_MATCHING_ABIS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>一种 CPU 架构 = 一种 ABI = 一种对应的 SO 库；</li>
<li>加载 SO 库时，需要加载对应类型的 SO 库；</li>
<li>尽量提供全平台 CPU 类型的 SO 库支持；</li>
</ol>
<p>题外话，SO 库的使用本身就是一种最纯粹的动态加载技术，SO 库本身不参与 APK 的编译过程，使用 JNI 调用 SO 库里的 Native 方法的方式看上去也像是一种 “硬编程”，Native 方法看上去与一般的 Java 静态方法没什么区别，但是它的具体实现却是可以随时动态更换的（更换 SO 库就好），这也可以用来实现热修复的方案，与 Java 方法一旦加载进内存就无法再次更换不同，Native 方法不需要重启 APP 就可以随意更换。<br>出于安全和生态控制的原因，Google Play 市场不允许 APP 有加载外部可执行文件的行为，一旦你的 APK 里被检查出有额外的可执行文件时就不好玩了，所以现在许多 APP 都偷偷把用于动态加载的可执行文件的后缀名换成 “.so”，这样被发现的几率就降低了，因为加载 SO 库看上去就是官方合法版本的动态加载啊（不然 SO 库怎么工作），虽然这么做看起来有点掩耳盗铃。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="http://www.jianshu.com/p/cb05698a1968" target="_blank" rel="noopener">关于 Android 的.so 文件你所需要知道的</a><ul>
<li><a href="https://github.com/limpoxe/Android-Plugin-Framework" target="_blank" rel="noopener">Android-Plugin-Framework</a></li>
</ul>
</li>
</ul>
<!-- Generated by HexoWriter
notion-down.version = 1.0.0
notion-down.revision = b'df2b844'
Title = 使用 so 库时要注意的一些问题
Date = 2016-06-04 00:00:00
Published = true
Category = Android
Tag = ['Android', '动态化', 'so 库']
FileLocate = 
FileName = android-dynamical-loading-04-so-problems
hexo.comments = true
hexo.metaAlignment = center
-->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/动态化/">动态化</a><a href="/tags/so-库/">so 库</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'kidhaibara';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">notion-down</a> and
    Theme by <a href="https://github.com/kaedea/hexo-theme-hacker" target="_blank">hexo-theme-hacker</a>
    </br>
    
    &copy; 2025 Kaede Akatsuki
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'G-J38N5N288S', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>