<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kaede Akatsuki</title>
  
  <subtitle>中二病也要开发 Android</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kaedea.com/"/>
  <updated>2021-10-22T09:55:05.988Z</updated>
  <id>http://kaedea.com/</id>
  
  <author>
    <name>Kaede Akatsuki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notion 数据自动备份方案</title>
    <link href="http://kaedea.com/2021/10/01/devops/notion-backup/"/>
    <id>http://kaedea.com/2021/10/01/devops/notion-backup/</id>
    <published>2021-10-01T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/8f134329_a1a6_49b2_97a4_c07ea4c3e733_untitled.png" alt></p><p>最近我已经把自己的笔记系统迁移到 Notion 上面，相比过去十年间用过的为知笔记和有道云笔记，Notion 的自定义和自动化玩法显然要丰富许多，而且多个平台的客户端也做得不错（国产软件现在都是满屏的广告非常难受）。不过我总感觉 Notion 在数据同步和历史数据版本控制上做得比较搓。</p><p>比如我感觉我好像同步丢过几次数据，而且就算开了 Notion Pro 服务，Notion Page 的历史记录居然没有 <code>diff</code> 比对（这样很难看出不同历史记录之间的变更）。</p><p>因此我打算给 Notion Workspace 加上自动备份功能，用于防止数据丢失以及通过 <code>git diff</code> 查看不同备份快照之间的差异。<br><a id="more"></a></p><h2 id="NotionUp"><a href="#NotionUp" class="headerlink" title="NotionUp"></a>NotionUp</h2><p><a href="https://github.com/kaedea/notion-up" target="_blank" rel="noopener">notion-up</a> 是一个用来备份 Notion 数据的 Python Repo，主要功能是通过 Notion API 导出 Notion 的备份数据 exported.zip，配合 CircleCi 或其他持续集成服务，能够定期把  exported.zip 文件上传到 GitHub Releases 并把解压出来的 Notion 笔记内容提交到指定的 GitHub Repo。</p><h2 id="备份-Notion-数据"><a href="#备份-Notion-数据" class="headerlink" title="备份 Notion 数据"></a>备份 Notion 数据</h2><p>通过以下命令可以备份指定 Notion Workspace 的数据并导出为 .zip 文件。（其中的 token_v2 的获取方式可以参考一下这个文档：<a href="https://github.com/kaedea/notion-down/blob/master/dist/parse_readme/notiondown_gettokenv2.md" target="_blank" rel="noopener">notion_token_v2</a>。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONPATH=./ python main.py --token_v2 &lt;token_v2&gt;</span><br></pre></td></tr></table></figure><h2 id="配合-CircleCi-使用"><a href="#配合-CircleCi-使用" class="headerlink" title="配合 CircleCi 使用"></a>配合 CircleCi 使用</h2><p>搭配 CircleCi 等持续集成服务，可以实现定期自动备份 Notion 数据到 GitHub Releases 以及 GitHub 仓库。（详细配置可以参考一下：<a href="https://github.com/kaedea/notion-up/blob/master/.circleci/config.yml" target="_blank" rel="noopener">.config.yml</a>。）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">workflows:</span></span><br><span class="line">  <span class="attr">backup-notion:</span></span><br><span class="line">    <span class="attr">jobs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">export-workspace</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">publish-github-release:</span></span><br><span class="line">          <span class="attr">requires:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">export-workspace</span></span><br><span class="line">  <span class="attr">backup-notion-nightly:</span></span><br><span class="line">    <span class="attr">triggers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">schedule:</span></span><br><span class="line">          <span class="attr">cron:</span> <span class="string">"0 * * * *"</span>  <span class="comment"># every hour</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="attr">branches:</span></span><br><span class="line">              <span class="attr">only:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">export-workspace</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">publish-github-release:</span></span><br><span class="line">        <span class="attr">requires:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">export-workspace</span></span><br></pre></td></tr></table></figure><p>效果如下：<br>Notion 数据备份文归档</p><!-- ColumnList start --><!-- Column 0 start --><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/96cc3ab6-2b10-4c1d-a136-4ac50867d7f1/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20211022%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20211022T095307Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=477d450224d4dee11c333853050fdf3dd0d4a7de84c3842ef51634a81ec93b84&amp;X-Amz-SignedHeaders=host" alt></p><!-- Column end --><!-- Column 1 start --><!-- Column end --><!-- ColumnList end --><p>Notion 数据 git diff</p><!-- ColumnList start --><!-- Column 0 start --><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3406a622-336c-4146-abc5-20b2576adaba/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20211022%2Fus-west-2%2Fs3%2Faws4_request&amp;X-Amz-Date=20211022T095307Z&amp;X-Amz-Expires=86400&amp;X-Amz-Signature=9624fa49bb0cae0aa3b528bc3545826e928c8e466a13a6fae4cd897a53a01a2e&amp;X-Amz-SignedHeaders=host" alt></p><!-- Column end --><!-- Column 1 start --><!-- Column end --><!-- ColumnList end --><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Notion 数据自动备份方案Date = 2021-10-01Published = trueCategory = BlogTag = ['Notion', 'NotionUp']FileLocate = devopsFileName = notion-backup-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/8f134329_a1a6_49b2_97a4_c07ea4c3e733_untitled.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;最近我已经把自己的笔记系统迁移到 Notion 上面，相比过去十年间用过的为知笔记和有道云笔记，Notion 的自定义和自动化玩法显然要丰富许多，而且多个平台的客户端也做得不错（国产软件现在都是满屏的广告非常难受）。不过我总感觉 Notion 在数据同步和历史数据版本控制上做得比较搓。&lt;/p&gt;
&lt;p&gt;比如我感觉我好像同步丢过几次数据，而且就算开了 Notion Pro 服务，Notion Page 的历史记录居然没有 &lt;code&gt;diff&lt;/code&gt; 比对（这样很难看出不同历史记录之间的变更）。&lt;/p&gt;
&lt;p&gt;因此我打算给 Notion Workspace 加上自动备份功能，用于防止数据丢失以及通过 &lt;code&gt;git diff&lt;/code&gt; 查看不同备份快照之间的差异。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="Notion" scheme="http://kaedea.com/tags/Notion/"/>
    
      <category term="NotionUp" scheme="http://kaedea.com/tags/NotionUp/"/>
    
  </entry>
  
  <entry>
    <title>博客源文件迁移到 Notion 云笔记</title>
    <link href="http://kaedea.com/2021/09/01/devops/notion-to-hexo/"/>
    <id>http://kaedea.com/2021/09/01/devops/notion-to-hexo/</id>
    <published>2021-09-01T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p>为了彻底解决日志编辑的 <code>割裂感</code> 问题，我已经把博客日志的全部源文件迁移到自己的 Notion 笔记，同时通过自动化技术，使用 <a href="https://www.kaedea.com/2021/05/01/devops/project-notion-down/" target="_blank" rel="noopener">NotionDown</a> 把 Notion Pages 解析成 MarkDown 源文件，并编译和部署成 Hexo 静态博客。</p><p><img src="/assets/42d59036_fb28_4b90_8e31_e27a0280b81d_untitled.png" alt></p><p>相同的解决方案可以参考：<a href="https://github.com/kaedea/notion-down-hexo-showcase" target="_blank" rel="noopener">https://github.com/kaedea/notion-down-hexo-showcase</a>。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 博客源文件迁移到 Notion 云笔记Date = 2021-09-01Published = trueCategory = BlogTag = ['Notion', 'NotionDown']FileLocate = devopsFileName = notion-to-hexohexo.comments = falsehexo.layout = linkhexo.link = https://www.kaedea.com/2021/05/01/devops/project-notion-down/-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了彻底解决日志编辑的 &lt;code&gt;割裂感&lt;/code&gt; 问题，我已经把博客日志的全部源文件迁移到自己的 Notion 笔记，同时通过自动化技术，使用 &lt;a href=&quot;https://www.kaedea.com/2021/05/01/devops/project-not
      
    
    </summary>
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="Notion" scheme="http://kaedea.com/tags/Notion/"/>
    
      <category term="NotionDown" scheme="http://kaedea.com/tags/NotionDown/"/>
    
  </entry>
  
  <entry>
    <title>Android App 电量统计原理与优化</title>
    <link href="http://kaedea.com/2021/08/14/android-apm-battery-stats-opt/"/>
    <id>http://kaedea.com/2021/08/14/android-apm-battery-stats-opt/</id>
    <published>2021-08-14T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.984Z</updated>
    
    <content type="html"><![CDATA[<!-- changelog2021-09-10修订 3Add: 1. 案例分享：HashMap 死链2021-07-27修订 2Add: 1. 项目使用效果2021-07-21修订 1Add: 1. 拓展阅读2021-07-20初稿--><!-- draft1. 背景1. 耗电问题表现1. 耗电统计原理    1. 计算公式    1. Android 硬件模块电量统计    1. BatteryStatsService1. Matrix BatteryCanary    1. ProcStat    1. 线程池    1. UI 线程、Looper 线程    1. EventSlice    1. StackTrace1. 案例1. 其他耗电指标1. 拓展阅读    1. Benchmarks    1. 竞品--><!-- Header## App “耗电综合征”--><p>当我们说一个 App 耗电的时候我们在说什么？</p><p>我们可能是指 App 吃 CPU 导致系统掉电快，也可能是在说系统告警 App 后台扫描频繁消耗电量，还可能是在说使用 App 时手机发烫严重…… 是的，相对于 Crash、ANR 等常见的 APM 指标，Android App 电量优化更像是一个综合性的问题。</p><p>一方面，造成 App 耗电的原因是多种多样的，比如 CPU/GPU Load、屏幕、传感器以及其他硬件开销等，每个分类的排查思路是大相径庭的，再加上 AOSP 没有“官方”的耗电异常检测框架，各个 OEM 厂商自家系统对 App 耗电的监控方案又各不相同（且没有充分的公开文档），所以检测方案需要结合具体 App 项目实际和用户反馈状况，针对具体的耗电类型做出考量和取舍。另一方面，耗电问题也经常是比较“主观”的，比如用户感觉 App 新版本掉电比较快了，或者在户外气温比较高的环境使用 App 时感觉设备发烫了，又或只是单纯的因为使用时间变长了导致系统耗电排行靠前了等等，这些通常都是一些比较微妙的主观感受，难以量化问题。</p><p>因此，<strong>如何检测各种类型的耗电异常，以及如何提炼耗电问题的规则（划红线）是优化电量指标的关键所在</strong>。微信 Android 项目在与 App 耗电异常这项“疑难杂症”日常斗智斗勇的过程中，产出了一些比较实用的工具和优化思路。本文针对 Anroid App 的耗电问题，具体分为“App 电量统计原理”、“耗电异常监控方案”、以及相关的“优化案例”三部分进行解析和分享。</p><a id="more"></a><h2 id="App-电量统计原理"><a href="#App-电量统计原理" class="headerlink" title="App 电量统计原理"></a>App 电量统计原理</h2><h3 id="电量计算公式"><a href="#电量计算公式" class="headerlink" title="电量计算公式"></a>电量计算公式</h3><p>了解 App 电量统计原理之前，有必要先复习一下电量计算公式：</p><blockquote><p>电量 = 功率 × 时间</p></blockquote><p>其中需要注意一点的是， 功率 = 电压 × 电流。而在数码产品中，元器件一般对电流比较敏感，而电压基本是恒定的，所以我们直接使用电流来代替功率，这也是我们经常说“毫安时”（mAh）而不说“千瓦时/度”（kWh）的原因。</p><h3 id="Android-硬件模块的电量统计方式"><a href="#Android-硬件模块的电量统计方式" class="headerlink" title="Android 硬件模块的电量统计方式"></a>Android 硬件模块的电量统计方式</h3><p>了解计算公式之后，App 的电量统计思路就比较清晰了：</p><blockquote><p>App 电量 = SUM( 模块功率 × 模块时间 )</p></blockquote><p>其中模块主要是指 Android 设备的各种硬件模块，主要可以分为以下三类。</p><p><img src="/assets/4dcaf5d8_79f9_40e1_b58f_f5044b852a03_untitled.png" alt></p><p>第一类，像  Camera/FlashLight/MediaPlayer/一般传感器等之类的模块，其工作功率基本和额定功率保持一致，所以模块电量的计算只需要统计模块的使用时长再乘以额定功率即可。</p><p>第二类，像 Wifi/Mobile/BlueTooth 这类数据模块，其工作功率可以分为几个档位。比如，当手机的 Wifi 信号比较弱的时候，Wifi 模块就必须工作在比较高的功率档位以维持数据链路。所以这类模块的电量计算有点类似于我们日常的电费计算，需要“阶梯计费”。</p><p>第三类，也是最复杂的模块，CPU 模块除了每一个 CPU Core 需要像数据模块那样阶梯计算电量之外，CPU 的每一个集群（Cluster，一般一个集群包含一个或多个规格相同的 Core）也有额外的耗电，此外整个 CPU 处理器芯片也有功耗。简单计算的话，CPU 电量 = SUM( 各核心功耗 ) + 各集群（Cluster）功耗 + 芯片功耗 。如果往复杂方向考虑的话，CPU 功耗还要考虑超频以及逻辑运行的信息熵损耗等电量损耗（这方面有兴趣的话可以自行拓展查证，Android 系统 CPU 的电量统计只计算到芯片功耗这一层）。屏幕模块的电量计算就更麻烦了，很难把屏幕功耗合理地分配给各个 App， 因此 Android 系统只是简单地计算 App 屏幕锁（WakeLock）的持有时长，按固定系数增加 App CPU 的统计时长，粗略地把屏幕功耗算进 CPU 里面。</p><p>最后，需要特别注意的是，<strong>以上提到的各种功率和时间在 Android 系统上的统计都是估算的</strong>，可想而知最终计算出来的电量数值可能与实际值相差巨大，Facebook 的工程师对此也有所吐槽：<a href="https://github.com/facebookincubator/Battery-Metrics/blob/master/docs/mistrustbatterylevel.md" target="_blank" rel="noopener">Mistrusting OS Level Battery Levels</a>，这点大家心里要有一点概念。</p><h2 id="Android-系统电量统计服务"><a href="#Android-系统电量统计服务" class="headerlink" title="Android 系统电量统计服务"></a>Android 系统电量统计服务</h2><p>Android 系统的电量统计工作，是由一个叫 <strong>BatteryStatsService</strong> 的系统服务完成的。</p><p>先了解一下其中四个比较关键的角色：</p><ol><li>功率：power_profile.xml，Android 系统使用此文件来描述设备各个硬件模块的额定功率，包括上面提到的多档位功率和 CPU 电量算需要到的各种参数值。</li><li>时长：StopWatch &amp; SamplingCounter，其中 StopWatch ⏱  是用来计算 App 各种硬件模块的使用时长，而 SamplingCounter 则是用来采样统计 App 在不同 CPU Core 和不同 CpuFreq 下的工作时长。</li><li>计算：PowerCalculators，每个硬件模块都有一个相应命名的 PowerCalculator 实现，主要是用来完成具体的电量统计算法。</li><li>存储：batterystats.bin，电量统计服务相关数据的持久化文件。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>BatteryStatsService 的工作流程大致可以分为两个部分：时长统计 &amp; 功耗计算。</p><p><img src="/assets/8e770ef6_890e_406f_ba93_69f634d2b753_untitled.png" alt></p><h4 id="BatteryStatsService-时长统计流程"><a href="#BatteryStatsService-时长统计流程" class="headerlink" title="BatteryStatsService 时长统计流程"></a>BatteryStatsService 时长统计流程</h4><p>BatteryStatsService 框架的核心是 ta 持有的一个叫 <strong>BatteryStats</strong> 的类，BatteryStats 又持有一个 <strong>Uid[]</strong> 数组，每一个 Uid 实例实际上对应一个 App，当我们安装或者卸载 App 的时候，BatteryStats 就会更新相应的 Uid 元素以保持最新的映射关系。同时 BatteryStats 持有一系列的 StopWatch 和 SamplingCounter，当 App 开始使用某些硬件模块的功能时，BatteryStats 就会调用相应 Uid 的 StopWatch 或 SamplingCounter 来统计其硬件使用时长。</p><p>这里以 Wifi 模块来举例：当 App 通过 WifiManager 系统服务调用 Wifi 模块开始扫描的时候，实际上会通过 <code>WifiManager#startScan() --&gt; WifiScanningServiceImp --&gt; BatteryStatsService#noteWifiScanStartedFromSource() --&gt; BatteryStats#noteWifiScanStartedLocked(uid)</code> 等一连串的调用，通知 BatteryStats 开启 App 相应 Uid 的 Wifi 模块的 StopWatch 开始计时。当 App 通过 WifiManager 停止 Wifi 扫描的时候又会通过类似的流程调用<code>BatteryStats#noteWifiScanStoppedLocked(uid)</code> 结束 StopWatch 的计时，这样一来就通过 StopWatch 完成 App 对 Wifi 模块使用时长的统计。</p><h4 id="BatteryStatsService-功耗计算流程"><a href="#BatteryStatsService-功耗计算流程" class="headerlink" title="BatteryStatsService 功耗计算流程"></a>BatteryStatsService 功耗计算流程</h4><p>具体电量计算方面，BatteryStats 是通过 ta 依赖的一个 <strong>BatteryStatsHelper</strong> 的辅助类来完成的。BatteryStatsHelper 通过组合使用 Uid 里的时长数据、PoweProfile 里的功率数据（power_profile.xml 的解析实例）以及具体各个模块的 PowerCalculator 算法，计算出每一个 App 的综合电量消耗，并把计算结果保存在 <strong>BatterySipper[]</strong> 数组里（按计算值从大到小排序）。</p><p>还是以 Wifi 模块来举例：当需要计算 App 电量消耗的时候，BatteryStats 会通过调用 <code>BtteryStatsHelper#refreshStats() --&gt; #processAppUsage()</code> 来刷新 BatterySipper[] 数组以计算最新的 App 电量消耗数据。而其中 Wifi 模块单独的电量统计就是在 processAppUsage 方法中通过 WifiPowerCalculator 来完成的：Wifi 模块电量 = PowerProfile 预置的 Idle 功率 × Uid 统计的 Wifi Idle 时间 + 上行功率 × 上行时间 + 下行功率 × 下行时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WifiPowerCalculator</span> <span class="keyword">extends</span> <span class="title">PowerCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        app.wifiPowerMah =</span><br><span class="line">                ((idleTime * mIdleCurrentMa) + (txTime * mTxCurrentMa) + (rxTime * mRxCurrentMa))</span><br><span class="line">                / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>作为补充，这里罗列几个 BatteryStatsService 系统服务的应用场景来说明其工作方式。</p><h4 id="Android-系统-App-耗电排行"><a href="#Android-系统-App-耗电排行" class="headerlink" title="Android 系统 App 耗电排行"></a>Android 系统 App 耗电排行</h4><p>通过以上分析，我们其实已经知道 Android 系统 App 耗电排行是通过读取 BatteryStatsHelper 里的 BatterySipper[] 数据来实现排行的。一般情况下，BatteryStats 的统计口径是 <code>STATS_SINCE_CHARGED</code>, 也就距离上次设备充满电到现在的状态。不过个别 OEM 系统上这里的统计细节有所不同，有的 Android 设备系统可以显示最近数天甚至一周以上的 App 的电量统计数据，具体实现细节不得而知，姑且推断是根据 BatteryStatsHelper 自行定制的服务。</p><h4 id="adb-dumpsys-batterystats-amp-adb-bugreport"><a href="#adb-dumpsys-batterystats-amp-adb-bugreport" class="headerlink" title="adb dumpsys batterystats &amp; adb bugreport"></a>adb dumpsys batterystats &amp; adb bugreport</h4><p>或许你已经知道怎么通过 <code>adb dumpsys batterystats</code> 或者 <code>adb bugreport</code> Dump 出系统的电量统计数据，以及如何配合 Battery Historian 工具来分析这些数据，实际上这些 adb 命令都是通过 BatteryStatsService 查询 BatteryStats 里持有的 Uid[] 来获得相应的电量统计数据，具体实现可以参考 <code>com.android.server.am.BatteryStatsService#dump</code>。</p><h4 id="CPU-Load-Usage"><a href="#CPU-Load-Usage" class="headerlink" title="CPU Load/Usage"></a>CPU Load/Usage</h4><p>“CPU Load xx%  yy% zz% ” 之类的数据相信大家都或多或少见过，ANR 的 traces.txt、以上的 batterystats 和 bugreport Dump 出来的数据，以及 adb top 命令里都会显示类似的 CPU 负载数据，实际上这个数据也是通过 CPU 模块的统计时长来计算：CPU Load = SUM(App CPU Core 时长时间) / CPU 工作时间。需要注意的是 App CPU 时长是按 CPU Core 为单位分开计算的，所以计算结果完全可能超过 100%，比如一个 8 核心的 CPU 计算结果的理论上限是 800%。</p><h2 id="BatteryCanary"><a href="#BatteryCanary" class="headerlink" title="BatteryCanary"></a>BatteryCanary</h2><p>经过以上分析，我们知道 BatteryStatsService 里已经有比较详细的 App 电量统计数据。不过上帝刚给我们开了一扇窗，转身就把门给拆了。实际上这个系统服务对 App 是隐藏的，也就是说在 App 里我们无法直接访问 BatteryStatsService 里的数据（HealthStats 服务能间接访问一部分数据），不过这也不是说我们完全没有办法。</p><p><strong>既然我们已经知道了 Android 系统的调用统计原理，那么用类似的计算方案在 App 内部进行电量统计应该也能得到一个近似解</strong>。这也是 Matrix BatteryCanary 的核心原理，具体实现大致可以分为两部分：线程监控 &amp; 系统服务调用监控。</p><h3 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h3><p>实际上，我们除了通过 <code>SystemClock.currentThreadTimeMillis()</code> 来获取当前 Java 线程的工作时间此外，并没有直接的办法能够直接获取 App 所有线程的工作时长和状态，幸运的是 Linux 的 proc 命令可以给我们提供一些帮助。</p><p>Linux 命令 <code>proc/[pid]/stat</code> 和 <code>proc/[pid]/task/[tid]/stat</code> 可以 Dump 当前 App 进程和线程的统计信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /proc/&lt;mypid&gt;/task/&lt;tid&gt;/<span class="built_in">stat</span></span><br><span class="line">10966 (terycanary.test) S 699 699 0 0 -1 1077952832 6187 0 0 0 22 2 0 0 20 0 17 0 9087400 5414273024 24109 18446744073709551615 421814448128 421814472944 549131058960 0 0 0 4612 1 1073775864 1 0 0 17 7 0 0 0 0 0 421814476800 421814478232 422247952384 549131060923 549131061022 549131061022 549131063262 0</span><br></pre></td></tr></table></figure><p>这里比较关键的数据是 <code>进程/线程名</code>、<code>进程/线程状态</code>，以及第 13 - 16 位的 <code>utime</code>、<code>stime</code>、<code>cutime</code> 和 <code>cstime</code>。utime 和 stime 分别是进程/线程的用户时间和系统时间，而 cutime/cstime 是当前进程等在子进程的时间（在 Android 进程上大都是 0）。实际上我们对这些数据内容也不完全是陌生的，Logcat 里一些线程相关的 syslog 也有类似的输出，如下图所示。</p><p><img src="/assets/19e02336_b567_42a8_8bff_b5b8a9d0f361_untitled.png" alt></p><p>在这里有一点需要单独拎出来讲：<strong>utime 和 stime 具体代表什么意义呢？</strong>我们已经知道它们是表示线程的工作时长，但实际上其单位 jiffy 并不是一个时间的单位，而是一个频率的单位！</p><p>就如你所看到的，上图截图中有个圈起来的线程数据：HZ=100。这个数值代表当前 Linux 系统给进程（具体点说是线程）分配 CPU Slice 资源的周期频率是 100Hz，换句话说就是系统软件中断的频率是每秒 100 次。假如一个周期的这 100 个 CPU Slice 全部分配给某个线程，那么这个线程的 CPU 开销就是 100 Jiffies，共占用 CPU 一个周期的时间 （1 秒）。</p><blockquote><p>Android Linux 上，100 Jiffies ≈ 1 Second</p></blockquote><p>所以我们可以记住一个比较重要的结论：在 Android 系统上，Jiffy 和 Millis 的换算关系大概是 1 比 10。（100 Hz 是一个 Linux 系统的编译参数，在不同的 Linux 版本上这个值可能是不同的。） </p><h3 id="系统服务调用监控"><a href="#系统服务调用监控" class="headerlink" title="系统服务调用监控"></a>系统服务调用监控</h3><p>系统服务调用监控就比较简单了，主要分为 SystemService Hook 和 ASM 插桩两种方案，具体实现大家应该都比较熟悉了，这里不再赘述。不同需要注意的是，SystemService Hook 在不同 Android API Level 上面存在较多的兼容性问题（特别是在新 API Level 的变动上面坑比较多），而 SystemService ASM 经常会插漏一些运行时动态加载的插件。具体生产环境的应用上，以 ASM 为主 Hook 为辅的方案比较合适。</p><h3 id="一些实现细节"><a href="#一些实现细节" class="headerlink" title="一些实现细节"></a>一些实现细节</h3><p>以上提到的监控方案，已经能兜住大部分的 App 耗电监控需要，不过在实际具体项目的实现细节上，依然存在不少的挑战。</p><h4 id="App-状态统计"><a href="#App-状态统计" class="headerlink" title="App 状态统计"></a>App 状态统计</h4><p>电量监控跟其他质量指标监控相比有个不同的地方就是 ta 是一个过程，其他异常比如 Crash / ANR 发生的时候是瞬时的。比如 Crash 发生的时候，可以一并获取 App 的前后台状态再上报，这样我们就能有效区分前台、后台 Crash（这很重要，因为前台 Crash 优先级要高许多）。然而电量上报就不能这么做了，因为我们监控到一个 App 在 10 分钟的统计窗口里出现了耗电异常，当我们上报的时候获取得到 App 状态是后台的，然而 App 完全有可能前面 9 分钟都是前台的，最后 1 分钟才进入了后台，因此这样我们统计出来的状态数据是有失真的。同样，设备充电、亮灭屏等状态也有类似的问题。</p><p><img src="/assets/b1e246bc_f6fe_4a80_b0dd_52814e79bb21_untitled.png" alt></p><p>这个问题早期给我们带来不少麻烦，甚至造成一些电量 Bug 交付的乌龙。好在我们很快就发现这个问题并做出了改善：类似 CPU Slice，我们使用一种叫做 Event Slice 的方案来计算一段时间窗口内 App 的状态占比。根据上图，在设备状态发生变化的时候，我们记下每一个 Event 的 Stamp，统计 App 状态时，根据统计窗口的起始时间和结束时间，我们就可以计算出这段时长内 App 每个事件状态的占比。</p><h4 id="线程池问题细分"><a href="#线程池问题细分" class="headerlink" title="线程池问题细分"></a>线程池问题细分</h4><p>通过 procStat 监控到的异常线程，如果其业务相关性比较强的话一般都能很快解决。不过如果出现异常的是线程池之类的线程就比较麻烦了：和上面的状态统计一样，线程出现异常的时候，正在执行的 Runnable 任务，不一定就是真正导致异常的元凶。</p><p>为了解决这个问题，我们设计了一下两种方案：</p><ol><li>Runnable Jiffies 统计：我们给线程池的每一个 TaskRunnable 实例都包裹一层 RunnableWrapper，并在 <code>Wrapper#run</code> 里执行 TaskRunnable 的前后，分别计算当前线程的 Jiffies 差值 Delta，已得到当前  TaskRunnable 的实际 Jiffies 开销。</li><li>Task Slice 方案：在方案 1 的基础上，我们已经得到每个线程池线程上执行的 TaskRunnable Jiffies 信息，然后应用类似 Event Slice 的统计方案，我们就能得出每个线程池线程某一段出现异常的 Jiffies Delta 窗口里，执行的 TaskRunnable 的占比信息，从而推断出哪些 TaskRunnable 是导致线程耗电的元凶。</li></ol><h4 id="线程异常现场"><a href="#线程异常现场" class="headerlink" title="线程异常现场"></a>线程异常现场</h4><p>通过线程 Jiffies 和线程 State，我们可以监控到某些线程出现了异常，比如 App 待机的时候线程一直处于 Running 状态（State R）并且持续消耗 Jiffies。毋庸置疑，我们已经发现了 App 耗电异常的原因和问题现场。这时候新的挑战出现了，虽然我们已经足够确信目标线程出现耗电异常，但是这类有问题的线程并不是一直有 Log 输出的（特别是处于死循环状态的线程），缺乏现场日志，我们分析和优化耗电异常的效率将大大降低。</p><p>虽然我们很快想到了用 Thread 相关的 API 来 Dump Java 线程异常现场的 StackTrace，但是对于 Native 线程却是一丁点儿办法都没有。无奈之下，一开始我们也只能用一些比较笨的办法来处理，比如 Review 可疑代码并加多 Log，甚至通过 tkill/tgkill 的方式来主动触发 Native 线程 Crash 从而把 StackTrace Dump 出来。后来我们发现一种成本比较低的方案：通过主动模拟 ANR 触发系统 Dump 线程 Trace Log  从而获取所有线程的 StackTrace（目前由 Matrix AnrDumper 工具实现）。</p><p>以上陈述的各种方案，已经帮我们项目监控到了大部分的耗电问题，以下列举一些优化案例作为分享。</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>很多看似复杂的耗电异常问题（特别是高耗），最终排查下来都是一些看似简单的“低级错误”导致，如果一个个单独拎出来讲解的话，总有一股“走近科学”的味道，所以这里聚合成几类问题分别进行讲解。</p><h3 id="长时、频繁任务"><a href="#长时、频繁任务" class="headerlink" title="长时、频繁任务"></a>长时、频繁任务</h3><p>相信不少人同我一样有一个朴素的开发观念，那就是对于一个长时任务就应该把 ta 丢进 Worker 线程、线程池里去执行。换句话说，只要不在 UI 线程执行，大家对 ta 性能开销的敏感度或者心理预期就大大降低了。然而，这类长时任务，或者频繁的短时任务有时候也会造成 App 后台 CPU 负载异常。</p><p>比如微信部分为了优化用户体验的 PreLoad 逻辑（Emoji 资源、朋友圈资源等），会直接被丢进线程池里执行，有时候 App 已经待机好长一段时间了，相关的预载逻辑还在执行，从而导致系统 CPU Load 异常告警。又比如，有个古老的轻量 IO 逻辑为了方便是直接在 UI 线程里执行的，后来我们发现这里产生 ANR 了，然后就把这个逻辑挪到了 Woker 线程里执行并解决了 ANR，然而这个逻辑实际上在极端的条件下是因为出现死循环才导致的 ANR，这样简单的处理方案会导致 Woker 线程进入死循环并且不宜被发现。</p><p>类似的“低级错误”还有好多，这给我们提供一个深刻的教训：<strong>运行时间在分钟量级以上的任务都应该考虑待机耗电问题，而不是简单地异步化就完事了</strong>。在这方面，BatteryCanary 提供了电量相关的生命周期接口和事件回调，用于在 App 进入待机后的某个恰当时机来退出长时、频繁任务。</p><h3 id="前后台判断"><a href="#前后台判断" class="headerlink" title="前后台判断"></a>前后台判断</h3><p>Android App 耗电异常发发生后台的状态的案例比较多，实际上 Android 系统的性能优化也一直朝着收敛 App 后台活动范围的方向发展，所以我们有必要在 App 进入后台并持续一段适合的时间后，执行一些退出和析构逻辑，并严格限制后台 Task。不幸的是，我们也在这里翻车了。</p><p>早期微信小程序框架并没有提供<strong>持续定位</strong>的接口，部分需要持续定位的小程序则是通过循环调用单次定位接口来实现目的，而有时候定位服务需要通过 Wifi 或者 Bluetooth 来实现辅助定位，所以一旦小程序进入后台后还在循环调用单次定位接口来实现实时导航等服务时，我们不仅获取了一堆系统的后台 GPS/Wifi/Bluetoosh 扫描异常告警，还成功把 App 推上系统耗电排行榜的宝座。</p><p>另一次翻车则与播放器有关：微信的视频播放有个自动播放的逻辑，当视频 Prepared 完毕就可以自动 Loop 播放，当 App 进入后台时候停止视频播放，然而这里有个遗留的代码缺陷：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (player.isPrepared) &#123;</span><br><span class="line">        player.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你已经看出问题了，当 App 进入后台时，如果 Player 还没有完成 Prepare，那么 ta 将彻底失去 stop 的机会，当缓冲完毕的时候，播放器就会一直在后台 Loop 播放了。</p><p>此外，Android App 前后台状态的判断有很多种办法，这里必须指出的是部分方案是有版本兼容性问题的，比如有个方案是通过判断 App 自身是否在 <code>ActivityManager#getRunningAppTasks</code> 数组顶部来判断 App 是否在前台，然而 Android L 之后这个 API 只会返回 App 自身相关的 Tasks，也就是说结果会恒为前台，最终导致有些需要通过这个 API 来判断并限制后台活动的任务就会失控。（作为目前比较靠谱的方案，可以考虑通过 <code>ActivityManager.RunningAppProcessInfo#importance</code> 的值来判断 App 前后台状态。）</p><h3 id="Loop-退出逻辑不完备"><a href="#Loop-退出逻辑不完备" class="headerlink" title="Loop 退出逻辑不完备"></a>Loop 退出逻辑不完备</h3><p>Loop 循环控制异常是耗电问题的重灾区。</p><h4 id="while-true"><a href="#while-true" class="headerlink" title="while(true) {}"></a>while(true) {}</h4><p>有些算法实现使用 <code>while(true) {}</code> 之类的 Loop 结构来完成通常会比较简单和直观，然而这里也是比较容易翻车的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1: 退出判断不在当前 while block 内部</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (shouldExit()) &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2: 有限状态机 + 责任链</span></span><br><span class="line"><span class="keyword">var</span> playerStatus = int(status)</span><br><span class="line"><span class="keyword">val</span> consumers = listOf(consumers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> cosumer : consumers) &#123;</span><br><span class="line">       <span class="keyword">if</span> (consumer.accept(playerStatus)) &#123;</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Case 1，因为作为 Exit Conditioning 的判断方法 <code>shouldExit()</code> 不在 while 循环体内部，很容易在后续的代码迭代过程中因为调整了 shouldExit 的实现细节，导致 while block 出现了死循环的破绽。而对于 Case 2，这实际上是微信播放器某个老版本的实现，通过“状态机 + 责任链”的模式能有效地解耦播放器各个业务模块的控制逻辑，但是这样的设计实际上也是把 while block 的 Exit Conditioning 挪到了外部的 Consumer 里，容易因为出现某个新添加进来 playerStatus 所有的 consumers 都无法消耗，从而出现 while 死循环。</p><h4 id="Loop-嵌套"><a href="#Loop-嵌套" class="headerlink" title="Loop 嵌套"></a>Loop 嵌套</h4><p>目前 Android 项目中，Java 8 或者 Kotlin 相对 Java 7 的占比还是比较小（特别是规模比较大的项目），因此在处理一些比较复杂的数据结构时，相比起使用新语言特性中 Collection 相关的“流式编程”，我们更加偏向使用传统 Loop 嵌套的方式来实现数据结构的转化，而且其中往往还伴随着比较严重的“胶水代码”，这也给 Loop 循环控制埋下了隐患。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop 套娃</span></span><br><span class="line"><span class="keyword">while</span> (condition1) &#123;</span><br><span class="line">    <span class="keyword">while</span> (condition2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exit == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> or <span class="keyword">continue</span> or <span class="keyword">return</span>?</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们项目中，就发现不止一处在类似以上代码的 Loop 嵌套结构中，因为“忘记”自己当前在哪一层，使用了错误的中断或者退出语句，结果导致了外层或者内层 Loop 死循环的悲剧。</p><h4 id="Loop-Sleep"><a href="#Loop-Sleep" class="headerlink" title="Loop + Sleep"></a>Loop + Sleep</h4><p>我们经常需要周期性地执行某些逻辑，所以我们也写了不少以下结构的代码来实现 Polling 操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop + Sleep = Polling</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">        sleep(<span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这样的写法也有不小的隐患：一旦 try-catch 代码块出现了异常，则 Loop 逻辑可能再也没有办法进入预设的 Sleep 状态，结果是还是死循环。令人意想不到的是，除了 Java 外，Native 代码也有类似的 Polling 问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = poll(fds, fdsCount, <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现个别机型会因为某些具体未知的原因（比如 App 进入后台因为系统限制 fd 出现了异常）导致 poll 系统调用失败，异常的 poll 调用会立即返回，而不是按照预想的每次 block 住线程 1000ms，最终也导致了 Native 线程出现了死循环。</p><p>以上 Loop 问题产生的原因虽然各不相同，但是结果却“出奇”地殊途同归：线程死循环。这是导致 App 出现系统耗电排行“屠榜”的重要原因，我综合地将以上所有的 Loop 问题原因归纳为“Loop 退出逻辑不完备，或者不健壮”。在编写类似 Loop 结构体的时候必须格外谨慎，最好是在 App 进入待机状态后有一个全局退出逻辑来作为兜底冗余。</p><h3 id="HashMap-并发操作导致的死循环（死链）"><a href="#HashMap-并发操作导致的死循环（死链）" class="headerlink" title="HashMap 并发操作导致的死循环（死链）"></a>HashMap 并发操作导致的死循环（死链）</h3><p>或许大家对于 HashMap/HashSet 等 Collection 类的线程安全问题并不陌生，但是我是没想到 <code>HashMap#put()</code> 和 <code>HashSet#add()</code> 等操作也会造成线程死循环。</p><p>在一次排查线程耗电异常的 case 中，我们发现目标线程的 Stacks 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|   -&gt; (RUNNABLE)ThreadPool#Thread-1(761)</span><br><span class="line">|      java.util.HashMap.put(HashMap.java:<span class="number">425</span>)</span><br><span class="line">|      java.util.HashSet.add(HashSet.java:<span class="number">217</span>)</span><br><span class="line">|      ...</span><br><span class="line">|      java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">428</span>)</span><br><span class="line">|      java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">237</span>)</span><br></pre></td></tr></table></figure><p>一开始我怀疑  <code>java.util.HashMap.put(HashMap.java:425)</code> 这里是在内部自旋等待其他线程的操作所以没有仔细深入分析问题。随着类似的 Case 越来越多，我很快发现相关线程只要进入 <code>HashMap#put()</code> 后就再也没有退出，这基本可以排除自旋的可能性了。深入排查后，我们发现原来非 Concurrent 的 Collection 类的线程安全问题，除了造成“数据丢失或者读取脏数据”之外，还可能造成“线程死循环”。</p><p>问题的原因是当 HashMap 需要扩容的时候，需要进行一次 resize/rehash 的内部操作，在 Java7 上面这个操作需要进行链表重置。当重置链表过程出现并发操作时，就容易导致链表的元素出现循环的“死链”（多个线程同时迭代集合的元素），最终导致 <code>HashMap#put()</code> 调用进入死循环。</p><p>具体死链的原因分析请参考网络上其他详细的分析文章（Java 8 中相关链表设计被替换成红黑树，所以可以避免死链的问题，但是 HashMap 的线程安全问题仍然需要重视。）。</p><h2 id="使用-BatteryCanary"><a href="#使用-BatteryCanary" class="headerlink" title="使用 BatteryCanary"></a>使用 BatteryCanary</h2><p>当我们发现 App 耗电的时候能做些什么？</p><p>现在，除了像以往一样通过 adb top 查看 App 进程/线程异常，或者通过 adb dumpsys batterystats  和 Battery  Historian 查看 App 耗电数据之外，我们还能通过 BatteryCanary 实现 App 耗电问题的检测和线上监控。</p><p>文章最后，简单推广一下 BatteryCanary 的使用方式，主要包括以下两部分。</p><h3 id="Battery-Lifecycle"><a href="#Battery-Lifecycle" class="headerlink" title="Battery Lifecycle"></a>Battery Lifecycle</h3><p><img src="/assets/10481e77_fcba_4e78_89d0_c5b7d55a59bd_untitled.png" alt></p><p>BatteryCanary 默认会将一系列与电量相关的生命周期和事件输出到 Log 里，通过过滤 TAG <code>Matrix.battery.LifeCycle</code> 就可以获得相应的日志。</p><h3 id="Battery-电量报告-amp-Thread-Dump"><a href="#Battery-电量报告-amp-Thread-Dump" class="headerlink" title="Battery 电量报告 &amp; Thread Dump"></a>Battery 电量报告 &amp; Thread Dump</h3><p>除了 Battery 生命周期事件之外，BatteryCanary 还会周期性的 Dump 当前 App 的电量统计报告。当出现线程状态以及 Jiffies 开销异常的时候，还会将线程的 StackTrace Dump 出来。</p><p><img src="/assets/e9ea8aee_750b_4298_b2c3_2c6efad5fbaa_untitled.png" alt></p><p>以上方某用户反馈的耗电问题为例，可以按照以下流程来排查耗电问题：</p><ol><li>fg=bg, during=86：当前电量报告的统计口径为 App 进入后台 86 分钟的一段时间窗口。</li><li>avg(jffies/min)=6016：这 86 分钟内，当前进程每分钟的 CPU 开销为 6016 Jiffies，根据前面的分析， 6016 Jiffies = 6016 × 10 Millis ≈ 1 Min，也就是说当前进程在后台这一个多小时里，一直占满一个 CPU Core 以上的资源。</li><li>inc_thread_num &amp; cur_thread_num：进程当前一共 175 条线程，统计期间减少了 5 条。</li><li>(~/R)Thread-29(27479) 5940/510924 jiffies：Top 1 的问题线程是“Thread-29”，tid 为 27479，统计期间一共消耗 510924 Jiffies（每分钟 5940）。</li><li>scanning：统计期间进程 Bluetooth/Wifi/GPS 调用为 0。</li><li>app_stats：统计期间进程的前后台、充电、亮灭屏等状态。</li></ol><p>根据以上的排查结果，可以发现导致 App 耗电的主要原因是“Thread-29”线程在后台期间一直 Running，在电量统计报告的下方也可以看到该线程的 StackTrace Dump，从中可以定位到该线程一直在 mg_mgr_poll 方法中循环…… 至此，后续的工作就简单多了。</p><p><img src="/assets/279c062c_1e96_4d84_8175_b5215c19b5ba_untitled.png" alt></p><p>目前，BatteryCanary 作为 Matrix 项目集成的一个插件模块，已经在微信 Android 项目上稳定运行多个版本，并且帮助我们成功定位和优化多个严重的耗电问题，欢迎各位前来食用和反馈：<a href="https://github.com/Tencent/matrix。" target="_blank" rel="noopener">https://github.com/Tencent/matrix。</a></p><hr><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>以下内容为拓展阅读，罗列的数据仅供参考，具体以大家实际测试和使用感受为准。</p><h3 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h3><p>电量监控本身势必给 App 带来额外的功耗，所以全量应用在线上环境的时候要格外小心。BatteryCanary 框架的监控功耗主要是在系统服务调用（统计 App、Device 状态需要）和 procStat 数据解析这两个方面。</p><p>Pixel 1/Pixel 4/Pixel 5 设备上的测试数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Linux procStat 数据解析</span></span><br><span class="line"><span class="comment"># Benchmark 1. 连续 10000 次 procStat 解析</span></span><br><span class="line">Pixel 1: 耗时均值约 3467 ms，平均每次解析耗时 0.34 ms</span><br><span class="line">Pixel 4: 耗时均值约 1100 ms，平均每次解析耗时 0.11 ms  </span><br><span class="line">Pixel 5: 耗时均值约 1000 ms，平均每次解析耗时 0.10 ms  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 线程池 Task 监控</span></span><br><span class="line"><span class="comment"># 1. 整体额外开销大概在 2% ~ 5%</span></span><br><span class="line"><span class="comment"># 2. 看起来 CPU 比较差、闪存比较老旧的设备上，监控带来的额外消耗平摊下来占比反而比较小</span></span><br><span class="line"><span class="comment"># 3. 线程池的监控 Benchmarks 模拟的是极端状况，在短频、长时的状况下要乐观许多</span></span><br><span class="line"><span class="comment"># Benchmark 2. 线程池串行执行 100 个 Task（100ms），计算开启线程池监控的额外消耗</span></span><br><span class="line">Pixel 1: 耗时对比增量均值约 +4.2%</span><br><span class="line">Pixel 4: 耗时对比增量均值约 +4.7%</span><br><span class="line">Pixel 5: 耗时对比增量均值约 +4.9%</span><br><span class="line"></span><br><span class="line"><span class="comment"># Benchmark 3. 低并发执行 100 个 Task（100ms），计算开启线程池监控的额外消耗</span></span><br><span class="line">Pixel 1: 耗时对比增量均值约 +3.5%</span><br><span class="line">Pixel 4: 耗时对比增量均值约 +5.1%</span><br><span class="line">Pixel 5: 耗时对比增量均值约 +5.0%</span><br><span class="line"></span><br><span class="line"><span class="comment"># Benchmark 4. 高并发执行 100 个 Task（100ms），计算开启线程池监控的额外消耗</span></span><br><span class="line">Pixel 1: 耗时对比增量均值约 +2.0%</span><br><span class="line">Pixel 4: 耗时对比增量均值约 +5.5%</span><br><span class="line">Pixel 5: 耗时对比增量均值约 +5.5%</span><br></pre></td></tr></table></figure><h3 id="Facebook-Battery-Metrics"><a href="#Facebook-Battery-Metrics" class="headerlink" title="Facebook Battery-Metrics"></a>Facebook Battery-Metrics</h3><p>目前 Android 平台电量相关的开源方案并不多，我们只发现 Facebook 有个电量统计相关的开源项目 Battery-Metrics 能满足类似的需求，其基本设计思路与 BatteryCanary 类似，都是模拟 BatteryStatsService 的统计行为来测量 App 的电量消耗。不过 Battery-Metrics 的设计初衷是其工程师不“信任”Android 系统的耗电报告，因此编写此框架来统计他们自己想要的电量指标，两者在具体实现和数据取舍上的区别比较大。</p><ol><li>BatteryCanary 最核心的功能是通过监控线程异常来定位 App 的耗电 Bug，主要包括线程电量统计、堆栈信息和线程池问题细分等；BatteryMetrics 似乎比较关心 App 整体的耗电，CPU 模块的电量统计只有进程层级的。</li><li>BatteryCanary 通过 Hook、ASM 等手段实现 App 系统服务调用的监控；BatteryMetrics 则是设计一系列调用服务统计的 MetricsCollectors，需要在 App 调用系统服务时显式地调用一下 Collector 进行统计。</li><li>BatteryCanary 默认会监控 App 进入后台后的待机功耗，并统计 App、Device 的状态变化，用来检测用户实际使用感受中耗电比较敏感的场景；BatteryMetrics 则比较偏向线下电量压测，通过一堆  Collectors 收集尽可能多的数据来测试 App 功耗指标。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>[1] <a href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-battery-canary" target="_blank" rel="noopener">Matrix BatteryCanary</a><br>[2] <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/res/res/xml/power_profile.xml" target="_blank" rel="noopener">power_profile.xml</a><br>[3] <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java;l=568?q=BatteryStatsHelper" target="_blank" rel="noopener">BatteryStatsHelper</a><br>[4] <a href="https://github.com/facebookincubator/Battery-Metrics" target="_blank" rel="noopener">Battery-Metrics</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Android App 电量统计原理与优化Date = 2021-08-14Published = trueCategory = AndroidTag = ['Android', 'APM', '电量优化']FileLocate = FileName = android-apm-battery-stats-opthexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;!-- changelog
2021-09-10
修订 3
Add: 

1. 案例分享：HashMap 死链

2021-07-27
修订 2
Add: 

1. 项目使用效果

2021-07-21
修订 1
Add: 

1. 拓展阅读

2021-07-20
初稿
--&gt;
&lt;!-- draft

1. 背景
1. 耗电问题表现
1. 耗电统计原理
    1. 计算公式
    1. Android 硬件模块电量统计
    1. BatteryStatsService
1. Matrix BatteryCanary
    1. ProcStat
    1. 线程池
    1. UI 线程、Looper 线程
    1. EventSlice
    1. StackTrace
1. 案例
1. 其他耗电指标
1. 拓展阅读
    1. Benchmarks
    1. 竞品

--&gt;
&lt;!-- Header

## App “耗电综合征”

--&gt;
&lt;p&gt;当我们说一个 App 耗电的时候我们在说什么？&lt;/p&gt;
&lt;p&gt;我们可能是指 App 吃 CPU 导致系统掉电快，也可能是在说系统告警 App 后台扫描频繁消耗电量，还可能是在说使用 App 时手机发烫严重…… 是的，相对于 Crash、ANR 等常见的 APM 指标，Android App 电量优化更像是一个综合性的问题。&lt;/p&gt;
&lt;p&gt;一方面，造成 App 耗电的原因是多种多样的，比如 CPU/GPU Load、屏幕、传感器以及其他硬件开销等，每个分类的排查思路是大相径庭的，再加上 AOSP 没有“官方”的耗电异常检测框架，各个 OEM 厂商自家系统对 App 耗电的监控方案又各不相同（且没有充分的公开文档），所以检测方案需要结合具体 App 项目实际和用户反馈状况，针对具体的耗电类型做出考量和取舍。另一方面，耗电问题也经常是比较“主观”的，比如用户感觉 App 新版本掉电比较快了，或者在户外气温比较高的环境使用 App 时感觉设备发烫了，又或只是单纯的因为使用时间变长了导致系统耗电排行靠前了等等，这些通常都是一些比较微妙的主观感受，难以量化问题。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;如何检测各种类型的耗电异常，以及如何提炼耗电问题的规则（划红线）是优化电量指标的关键所在&lt;/strong&gt;。微信 Android 项目在与 App 耗电异常这项“疑难杂症”日常斗智斗勇的过程中，产出了一些比较实用的工具和优化思路。本文针对 Anroid App 的耗电问题，具体分为“App 电量统计原理”、“耗电异常监控方案”、以及相关的“优化案例”三部分进行解析和分享。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="APM" scheme="http://kaedea.com/tags/APM/"/>
    
      <category term="电量优化" scheme="http://kaedea.com/tags/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基于 Notion 的笔记写作和博客分享自动化方案</title>
    <link href="http://kaedea.com/2021/05/20/devops/notion-to-markdown-file-automating-solution/"/>
    <id>http://kaedea.com/2021/05/20/devops/notion-to-markdown-file-automating-solution/</id>
    <published>2021-05-20T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fwoodcuts_16.jpg" alt="Page Cover"></p><!-- draft1. 背景1. Notion1. Solution & Workflows    1. 流程图    1. refer：[https://github.com/soruly/trace.moe#overview](https://github.com/soruly/trace.moe#overview)1. NotionDown--><p>个人认为，笔记（Note）、写作（Writing）和分享（Share）是 <code>个人知识管理</code> 重要的组成部分。笔记是知识元素，写作是知识汇总，分享是知识升华。固然每个人具体实践的方式会尽不相同，不过大家应该都或多或少能对体会其中存在的一些割裂感：</p><p>其一，笔记存在多端同步编辑的刚需。不过随着云笔记解决方案越来越成熟后，这问题现在已经有许多解决方案。其二，笔记草稿和写作正文之间的同步存在许多机械的地方：同一篇文章经常需要在草稿和正文（终稿）之间来回修订，而大部分情况下这两者的同步是通过复制粘贴和人工比对来完成的，这个过场是写作体验主要的割裂感之一。其三，写作正文完成之后的文章分享（Publish）也是一个麻烦的流程，尽管现在许多静态博客可以通过自动化技术完成部署，不过文章正文内容和部署用的 MarkDown 源文件之间的数据同步也是个非常头疼的事情：如果正文和 MD 文件分开处理，两者之间只能手动同步；如果直接用 MD 文件来写正文，又不得不面临现在多数云笔记糟糕的 MD 文件编辑体验（而且 MD 文件能否导出还是个未知数）；如果干脆使用 gitbook 之类的方案来编辑 MD 文件，那基于 git 的笔记云同步方案体验也不会好到哪。</p><p>自从改用静态博客代替 WordPress 来发表自己的文章、文档后，我不得已采用”云笔记写草稿，MD 文件保存文章正文，手动在草稿和正文之间同步“这样的 <code>原始</code> 的写作方案，以上说的几种割裂感也是一直以来我感到非常困扰的地方。</p><p>几番苦寻更好的云笔记体验方案，未果。直到 ta 的出现：<code>Notion</code> 。<br><a id="more"></a></p><h2 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h2><p><a href="http://notion.so" target="_blank" rel="noopener">Notion</a> 是一款时下比较流行的云笔记服务，虽然上线比较晚，不过 ta 却是众多云笔记里面”最靓的仔“。基于巧妙和独特的文本元素关系设计，Notion 可以将你的 Notes、Project Tasks / Plans、Doc / Wikis 等统统整合起来（还提供许多优秀的 Template 以满足不同的文档需要），在 ta 身上我看到了知识管理和项目管理的“大一统”的希望。</p><p>简单来说，Notion 抛弃了传统以段落（paragraph）为原子单位的做法，而是将所有的一切都当做 Block（是 Everything is Block）。一段文本是一个 TextBlock，一张图片也是一个 ImageBlock，Block 之间可以随意移动和嵌套。同时 Notion Block 被巧妙地设计成组合模式：一个 Block 可以是单一的 Block 也可以是 BlockGroup。这使得 Notion 可以满足几乎所有的文本关系，一片文章本身就是一个 PageBlock，PageBlock 即可以包含各种类型 Block 也可以包含 BlockGroup（用来存放 Table、Columns 等文本组），甚至文章本身就是一个 BlockGroup（类似于 Folder，用于存放一组子文章）。此外，Notion 的强大之处还在于 ta 提供了 CollectionBlock（可以认为是一个简化的 Excel），配合相关的 Notion APIs 我们甚至可以把其当做一个数据库来使用。</p><p>鉴于 Notion 优秀的多端同步服务和灵活的文本存储功能，我从开始接触到 ta 的时候就产生了“基于 Notion 优化一下自己的知识管理方案”的想法。不过眼下有两个问题还需进一步观察：其一， Notion 一开始是收费的（而且不便宜），我担心收益出现边际效应，成本不可控；其二，Notion 并没有 Official APIs，这会影响基于 Notion 的二次开发的稳定性，而稳定性又是自动化实践里非常重要的考量。</p><p>随着 Notion 开放免费的个人账号（Personal Plan）和官方 APIs 计划的展开，这些顾虑都再也不是问题。</p><h2 id="Solution-amp-Workflows"><a href="#Solution-amp-Workflows" class="headerlink" title="Solution &amp; Workflows"></a>Solution &amp; Workflows</h2><p>如何优化自己现有的知识管理方案呢，我的基本设想是这样的：</p><ol><li>基于 Notion 写作，所有的文本材料和源数据都统一放在 Notion 上面同步，避免“冗余写作”。</li><li>使用自动化手段（DevOps）从 Notion 中导出指定笔记的 MD 文件，解决笔记和写作正文之间的割裂感：源文件依然可以保留各种草稿、标注和评论等内容，导出的 MD 文件则根据配置只生成指定的正文内容。</li><li>同样使用自动化手段导出需要分享的 Notion 文章，自动部署到 Hexo 等静态博客。</li></ol><p>如果有需要，作为兜底策略可以定期导出 Notion 全部笔记数据并做好保存和版本控制，从而弥补 Notion 付费才能使用的历史记录功能和为需要从 Notion 迁移数据这种状况做准备（尝试过云笔记数据迁移的朋友应该知道这是什么考量）。</p><p>工作流程示意图如下：</p><p><img src="/assets/notiondown_gong_zuo_liu_cheng_shi_yi_tu_notiondown.png" alt="NotionDown 工作流程示意图"></p><h2 id="NotionDown-Project"><a href="#NotionDown-Project" class="headerlink" title="NotionDown Project"></a>NotionDown Project</h2><p>基于 CAP 编程原则，能复制的代码绝不自己写，一开始我抱着侥幸的心态去 GitHub 上面搜索，还真让我找到了类似的工程 <a href="https://github.com/nategadzhi/notoma" target="_blank" rel="noopener">notoma</a>。不过项目还处于 WIP  状态，等了快一年作者还没有什么动作，Demo 也是处于无法运行的状态，所以我索性自己动手好了。</p><p>自己写一个 3rd-party 的 Notion APIs 不太现实，好在同样的 GitHub 上面已经有先驱做了类似的项目 <a href="https://github.com/jamalex/notion-py" target="_blank" rel="noopener">notion-py</a>，相比之下这个项目的完成度已经非常高了（目前唯一的遗憾就是尚未支持 Notion private 笔记的访问，且项目开发文档有限）。</p><p>基于 notion-py 我写了一个用来支撑自己知识管理的 Notion 笔记导出项目 <a href="https://github.com/kaedea/notion-down" target="_blank" rel="noopener">notion-down</a>，主要用来自动从云笔记导出 MD 文件和部署博客（配合 circleci + 静态博客）。</p><p>NotionDown 的主要功能如下：</p><ol><li>统一在 Notion 平台上编辑笔记（集大成）。</li><li>基于 Notion 笔记 + 相应的编译配置，解析所需的 MD 文件（必须支持图片配置）。</li><li>根据配置将需要 Publish 的文章自动部署指定的静态博客（Hexo）。</li><li>相关配套的集成功能：图床配置，自定义短代码（如生成的文章内容按渠道配置动态调整），中英混排优化（pangu），拼写检查（双拼用户刚需）。</li></ol><p>如此一来，以后岂不是可以专心写作了？🤣<del>（鬼咧，正经 Bloger 谁写文章啊，不都是在折腾博客主题吗。）</del></p><h2 id="Substitute"><a href="#Substitute" class="headerlink" title="Substitute"></a>Substitute</h2><p>如果只是需要自动把 Notion 上面的笔记部署到静态博客，我这发现一个更简单的解决方案：<a href="https://chenhuichao.com/c32f80ee1ca84d45aaf63ee170e3c267" target="_blank" rel="noopener">Notion + GatsbyJs + Netlify 极致的博客体验</a>。</p><p>其基本思路是通过 Netlify 作为 Trigger 触发 GatsbyJs 插件服务读取 Notion 笔记数据，并存放到 Gatsby 平台，最终通过 Gatsby 提供的博客服务展示博客内容。有兴趣可以了解一下 <a href="https://www.gatsbyjs.com/" target="_blank" rel="noopener">Gatsby</a>，这套方案可以节省 circleci 和静态博客 generating 等不少中间流程。</p><!-- unsupported page blocktype: aliasnotion id: a422096d-91ae-479a-87ad-ecf04df0c16d--><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 基于 Notion 的笔记写作和博客分享自动化方案Date = 2021-05-20Published = trueCategory = DevOpsTag = ['Notion', '知识管理', 'NotionDown']FileLocate = devopsFileName = notion-to-markdown-file-automating-solutionhexo.comments = false-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fwoodcuts_16.jpg&quot; alt=&quot;Page Cover&quot;&gt;&lt;/p&gt;
&lt;!-- draft

1. 背景
1. Notion
1. Solution &amp; Workflows
    1. 流程图
    1. refer：[https://github.com/soruly/trace.moe#overview](https://github.com/soruly/trace.moe#overview)
1. NotionDown

--&gt;
&lt;p&gt;个人认为，笔记（Note）、写作（Writing）和分享（Share）是 &lt;code&gt;个人知识管理&lt;/code&gt; 重要的组成部分。笔记是知识元素，写作是知识汇总，分享是知识升华。固然每个人具体实践的方式会尽不相同，不过大家应该都或多或少能对体会其中存在的一些割裂感：&lt;/p&gt;
&lt;p&gt;其一，笔记存在多端同步编辑的刚需。不过随着云笔记解决方案越来越成熟后，这问题现在已经有许多解决方案。其二，笔记草稿和写作正文之间的同步存在许多机械的地方：同一篇文章经常需要在草稿和正文（终稿）之间来回修订，而大部分情况下这两者的同步是通过复制粘贴和人工比对来完成的，这个过场是写作体验主要的割裂感之一。其三，写作正文完成之后的文章分享（Publish）也是一个麻烦的流程，尽管现在许多静态博客可以通过自动化技术完成部署，不过文章正文内容和部署用的 MarkDown 源文件之间的数据同步也是个非常头疼的事情：如果正文和 MD 文件分开处理，两者之间只能手动同步；如果直接用 MD 文件来写正文，又不得不面临现在多数云笔记糟糕的 MD 文件编辑体验（而且 MD 文件能否导出还是个未知数）；如果干脆使用 gitbook 之类的方案来编辑 MD 文件，那基于 git 的笔记云同步方案体验也不会好到哪。&lt;/p&gt;
&lt;p&gt;自从改用静态博客代替 WordPress 来发表自己的文章、文档后，我不得已采用”云笔记写草稿，MD 文件保存文章正文，手动在草稿和正文之间同步“这样的 &lt;code&gt;原始&lt;/code&gt; 的写作方案，以上说的几种割裂感也是一直以来我感到非常困扰的地方。&lt;/p&gt;
&lt;p&gt;几番苦寻更好的云笔记体验方案，未果。直到 ta 的出现：&lt;code&gt;Notion&lt;/code&gt; 。&lt;br&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="Notion" scheme="http://kaedea.com/tags/Notion/"/>
    
      <category term="NotionDown" scheme="http://kaedea.com/tags/NotionDown/"/>
    
      <category term="知识管理" scheme="http://kaedea.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Project NotionDown 🇯🇵</title>
    <link href="http://kaedea.com/2021/05/01/devops/project-notion-down-jp/"/>
    <id>http://kaedea.com/2021/05/01/devops/project-notion-down-jp/</id>
    <published>2021-05-01T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fnasa_buzz_aldrin_on_the_moon.jpg" alt="Page Cover"></p><p><a href="https://github.com/kaedea/notion-down" target="_blank" rel="noopener">Notion Down</a> とは、 Notion ページを Markdown ファイルにコンバートする Python ツールです。ちなみ、Hexo などのブログとのインテグレーションも可能です。このレポのインスピレーションやゴールは、「Notion のみでノートしながら自動的に目標な MD ファイルを生成する」ことで、ライティングの断片化を避ける。</p><a id="more"></a><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="http://www.kaedea.com" target="_blank" rel="noopener">kaedea.com</a><br><a href="http://hexo.kaedea.com" target="_blank" rel="noopener">hexo.kaedea.com</a><br><a href="https://www.kaedea.com/2021/05/20/devops/notion-to-markdown-file-automating-solution/" target="_blank" rel="noopener">基于 Notion 的笔记写作和博客分享自动化方案</a>  </p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p>今 NotionDown のできること：</p><ul><li>Notion ページのコンバート<ul><li><del>Basic Notion PageBlocks parsing</del></li><li><del>Notion images refer &amp; download</del></li><li><del>Notion nested list blocks</del></li><li><del>Notion obfuscated-links parsing</del></li><li><del>Notion table block (Collection)</del></li><li>Notion subpage / alias link parsing</li></ul></li><li>アドバンス Notion PageBlocks サポート<ul><li><del>Pullquote Blocks (Notion ColumnList)</del></li><li>イメージソースの変わり<ul><li><del>Replace notion image url with image file</del></li><li>Replace notion image url with other CDN urls</li></ul></li><li>Notion page embed blocks</li></ul></li><li>ライティングインハンス<ul><li><del>Noton custom <code>ShortCode</code> blocks that control parametered MD files generating</del></li><li><del>Mixed CN-EN text separation format</del> (<a href="https://github.com/vinta/pangu" target="_blank" rel="noopener">by pangu</a>)</li><li><del>Spelling inspect</del> (by <a href="https://github.com/shibing624/pycorrector" target="_blank" rel="noopener">pycorrector</a>)</li></ul></li><li>Hexo インテグレーション<ul><li><del>HEXO page properties config</del></li><li><del>HEXO generate</del></li><li>HEXO tags plugin</li></ul></li><li>PyPI パブリッシャ</li><li>Notion APIs<ul><li><del>notion-py (3rd party)</del></li><li>notion-sdk (official)</li></ul></li></ul><h2 id="ワークフロー"><a href="#ワークフロー" class="headerlink" title="ワークフロー"></a>ワークフロー</h2><p><img src="/assets/notiondown_workflows_notiondown.png" alt="NotionDown Workflows"></p><p>NotionDown は <a href="https://github.com/jamalex/notion-py" target="_blank" rel="noopener">notion-py</a> を使って Notion Page のデータを読み込む、そしてコンフィグレーションによって、目標な MD ファイルを生成する。</p><h3 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage"></a>Basic usage</h3><blockquote><p>notion-down &gt;&gt; Notion APIs (notion-py) &gt;&gt; Notion pages data &gt;&gt; generating MD files</p></blockquote><h3 id="Advanced-usage"><a href="#Advanced-usage" class="headerlink" title="Advanced usage"></a>Advanced usage</h3><blockquote><p>WebHook &gt;&gt; notion-down &gt;&gt; Notion APIs (notion-py) &gt;&gt; Notion pages data &gt;&gt; generating MD files &gt;&gt; Copy into Hexo source &gt;&gt; generating webpages &gt;&gt; push to GitHub pages</p></blockquote><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>準備：</p><ol><li><code>notion_token_v2</code> を取る。</li><li>ルーツページの <code>public notion blog_url</code> を取る。</li><li><code>notion-down/main.py</code> を実行する。</li></ol><p><code>notion_token_v2</code> のゲットする方法は <a href="https://github.com/kaedea/notion-down/blob/master/dist/parse_readme/notiondown_gettokenv2.md" target="_blank" rel="noopener">ここに</a> ある。</p><p><a href="https://www.notion.so/kaedea/NotionDown-Posts-Template-f77f3322915a4ab48caa0f2e76e9d733" target="_blank" rel="noopener">NotionDown Posts Template</a> を自分の Notion Workspace にコピーする、そしてそのURLを <code>blog_url</code> をしてつかいます（既存するルーツページを使うのもオッケー）。ちなみに、ルーツページを Public にセットすることが必要です。</p><h3 id="NotionDown-の実行"><a href="#NotionDown-の実行" class="headerlink" title="NotionDown の実行"></a>NotionDown の実行</h3><p><code>notion-down/main.py</code> の使い方：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run with cli cmd</span></span><br><span class="line">PYTHONPATH=./ python main.py \</span><br><span class="line">    --blog_url &lt;Notion Post Url&gt; \</span><br><span class="line">    --token_v2 &lt;token_v2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">PYTHONPATH=./ python main.py \</span><br><span class="line">    --config_file <span class="string">'.config_file.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># アーギュメントのコンフィグ：cli-args, config_file or SysEnv parameters</span></span><br><span class="line"><span class="comment"># Priority: cli args &gt; config_file &gt; SysEnv parameters &gt; NotionDown default</span></span><br></pre></td></tr></table></figure><p>くわりコンフィグレーションはここに <a href="https://github.com/kaedea/notion-down/blob/master/dist/parse_readme/notiondown_custom_configs.md" target="_blank" rel="noopener">Custom Configurations</a>。</p><p>以降は NotionDown のそれぞれな使い方を紹介する。</p><h3 id="CI-Builds"><a href="#CI-Builds" class="headerlink" title="CI Builds"></a>CI Builds</h3><p>チェック <code>/.circleci/config.yaml</code>：</p><ul><li><code>test-build-readme</code>: README.md を生成する CircleCI Jobs。</li><li><code>test-build-hexo</code>: デーモン Hexoソースコードを生成する CircleCI jobs、チェック <a href="https://github.com/kaedea/notion-down-hexo-showcase" target="_blank" rel="noopener">https://github.com/kaedea/notion-down-hexo-showcase</a>。</li><li><code>test-run-pycorrector</code>: スペルチェックの CircleCI jobs。</li></ul><h3 id="Showcase-Jobs"><a href="#Showcase-Jobs" class="headerlink" title="Showcase Jobs"></a>Showcase Jobs</h3><p>デーモンスクリプトは <a href="/jobs">/jobs</a> にあり、そしてアウトプットは <a href="/dist">/dist</a>。</p><ul><li><a href="/jobs/parse_readme/">Build README</a></li><li><a href="/jobs/parse_sample_posts/">Build Notion posts</a></li><li><a href="/jobs/parse_sample_posts_for_hexo/">Build Hexo ソースコード</a></li><li>Notion image page source replacing (WIP)</li></ul><h3 id="UnitTest-Examples"><a href="#UnitTest-Examples" class="headerlink" title="UnitTest Examples"></a>UnitTest Examples</h3><p>チェック <code>test/</code>。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Project NotionDown 🇯🇵Date = 2021-05-01Published = trueCategory = DevOpsTag = ['Notion', '日本語', 'NotionDown']FileLocate = devopsFileName = project-notion-down-jphexo.comments = false-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fnasa_buzz_aldrin_on_the_moon.jpg&quot; alt=&quot;Page Cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kaedea/notion-down&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Notion Down&lt;/a&gt; とは、 Notion ページを Markdown ファイルにコンバートする Python ツールです。ちなみ、Hexo などのブログとのインテグレーションも可能です。このレポのインスピレーションやゴールは、「Notion のみでノートしながら自動的に目標な MD ファイルを生成する」ことで、ライティングの断片化を避ける。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="Notion" scheme="http://kaedea.com/tags/Notion/"/>
    
      <category term="NotionDown" scheme="http://kaedea.com/tags/NotionDown/"/>
    
      <category term="日本語" scheme="http://kaedea.com/tags/%E6%97%A5%E6%9C%AC%E8%AA%9E/"/>
    
  </entry>
  
  <entry>
    <title>Project NotionDown</title>
    <link href="http://kaedea.com/2021/05/01/devops/project-notion-down/"/>
    <id>http://kaedea.com/2021/05/01/devops/project-notion-down/</id>
    <published>2021-05-01T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fnasa_buzz_aldrin_on_the_moon.jpg" alt="Page Cover"></p><p><a href="https://github.com/kaedea/notion-down" target="_blank" rel="noopener">Notion Down</a> 是一个用来把 Notion Page 转换成 Markdown 文件的 Python 工具，同时还提供了一些如 Hexo 静态博客构建的集成功能。其灵感和目标是通过“在 Notion 上写作并自动生成目标 MD 文件”来解决写作的割裂问题。比如：在 Notion 上编辑日志，并按照不同渠道配置生成目标 MD 文件；将指定 Notion 日志生成 Hexo Page 并自动部署到静态博客。</p><a id="more"></a><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p><a href="http://www.kaedea.com" target="_blank" rel="noopener">kaedea.com</a><br><a href="http://hexo.kaedea.com" target="_blank" rel="noopener">hexo.kaedea.com</a><br><a href="https://www.kaedea.com/2021/05/20/devops/notion-to-markdown-file-automating-solution/" target="_blank" rel="noopener">基于 Notion 的笔记写作和博客分享自动化方案</a>  </p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><p>现在 NotionDown 提供以下功能：</p><ul><li>Notion Page 转换成 MarkDown 文件<ul><li><del>Basic Notion PageBlocks parsing</del></li><li><del>Notion images refer &amp; download</del></li><li><del>Notion nested list blocks</del></li><li><del>Notion obfuscated-links parsing</del></li><li><del>Notion table block (Collection)</del></li><li>Notion subpage / alias link parsing</li></ul></li><li>Advanced Notion PageBlocks 支持<ul><li><del>Pullquote Blocks (Notion ColumnList)</del></li><li>图源替换<ul><li><del>Replace notion image url with image file</del></li><li>Replace notion image url with other CDN urls</li></ul></li><li>Notion page embed blocks</li></ul></li><li>写作增强<ul><li><del>Noton custom <code>ShortCode</code> blocks that control parametered MD files generating</del></li><li><del>Mixed CN-EN text separation format</del> (<a href="https://github.com/vinta/pangu" target="_blank" rel="noopener">by pangu</a>)</li><li><del>Spelling inspect</del> (by <a href="https://github.com/shibing624/pycorrector" target="_blank" rel="noopener">pycorrector</a>)</li></ul></li><li>HEXO 集成<ul><li><del>HEXO page properties config</del></li><li><del>HEXO generate</del></li><li>HEXO tags plugin</li></ul></li><li>PyPI 发布</li><li>Notion APIs<ul><li><del>notion-py (3rd party)</del></li><li>notion-sdk (official)</li></ul></li></ul><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/assets/notiondown_workflows_notiondown.png" alt="NotionDown Workflows"></p><p>NotionDown 通过 <a href="https://github.com/jamalex/notion-py" target="_blank" rel="noopener">notion-py</a> 读取 Notion Page 的数据，然后再（根据配置）解析成 MD 文件。</p><h3 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage"></a>Basic usage</h3><blockquote><p>notion-down &gt;&gt; Notion APIs (notion-py) &gt;&gt; Notion pages data &gt;&gt; generating MD files</p></blockquote><h3 id="Advanced-usage"><a href="#Advanced-usage" class="headerlink" title="Advanced usage"></a>Advanced usage</h3><blockquote><p>WebHook &gt;&gt; notion-down &gt;&gt; Notion APIs (notion-py) &gt;&gt; Notion pages data &gt;&gt; generating MD files &gt;&gt; Copy into Hexo source &gt;&gt; generating webpages &gt;&gt; push to GitHub pages</p></blockquote><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>前置准备：</p><ol><li>Prepare <code>notion_token_v2</code>.</li><li>Prepare <code>public notion blog_url</code> as root post for NotionDown to get the pages you want to handle.</li><li>Run <code>notion-down/main.py</code> with your configs.</li></ol><p>参考 <a href="https://github.com/kaedea/notion-down/blob/master/dist/parse_readme/notiondown_gettokenv2.md" target="_blank" rel="noopener">这里</a> 获取 <code>notion_token_v2</code>。 </p><p>复制一份 <a href="https://www.notion.so/kaedea/NotionDown-Posts-Template-f77f3322915a4ab48caa0f2e76e9d733" target="_blank" rel="noopener">NotionDown Posts Template</a> 到你的 Notion Workspace 并把其 URL 做为 <code>blog_url</code> (或者直接使用你自己已有的 Notion Posts)。需要注意的是，现阶段配合 notion_token_v2 使用的 Notion Posts 必须是 Public 的。</p><h3 id="运行-NotionDown"><a href="#运行-NotionDown" class="headerlink" title="运行 NotionDown"></a>运行 NotionDown</h3><p>执行 Python 基本 <code>notion-down/main.py</code> :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run with cli cmd</span></span><br><span class="line">PYTHONPATH=./ python main.py \</span><br><span class="line">    --blog_url &lt;Notion Post Url&gt; \</span><br><span class="line">    --token_v2 &lt;token_v2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">PYTHONPATH=./ python main.py \</span><br><span class="line">    --config_file <span class="string">'.config_file.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有三种方式配置 NotionDown 的运行参数：cli-args, config_file or SysEnv parameters</span></span><br><span class="line"><span class="comment"># Priority: cli args &gt; config_file &gt; SysEnv parameters &gt; NotionDown default</span></span><br></pre></td></tr></table></figure><p>更详细的参数配置，请参考 <a href="https://github.com/kaedea/notion-down/blob/master/dist/parse_readme/notiondown_custom_configs.md" target="_blank" rel="noopener">Custom Configurations</a>。</p><p>以下提供几种使用 NotionDown 的案例。</p><h3 id="CI-Builds"><a href="#CI-Builds" class="headerlink" title="CI Builds"></a>CI Builds</h3><p>参看以下 CI 脚本 <code>/.circleci/config.yaml</code>：</p><ul><li><code>test-build-readme</code>: CircleCI jobs 用来生成 NotionDown 的 README.md。</li><li><code>test-build-hexo</code>: CircleCI jobs 用来演示如何生成 Hexo 源文件 <a href="https://github.com/kaedea/notion-down-hexo-showcase" target="_blank" rel="noopener">https://github.com/kaedea/notion-down-hexo-showcase</a>。</li><li><code>test-run-pycorrector</code>: CircleCI jobs 用来演示如何执行拼写检查。</li></ul><h3 id="Showcase-Jobs"><a href="#Showcase-Jobs" class="headerlink" title="Showcase Jobs"></a>Showcase Jobs</h3><p>示例脚本放在 <a href="/jobs">/jobs</a>，其运行产物在 <a href="/dist">/dist</a>。</p><ul><li><a href="/jobs/parse_readme/">生成 README</a></li><li><a href="/jobs/parse_sample_posts/">生成 Notion posts</a></li><li><a href="/jobs/parse_sample_posts_for_hexo/">生成 Hexo 源文件</a></li><li>Notion image page source replacing (WIP)</li></ul><h3 id="UnitTest-Examples"><a href="#UnitTest-Examples" class="headerlink" title="UnitTest Examples"></a>UnitTest Examples</h3><p>单元测试放在 <code>test/</code>。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Project NotionDownDate = 2021-05-01Published = trueCategory = DevOpsTag = ['Notion', '知识管理', 'NotionDown']FileLocate = devopsFileName = project-notion-downhexo.comments = false-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fnasa_buzz_aldrin_on_the_moon.jpg&quot; alt=&quot;Page Cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kaedea/notion-down&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Notion Down&lt;/a&gt; 是一个用来把 Notion Page 转换成 Markdown 文件的 Python 工具，同时还提供了一些如 Hexo 静态博客构建的集成功能。其灵感和目标是通过“在 Notion 上写作并自动生成目标 MD 文件”来解决写作的割裂问题。比如：在 Notion 上编辑日志，并按照不同渠道配置生成目标 MD 文件；将指定 Notion 日志生成 Hexo Page 并自动部署到静态博客。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="Notion" scheme="http://kaedea.com/tags/Notion/"/>
    
      <category term="NotionDown" scheme="http://kaedea.com/tags/NotionDown/"/>
    
      <category term="知识管理" scheme="http://kaedea.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Bash 从入门到入土</title>
    <link href="http://kaedea.com/2018/08/20/bash-is-untype/"/>
    <id>http://kaedea.com/2018/08/20/bash-is-untype/</id>
    <published>2018-08-20T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/f0f8fb55_fea8_43ff_b2c1_b9b89b6f3a8f_untitled.png" alt></p><p>Bash 学习的深入可真是“从入门到入土”，个人感觉最佳实践应该是把 Bash 作为脚本入口，包一层别的脚本语言（比如 Python），后续工作全交由后者处理。</p><a id="more"></a><h2 id="Bash-is-Untype"><a href="#Bash-is-Untype" class="headerlink" title="Bash is Untype"></a>Bash is Untype</h2><ol><li>Bash 没有类型，所以Bash 所有变量都是 Text/String 文本。</li><li>if  [ $bool ] 其实是判断 bool 是不是 Not Empty。</li><li>因为都是文本类型，所以判断 Number 变量大小、加减，都需要使用配套的命令：-eq/-ne/-gt/-lt。</li></ol><h2 id="面向文本编程"><a href="#面向文本编程" class="headerlink" title="面向文本编程"></a>面向文本编程</h2><ol><li>Bash 语言里，一切都是 Text。</li><li>Bash 没有类型，甚至没有动态语言特有的结构，纯靠 Shell 工具解析 Bash 文本并执行相关指令。文本约束性太弱，经常会有意想不到的“惊喜”。</li><li>处理带有空格的 Var 的时候比较危险，因为空格有可能被当成 Bash 指令分隔符处理。</li><li>sh &lt;bash_file&gt; <args> 或者 eval <func> <args> 的时候，args 是被当成一个文本在解析成入参的。如果 args 包含有 Empty 参数，则该解析后的入参里会漏掉该参数并导致参数位置出现偏移。</args></func></args></li><li>文本有些场景需要加转义字符但是经常完了但是确没报错，比如：比较大于操作符 › 被当成文本输出操作符执行且返回 true。</li><li>文本还容易被当成命令执行。</li><li>抽取 Bash 重复代码段，使用 function 代替也会出现惊喜，特别是方法体里有 loop 以及需要返回值的时候。</li><li>function 方法块内最后的 statement 如果没有作为返回值赋值给一个 var，或者在方法最后使用 echo 来消费，则调用方法后改 statement 的值会作为 bash 指令执行。</li></ol><h2 id="Bash-编程最佳实践"><a href="#Bash-编程最佳实践" class="headerlink" title="Bash 编程最佳实践"></a>Bash 编程最佳实践</h2><ol><li>别思考 Bash 语法，直接 Google 反而更快一些。</li><li>Bash 语法有比较严重的兼容性问题，不仅不同 Bash 版本之间的 Bash 脚本表现可能不同，在不同终端（Shell）上面的运行效果可能也不一样。</li><li>要复用 Bash 代码能难，最好的实践就是 CAP 编程原则。</li><li>把 Bash 作为脚本入口，包一层别的脚本语言（比如 Python），后续工作全交由后者处理。</li></ol><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Bash 从入门到入土Date = 2018-08-20Published = trueCategory = DevOpsTag = BashFileLocate = FileName = bash-is-untypehexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/f0f8fb55_fea8_43ff_b2c1_b9b89b6f3a8f_untitled.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;Bash 学习的深入可真是“从入门到入土”，个人感觉最佳实践应该是把 Bash 作为脚本入口，包一层别的脚本语言（比如 Python），后续工作全交由后者处理。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="Bash" scheme="http://kaedea.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>动态下发 so 库在 Android APK 安装包瘦身方面的应用</title>
    <link href="http://kaedea.com/2018/06/04/android-so-loading-2/"/>
    <id>http://kaedea.com/2018/06/04/android-so-loading-2/</id>
    <published>2018-06-04T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.984Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知 Android 加载 so 文件本身就是一种运行时动态加载可执行代码的行为，所以把 so 做成动态下发的没有什么技术风险，不过要把这项技术稳定落地到实际生产项目中还是有不少麻烦的问题。本文根据实际项目经验，分享一些 so 动态化关键技术点和需要避免的坑。</p><a id="more"></a><h2 id="需求价值"><a href="#需求价值" class="headerlink" title="需求价值"></a>需求价值</h2><p>一般来说，越是成熟的 Android 项目，Native 代码的贡献量就越多，以往 APK 体积的主要占比大都是资源文件，不过现在 Native 代码带来的 so 体积占比也很可观了，所以 so 动态化的价值越来越凸显。另一方面，现在支持 arm64 的 Android 项目也越来越多，Google Play 更是强制要求支持 arm64，所以有的 Android 项目需要内置两种甚至以上 abi 支持（比如 B 站客户端项目就同时支持 arm32/arm64/x86 三种，以往还支持 arm5），结果就是 so 体积成倍地上涨。因此，能不能将非主要的 abi 相关的 so 文件动态化，也成为了国内 Android 项目瘦身优化不得不优先考虑的问题。</p><p>此外，一些第三方 SDK 库也自带了不少 so 库（比如腾讯视频 SDK，以前我在接入这个 SDK 的时候，项目本身才 15 MB 体积，而 SDK 自身 so 已经占了 17 MB），或许是为了精简第三方 SDK 带来的体积，或许是为了隔离第三方 SDK 的 API（项目只自身依赖自己定义的业务相关性 API，通过依赖注入的方式访问第三方 SDK 的实现，这样以后更换 SDK 的时候只需要切换依赖注入的形式即可），都需要具体的 so 动态化方案提供技术支撑。</p><h2 id="动态化需要解决的问题"><a href="#动态化需要解决的问题" class="headerlink" title="动态化需要解决的问题"></a>动态化需要解决的问题</h2><p>动态下发 so 库，看上只是把原本就算运行时动态加载的 so 文件，从 APK 安装包里面抽离出来，工作流程上变化不大，但实际上这也是一种完备的插件化技术，也就是说所有插件需要面临问题的问题我们统统需要考虑。我在以往的文章 <a href="http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems">使用 SO 库时要注意的一些问题</a> 中简单谈过 so 动态化的一些问题，不过那些问题也仅仅是在 DEMO 项目里进行挖掘，当具体投入到生产项目中时，面临的挑战要严峻许多。以下我针对实际投产时遇到的问题进行一一分析讲解。</p><h3 id="1-安全性问题"><a href="#1-安全性问题" class="headerlink" title="1. 安全性问题"></a>1. 安全性问题</h3><p>动态化本质上就是运行时加载可执行代码，而所有可执行代码在拷贝安装到安全路径（比如 Android 的 data/data 内部路径）之前，都有被劫持或者破坏的风险。so 动态化也不得不考虑这个安全性问题，最好的做法是每次加载 so 库之前都对其做一次安全性校验。考虑到检查带来的时间成本，可以假设内部路径是无条件可信的（对 Android 来说， data/data 路径在设备 root 情况下是不安全的；而且除了劫持风险外，内部路径文件有可能被应用自身一些不当文件操作给破坏导致插件不完整，因此如果要考虑绝对安全，内部路径插件被加载也必须做安全检查），在 so 文件拷贝到内部路径后单独做一次检查，检查失败就丢弃文件走 fail 逻辑，检查通过就生成一个 flag 文件作为标志，以后通过判断 flag 标志是否存在来决定是否需要执行安全检查。</p><p>怎么校验安全性呢？</p><p>最简单的方式是记录 so 文件的 MD5 或者 CRC 等 Hash 信息（粒度可以是每个单独的 so 文件，或者一批 so 文件的压缩包），将信息内置到 APK 内部或者服务器（如果保存在服务器，客户端需要通过类似 HTTPS 之类的可信通道获取这些数据），通过校验 so 文件 Hash 信息是否一致来确保安全性。不过 Hash 信息一般都会随之 so 文件的变动而改变，每次都需要调整这些数据比较麻烦，我想到的优化方案是“通过类似 APK 安装包签名校验的方式来确保安全性”：将 so 文件打包成 APK 格式的插件包并使用 Android Keystore 进行签名，将 Keystore 的指纹信息保存在宿主包内部，安全检验环节只需要校验插件包的签名信息是否和内置的指纹信息一致即可。（一种优化的方案是，使用和宿主包一样的 Keystore 给插件包签名，检验环节只需要检查插件和宿主的签名信息是否一致。）</p><p>具体代码实现可以参考一下：<a href="https://github.com/kaedea/android-dynamical-loading/blob/develop/android-frontia/frontia/src/main/java/moe/studio/frontia/PluginInstallerImpl.java#L54" target="_blank" rel="noopener">Installer#checkSafety()</a>。</p><h3 id="2-版本控制问题"><a href="#2-版本控制问题" class="headerlink" title="2. 版本控制问题"></a>2. 版本控制问题</h3><p>和一般的插件化方案一样，so 动态化也必须处理好版本控制问题：从 APK 里把 so 剥离出来后，我们除了要保证 so 文件的安全性，还要保证 so 文件和依赖它的宿主代码是 API 兼容的（严格上必须要求版本一直，至少做到向前兼容）。如果不需要一般插件那样考虑升降级问题，那也必须做到 so 文件和 APK 包版本是一致的：宿主下载相应版本的 so 文件后，安装到指定的版本路径；宿主版本升级后必须再次下载新版本的 so 文件而不能受到存量旧版本 so 文件的干扰（如果需要做到动态升降级，还需要保留最近一两个版本的存量 so 文件，用于 fallback 逻辑需要）。</p><p>版本控制除了解决插件的 API 兼容问题，还可以实现“<strong>即时吊销</strong>”策略。设想我们发布了某一个版本宿主 APK 和与之对应的 so 插件包，而这个版本的 so 是有 Bug 的可能导致 APP 崩溃。通过版本控制流程，我们可以在服务端禁用这个版本的 so 插件，从而使客户端进入“so 插件不可用”的逻辑，而不至于执行有问题的代码。（如果 so 插件支持动态升降级，还可以配置让客户端强制更新到 fix 插件版本，或者 fallback 回没有问题的存量旧版。）</p><p>从框架设计上，版本控制涉及动态化的 Update 和 Install 两个环节，具体实现代码可以参考 <a href="https://github.com/kaedea/android-dynamical-loading/blob/develop/android-frontia/frontia/src/main/java/moe/studio/frontia/PluginUpdaterImpl.java#L270" target="_blank" rel="noopener">Updater#doUpdatePolicy()</a> 和 <a href="https://github.com/kaedea/android-dynamical-loading/blob/develop/android-frontia/frontia/src/main/java/moe/studio/frontia/PluginInstallerImpl.java#L201" target="_blank" rel="noopener">Installer#isInstalled()</a>。</p><h3 id="3-abi-兼容性判断"><a href="#3-abi-兼容性判断" class="headerlink" title="3. abi 兼容性判断"></a>3. abi 兼容性判断</h3><p>abi 兼容性是 so 插件特有的动态化问题，除了考虑 so 插件是否安全之外，我们还需要检查 so 插件包里的 so 库 abi 信息是否与宿主目前运行时的 abi 一致。考虑这么一种情况：宿主 APK 里面内置了 ARM32 和 AMR64 两种 so 文件，同样插件包里也内置这两种 so 文件，当宿主 APK 安装在 ARM32 的设备上，动态加载 so 插件的时候，我们必须只解压并加载相应 AMR32 的 so 插件，对于 ARM64 的设备也是同样的道理。也就是说：同样的 APK 宿主，同样的 so 插件，安装在不同 abi 设备上时，动态化框架的插件处理行为是不一样的。</p><p>这个问题也可是说是版本控制问题上面的一个分支问题。考虑到框架的完备性，框架自身应该能自动设别和处理好 abi 兼容问题，而不是通过 so 插件的打包流程来规避这个问题（容错）。</p><h3 id="4-System-load-加载代码侵入问题"><a href="#4-System-load-加载代码侵入问题" class="headerlink" title="4. System#load 加载代码侵入问题"></a>4. System#load 加载代码侵入问题</h3><p>侵入性问题也是 so 插件特有的问题，这个问题跟 Android Framework 加载 so 库的具体方式有关。Framework 一般不让用户直接通过 dlopen 函数加载动态链接库，而是封装了以下两种加载 so 库的方式（实际上第二种最终也是需要通过  libName 找到具体的 so 文件路径，再通过文件路径加载 so 库，与第一种方式殊途同归）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：通过 so 文件路径加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(String filename)</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().load0(VMStack.getStackClass1(), filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式二：通过 so 库名加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span><span class="params">(String libname)</span> </span>&#123;</span><br><span class="line">        Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们是通过 <code>方式二</code> 以 <code>System.loadLibrary(&quot;xxx&quot;)</code> 的方式来加载 so 文件 <code>libxxx.so</code>，而将 so 文件动态化之后，我们需要将 so 文件安装到内部安全路径，在通过 <code>方式一</code> 以 <code>System.load(&quot;{安全路径}/libxxx.so&quot;)</code> 的方式来加载。这种方案是大部分 so 动态化项目采用的方案，一直以来也都能稳定工作，不过我们也在这个方案里发现了不少麻烦。</p><p>采用 <code>方式一</code> 作为 so 动态化的方案，意味着代码里要写死 <code>System.load(&quot;{安全路径}/libxxx.so&quot;)</code> 。这样一来，首先我们在代码调节阶段就蛋疼了，Native 代码在开发阶段完全可以用传统的内置方案进行调试，在集成阶段再按动态化的方案打包，这也就意味着我们必须频繁地在 <code>方式一</code> 和 <code>方式二</code> 直接来回修改，代码侵入性问题非常严重。然而这还不是最麻烦的问题，对于第三方的 SDK 项目的动态化问题，如果 SDK 项目本身的 so 库是以 <code>方式二</code> 的方式加载（正常的开发方式，对于一些自身就带有 so 文件下载逻辑的 SDK 项目，则很可能是以 <code>方式一</code> 加载的，这种情况下反而问题不大），则可能需要借助 ASM 这种“曲线救国”的方式来把 SDK 项目里 so 加载的相关代码修改成 <code>方式一</code>；或者选择在准备好 so 插件之后立即以 <code>方式一</code> 把插件里的所有 so 文件加载进宿主，这样可以兜住插件里 <code>方式二</code> 的加载代码（如果目标 so 库已经加载过一次，则 <code>方式二</code> 加载代码变成一个空实现）。</p><p>解决 so 动态化的 System#load 代码侵入问题，要借鉴 Android 热修复技术方案的思路：按 <code>方式二</code>，即通过 <code>System#loadLibrary(&quot;xxx&quot; )</code> 加载 so 库， Android Framework 会遍历当前上下文的 ClassLoader 实例里的 <a href="https://cs.android.com/android/platform/superproject/+/master:libcore/dalvik/src/main/java/dalvik/system/DexPathList.java;bpv=1;bpt=1;l=80" target="_blank" rel="noopener">nativeLibraryDirectories</a> 数组，在数组里所有的文件路径下查找文件名为 <code>libxxx.so</code> 的文件，所以我们的解决思路就是在安装好 so 插件之后，将其所在的内部安全路径注入到这个 nativeLibraryDirectories 数组里，即可实现通过 <code>方式二</code> 加载。（思路虽然简单清晰，不过 <strong>在实际应用中还是有不少问题</strong>，以来在具体的解决方案中进行详细说明。）</p><p>具体注入代码实现可以参考一下 <a href="https://github.com/Tencent/tinker/blob/dev/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java" target="_blank" rel="noopener">TinkerLoadLibrary#installNativeLibraryPath(ClassLoader, File)</a>。以下篇幅 <strong>对 so 动态化的方案和具体技术细节给出我们的分析和答案</strong>。</p><h2 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h2><h3 id="1-系统加载-so-库的工作流程"><a href="#1-系统加载-so-库的工作流程" class="headerlink" title="1. 系统加载 so 库的工作流程"></a>1. 系统加载 so 库的工作流程</h3><p>当我们调用 <code>System#loadLibrary(&quot;xxx&quot; )</code> 后，Android Framework 都干了些了啥？</p><p>简单来说，Android 的 so 加载流程，大致可以分为以下四个环节：</p><ol><li>PMS install：安装 APK 包的时候，PackageManagerService 根据当前设备的 abi 信息，从 APK 包里拷贝相应的 so 文件。</li><li>Native classpath：启动 APP 的时候， Android Framework 创建应用的 ClassLoader 实例，并将当前应用相关的所有 so 文件所在目录注入到当前 ClassLoader 相关字段。</li><li>so loading：调用 System.loadLibrary(“xxx”)， Android Framework 从当前上下文 ClassLoader 实例（或者用户指定）的目录数组里查找并加载名为 libxxx.so 的文件。</li><li>jni calling：调用 so 相关 JNI 方法。</li></ol><p>大致流程示意图如下：</p><p><img src="/assets/so_loading_flow_ee66c324_0375_41c9_a9d4_3643769fc9e9_untitled.png" alt="so loading flow"></p><p>具体流程以及方法调用链这里不做深入讨论，有兴趣这里推荐老罗的 <a href="https://blog.csdn.net/luoshengyang/article/details/8923483" target="_blank" rel="noopener">Dalvik虚拟机JNI方法的注册过程分析</a> 一文。根据这个流程以及上面提到的“加载代码侵入问题”，按照 <code>System.loadLibrary(&quot;xxx&quot;)</code> 加载代码和 JNI 方法相关类（以下统称 JNI 代码）所在的 ClassLoader 实例不同，so 动态化技术可以分为“JNI 代码隔离”和“JNI 代码内置”两种解决方案。</p><h3 id="2-JNI-代码隔离方案"><a href="#2-JNI-代码隔离方案" class="headerlink" title="2. JNI 代码隔离方案"></a>2. JNI 代码隔离方案</h3><p><img src="/assets/jni_separated_diagram_a2bb6b5e_bddc_4b24_849b_a353b653fe90_untitled.png" alt="jni-separated diagram"></p><p>顾名思义，就是将涉及到的 JNI 代码拆解到一个独立的模块，一同打包进 so 插件包里。运行时动态加载 so 库的时候，先给 so 插件创建一个插件 ClassLoader，在插件 ClassLoader 内部执行“so loading”和“jni calling”。代码隔离方案的优点是是能够做到插件模块编译隔离，其他模块的代码无法 Reference 插件里面的相关 JNI 方法，不容易干扰 JNI 调用的生命周期，后续维护成本低（这也是一般的插件化方案需要做到的目标）。同时缺点也是非常明显的：根据项目历史包袱的具体情况，<strong>模块拆解成本可能比动态化改造的收益还大</strong>。因此，代码隔离方案比较适合新增的 Native 模块，一开始就奔着动态化、延迟加载的方向去。</p><h3 id="3-JNI-代码内置方案"><a href="#3-JNI-代码内置方案" class="headerlink" title="3. JNI 代码内置方案"></a>3. JNI 代码内置方案</h3><p><img src="/assets/jni_builtin_diagram_737587da_0307_42d4_a466_7ba877043376_untitled.png" alt="jni-builtin diagram"></p><p>考虑到拆解 JNI 模块的技术成本，可以考虑先单独把 so 文件单独打包进插件包，JNI 代码保留在宿主代码内部，so 插件共用宿主的 ClassLoader 实例，“so loading”和“jni calling”依旧保留在宿主内部执行。这种“偷懒”的 JNI 代码内置方案相对于隔离方案来说改造难度要小得多，相应地由于没有把代码拆解干净，非常容易造成代码污染问题，后续维护成本大。考虑到时间成本，我相信大部分项目只能选择 JNI 代码内置方案。毕竟代码污染问题，可以通过 Code Review、Lint 静态检查等方式来加强“代码准入”门槛，缓解问题。</p><p>这里需要特别强调的是，相比于代码隔离方案，JNI 代码内置方案有个特有的技术问题不得不解决：向 <code>nativeLibraryDirectories</code> 注入 so 插件路径带来的 <strong>集合并发修改</strong> 问题。由于 nativeLibraryDirectories 的具体实现是一个 ArrayList 实例，其元素读写操作自身是不保证线程安全的，而我们在 Worker 线程加载 so 插件的环节最后需要将新的 so 文件路径注入到 ArrayList 集合里，如果这时候刚好有另一个线程因为执行“so loading”操作而正在遍历集合元素，则会抛出 ConcurrentModificationException（ArrayList 内部实现）。</p><p>解决并发修改问题的思路有两种：</p><blockquote><p>给“so loading”和“ so 文件路径注入”这两种操作同时上锁，锁的实例是 so 相关的 ClassLoader 实例。在所有“so loading”操作之前（比如冷启动初始化环节）就预先注入预留好的 so 文件路径。</p></blockquote><p>思路 1 比较简单合理，不过加锁的操作需要“侵入”其他所有相关的 <code>System.loadLibrary(&quot;xxx&quot;)</code> 调用，同样容易造成代码污染问题；而思路 2 总感觉有点违反程序设计的一般原则（有些 so 插件可能基本用不上，犯不着在一开始就把其路径注入进来），具体取舍要看项目实际情况。作为补充，思路 1 可以再优化一下：为了避免加锁操作带来的代码污染，可以绕个弯子在编译阶段通过 ASM 手段给自动给所有“so loading”上锁；或者在往 ClassLoader 注入路径的时候，不要在原有的 nativeLibraryDirectories 集合上做修改，而是重新 new 一个 List 实例把所有的路径都拷贝到新集合上，最后再整体塞回去 ClassLoader，避免并发修改异常，代价是允许出现并发读脏数据问题（不至于崩溃）。</p><p>我们这两个思路都有尝试，实际投产用的是思路 2，除了污染问题之外，主要是因为下面谈到的“<strong>dlopen 问题</strong>”。</p><h3 id="4-处理-dlopen-问题"><a href="#4-处理-dlopen-问题" class="headerlink" title="4. 处理 dlopen 问题"></a>4. 处理 dlopen 问题</h3><p><code>dlopen</code> 是 Native 开发比较熟悉的一个函数，其功能是以指定模式加载指定的动态链接库（使用 dlclose 来卸载打开的库）。实际上，Android Framework 加载 so 库的 <code>System.loadLibrary(&quot;xxx&quot;)</code> 调用，最后也是通过 <code>dlopen</code>  来实现 ，大致的调用路径如下：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sysytem#loadLibrary --&gt; Sysytem#load --&gt; Runtime#nativeLoad</span><br><span class="line">                                           Java  +</span><br><span class="line">                                                 |  Native</span><br><span class="line">                                          dvmLoadNativeCode --&gt; dlopen</span><br></pre></td></tr></table></figure><p>在 NDK 开发中，如果我们有两个 so 文件：<a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 和 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a>（后者是基础库，前者需要依赖后者的 API），xxx 需要动态链接 log，具体体现在 CMake 配置如下：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET_LINK_LIBRARIES(xxx liblog.so)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>则当我们调用 <code>System.loadLibrary(&quot;xxx&quot;)</code> 的时候，Android Framework 会通过上面提到的调用链最终通过 dlopen 加载 <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 文件，并接着通过其依赖信息，自动使用 dlopen 加载 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a>（第二步没有返回 System#load，而是直接在 Native 层面执行）。对于熟悉 Native 开发的同学来说可能司空见惯，但对于只在第三方 SDK 里接触过 so 文件的同学来说，应该不太知道着这一点。然而恰恰正是这一点，给 so 动态化添加了非常大的困难，也让我们在具体的实践项目中吃了很大的亏。</p><p>根据项目经验，现在无论是插件化技术，或者是热修复技术，里面关于动态加载 so 文件的技术方案应该相当成熟，所有的坑都踩得七七八八，就算有没有解决的坑，那应该也不不会严重到影响项目方案可行性的地步。所以一开始，我们把动态化方案主要的风险评估放在模块代码拆解方面，而完全没有担心技术风险。实际上，在 Android N 以前，只要你将 <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 和 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 所在的文件目录路径都注入到当前 ClassLoader 的 nativeLibraryDirectories 里，则在加载 so 插件的时候，这两个文件都能正常被找到。而从 N 开始情况就不一样了： <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 能正常加载，而 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 会出现加载失败错误。具体异常如下：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E/ExceptionHandler: Uncaught Exception java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;liblog.so&quot; not found</span><br><span class="line">at java.lang.Runtime.loadLibrary0(Runtime.java:xxx)</span><br><span class="line">at java.lang.System.loadLibrary(System.java:xxx)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其主要原因是，Android Native 用来链接 so 库的 <a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker.h;bpv=1;bpt=1;l=96?gsn=do_dlopen" target="_blank" rel="noopener">Linker.cpp dlopen 函数</a> 的具体实现变化比较大（主要是引入了 <strong>Namespace 机制</strong>）：以往的实现里，Linker 会在 ClassLoder 实例的 nativeLibraryDirectories 里的所有路径查找相应的 so 文件；更新之后，Linker 里检索的路径在创建 ClassLoader 实例后就被系统通过 Namespace 机制绑定了，当我们注入新的路径之后，虽然 ClassLoader 里的路径增加了，但是 Linker 里 Namespace 已经绑定的路径集合并没有同步更新，所以出现了 <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 文件能找到，而 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 找不到的情况。</p><p>至于 Namespace 机制的工作原理了，可以简单认为是一个以 ClassLoader 实例 HashCode 为 Key 的 Map，Native 层通过 ClassLoader 实例获取 Map 里存放的 Value（也就是 so 文件路径集合），具体代码可以参考 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/ClassLoaderFactory.java;bpv=1;bpt=1;l=111?gsn=createClassLoader" target="_blank" rel="noopener">ClassLoaderFactory#createClassLoader()</a>。</p><p>我之前琢磨着，Tinker 之所以一直没有把 dlopen 问题暴露出来，主要是因为 Tinker 是热修复框架，补丁插件里需要的  <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 文件，往往在宿主里本来就有内置一份，所以只会导致热修复部分失效，而不会出现 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 找不到问题。而实际上好巧不巧，Tinker 在解决 Android N 的混合编译带来的热修复失败问题时，在往 ClassLoader 注入插件 so 文件路径的时候，会创建一个新的 AndroidNClassLoader 实例用来替换 APP 自身的 ClassLoader，这个替换的操作刚好一并兜住了 dlopen 问题。至于其他插件化框架里为何没有提到这个问题，大概是因为一般适合动态化改造的插件都比较轻量，一般不会有 Native 代码（就算有也往往没有 so 依赖）。</p><p>解决 dlopen 问题主要有以下几个思路：</p><blockquote><p>自定义 System#load，加载 libxxx.so 前，先解析 libxxx.so 的依赖信息，再递归加载其依赖的 so 文件（推荐参考开源方案 SoLoader）。自定义 Linker，完全自己控制 so 文件的检索逻辑（推荐参考开源方案 ReLinker）。类似 Tinker，在合适的时机替换 ClassLoader 实例（这是我们现在投产的方案）。</p></blockquote><h3 id="5-so-依赖分析工具"><a href="#5-so-依赖分析工具" class="headerlink" title="5. so 依赖分析工具"></a>5. so 依赖分析工具</h3><p>上面提到的都是 so 动态化方案中的具体技术难题，剩下的都是一些繁琐的项目问题了（技术债务），比如上面提到的 so 依赖分析。想要把 so 动态化技术应用到 APK 的瘦身项目中来，除了分析哪些 so 文件体积占比比较大之外，最好的做法是将其依赖的所有 so 文件一定挪到插件包里。怎么了解 APK 里所有 so 文件具体的依赖信息呢？根据 so 文件模型手撸代码解析依赖信息固然可行，不过那都是大神干的活，吾等平凡之辈还是选择站在巨人的肩膀上。</p><p>这里推荐一款 Google 开源的 APK 解析工具 <a href="https://github.com/google/android-classyshark" target="_blank" rel="noopener">android-classyshark</a>，除了提供分析 APK dex/so 依赖信息之外，它还提供了 GUI 可视化界面，非常适合快速上手。</p><p><img src="/assets/so_deps_screenshot_a3f75364_3ae6_42e5_9f9f_8e9c375f4ed6_untitled.png" alt="so deps screenshot"></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="相关-JNI-类污染问题"><a href="#相关-JNI-类污染问题" class="headerlink" title="相关 JNI 类污染问题"></a>相关 JNI 类污染问题</h3><p>JNI 方法需要在加载完成相应的 so 库才能正常调用，所以有不少开发选择将 <code>System#loadLibrary(&quot;xxx&quot; )</code> 之类的代码写在 JNI 类的静态代码块，以保证在访问 JNI 之前一定会先完成 so 库加载。不过这实际上非常不“Best Practice”：一方面，加载 so 原本就属于一种动态化技术，其自身就存在失败的可能性，而且 Native 开发在 Android 上一直存在诸多“疑难杂症”（推荐参考一下这篇文章 <a href="https://medium.com/keepsafe-engineering/the-perils-of-loading-native-libraries-on-android-befa49dce2db" target="_blank" rel="noopener">The Perils of Loading Native Libraries on Android</a>），最好的办法是考虑所有 so 加载和 JNI 方法调用失败的可能性；另一方面，加载 so 文件本身就有些许性能损耗，在静态代码块中加载会加剧性能问题。最麻烦的是，so 动态化改造之后，如果项目后续开发中有人不小心在 so 插件尚未安装完成之前引用了相关的 JNI 类（比如访问静态方法），哪怕没有发生实际的方法调用，也会导致 JNI 类提前被 ClassLoader 加载，进而提前触发 <code>System#loadLibrary(&quot;xxx&quot; )</code> 逻辑，触发 Crash。</p><p>对于项目已有的 JNI 代码，如果存在“静态代码块加载 so 问题”，则在改造成动态化的时候，最好将相关加载代码挪出静态代码块，并且增加 so 加载失败时候的 onFail 逻辑，确保所有 so 加载和 JNI 方法调用都不会出现崩溃问题。</p><h3 id="代码后续维护成本"><a href="#代码后续维护成本" class="headerlink" title="代码后续维护成本"></a>代码后续维护成本</h3><p>这也是我目前比较头疼的问题，由于采用了“JNI 代码内置方案”，没有对 JNI 代码进行编译隔离，非常容易导致后续代码维护过程中，在不正确的生命周期里访问了动态化 so 相关的 JNI 方法，增加 Crash 的风险。</p><p>按照以往的动态化项目经验，“比较稳定，代码变化不大，模块边界比较内聚”的业务比较适合动态化改造，所以 so 动态化应该优选则这种类型的模块，无论是改造成“JNI 代码隔离方案”，还是后续的维护成本，都相对要小许多。对于那些代码耦合比较严重，版本迭代非常活跃的业务模块，这是一个典型的“在高速行驶的火车上更换引擎”的问题：在动态化改造的同时，FT 代码还在并行迭代，势必会产生许多冲突；对于耦合比较严重的代码，考虑投入产出比的话一般都会选择“JNI 代码内置”方案，没有对 JNI 代码进行编译隔离，所以非常容易导致 Crash；改造完成后，后续 FT 代码变动频繁，后续代码维护压力大，而且可能是。</p><p>目前我觉得比较靠谱的处理方案是从项目管理流程上找突破点，主要方向最好还是让 FT 开发自己负责自己模块的动态化改造工作，降低维护成本（考虑到业务团队跟质量团队之间绩效目标的冲突，可能难以推动）。同时需要尽量根据项目的实际需要完善动态化框架以及相关配到的知道文档，降低 FT 的接入成本。作为辅助，还需要给容易产生代码冲突的地方加上相应的静态检查 Case，以便及时发现问题。</p><h3 id="持续集成、部署问题（CI-CD）"><a href="#持续集成、部署问题（CI-CD）" class="headerlink" title="持续集成、部署问题（CI/CD）"></a>持续集成、部署问题（CI/CD）</h3><p>踩了上面一系列的坑，眼看着动态化技术方案完善得七七八八了，实际上 <strong>我们才刚刚开始而已</strong>！</p><p>首先，怎么编译出 so 插件包也是个技术活，这一点要根据具体的项目情况选择合适的方案（我们选用的是 Gradle 插件在 PackageApplication 阶段抽取目标资源文件）。这个是一个 CI 问题，换句话说就是我们需要一个稳定灵活的流水线，用于稳定编译我们指定版本的 so 插件包，而不是每次都通过非常手工、笨拙的方式编包。其次，插件包编译之后，不应该通过手工的方式把文件上传到后端，在填写相关的版本、依赖等配置信息。这是一个 CD 问题（Continuous Deployment），我们应该采用自动化的手段（哪怕只是脚本），在集成阶段之后收集需要的配置信息，自动上传到一个内部环境的管理平台（平台上我们可以查看每个版本的数据），在 Test/Release 阶段根据需要将指定版本的配置信息“一键导入”到测试、预发布环境，每个环节上都要尽量避免人工操作。</p><p>因此，从工程管理的角度来看，一个完备的动态化方案，必须涵盖集成、部署、加载框架三个流程的内容，而前面的两点是大多数动态化项目或者技术文章没有提及到的，往往容易被忽视。</p><h3 id="Play-Store-动态代码禁用问题"><a href="#Play-Store-动态代码禁用问题" class="headerlink" title="Play Store 动态代码禁用问题"></a>Play Store 动态代码禁用问题</h3><p>由于一些总所周知的原因，包含有动态代码的 APK 包是无法上传到 Play Store 的。不过实际上 Google 不是禁止动态代码，而是禁止绕过 Play 渠道下发未进过审核的动态代码。经过咨询，通过 Play 提供的 <a href="https://developer.android.com/google/play/expansion-files" target="_blank" rel="noopener">APK 拓展资源包 Expansion Files</a> 服务，可以向客户端下发相关插件资源包，没有政策风险（该服务主要是面向游戏客户端，可以想 APK 客户端下发绑定版本的“一个主资源包 + 一个 patch 包”，体积上限个 1G。需要说明的是，用户发布特定版本的 APK 之前必须先绑定资源包，一旦发布就无法修改）。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>本文主要是根据我自身实际投产的 Android 动态化项目经验（SDK 插件、动态组件化）以及最近相关的 so 动态化实践，分享一些动态加载 so 库时需要考虑的问题。内容主要包括插件化方案的共同问题、abi 兼容性问题、代码侵入性问题、并发修改问题，以及最重要也最容易忽视的 dlopen 问题。千言万语汇成一句话：</p><blockquote><p>插件有风险，投资须谨慎！</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems/">使用 SO 库时要注意的一些问题</a></li><li><a href="http://kaedea.com/2016/07/10/android-dynamical-loading-08-satrt-frontia/">设计一个框架化框架</a></li><li><a href="https://github.com/kaedea/android-dynamical-loading/tree/develop/android-frontia" target="_blank" rel="noopener">Android Frontia</a></li><li><a href="https://blog.csdn.net/luoshengyang/article/details/8923483" target="_blank" rel="noopener">Dalvik虚拟机JNI方法的注册过程分析</a></li><li><a href="https://blog.hike.in/reduce-the-size-of-your-app-by-moving-so-files-to-over-the-air-b51ca9dfdaf2" target="_blank" rel="noopener">Reduce the size of your app by moving .SO files to over-the-air</a></li></ol><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 动态下发 so 库在 Android APK 安装包瘦身方面的应用Date = 2018-06-04Published = trueCategory = AndroidTag = ['动态加载', '插件化', 'so 库']FileLocate = FileName = android-so-loading-2hexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知 Android 加载 so 文件本身就是一种运行时动态加载可执行代码的行为，所以把 so 做成动态下发的没有什么技术风险，不过要把这项技术稳定落地到实际生产项目中还是有不少麻烦的问题。本文根据实际项目经验，分享一些 so 动态化关键技术点和需要避免的坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="so 库" scheme="http://kaedea.com/tags/so-%E5%BA%93/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>增量静态检查（SPA）在代码合入检查里的应用</title>
    <link href="http://kaedea.com/2018/04/01/devops/incremental-spa/"/>
    <id>http://kaedea.com/2018/04/01/devops/incremental-spa/</id>
    <published>2018-04-01T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<!-- draftAndroid静态代码扫描效率优化与实践 - 美团[https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA](https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA)1. 背景2. 思考3. 实践4. 结果5. 沉淀6. 总结文章源代码计划：1. 高亮2. 多渠道3. 注释--><p>静态程序分析，是指在不运行程序的情况下分析检查代码里存在的问题。这项技术在代码质量、漏洞扫描等领域有广泛的使用。常见分析工具包括 CheckStyle、Lint、FindBugs 等，也有商用的 Coverity。本文主要讲述为我们在 Android 项目 Merge Request 合入检查里对静态程序分析技术的应用，核心内容是增量代码的静态分析方案，至于各种检查工具的对比筛选，请参考文末提供的 References。</p><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol><li>静态程序分析：SPA (Static Program Analysis)，也称静态代码检查、静态扫描、静态检查等（下文统称 “静态检查”）</li><li>代码合入检查：泛指代码提交进主干分支前的一些列检查流程，比较有代表性的是 GitHub PR (Pull Request) 或者 GitLab MR (Merge Request) 合并前进行自动化检查流水线、或者 Code Review 工作（下文统称 “静态检查”，指 MR 合并前的代码检查）</li></ol><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><!-- draft - 提高代码质量 - 为 CodeReview 提供支撑 - 效率 - 历史包袱--><p>微信相关 Android 项目的 DevOps 实践中，我们在合入检查方向已经先后完成了 “需求合法性检查”、“代码冲突检查”、“编译检查”、“编译后 WeTest 自动化 UI 测试” 等检查项目，代码合入检查流程已经比较完善。接下来，我们想尝试在检查流程里加入静态检查环节，看看能不能在 “统一代码风格、提高代码质量” 方面实现一些突破。</p><p>传统上，代码风格检查普遍比较依赖于人工的 Code Review，而 DevOps 实践给我们的经验是，代码格式、一般向代码错误等问题交给工具自动化处理比较合适，人工 Review 的主要目的应该是项目方案评审，以及优秀代码学习，不然的话 Code Review 很可能会变成政治任务，流于形式。因此，我们希望借助静态检查工具，先过滤大部分的一般代码问题，再交由人工进行代码设计方面的 Review 或者学习（注意，本文侧重于静态检查工具的使用，至于具体 Code Review 标准、流程请参考其他文献）。</p><p>静态检查对 Code Review 起到一个支撑作用：</p><blockquote><p>先由静态检查工具过滤常见的错误，工具无法判断的问题可以给出先 warning log，人工 Review 再根据静态检查的 log，重点排查可疑代码。</p></blockquote><p>不过实际应用上，静态检查工具的接入还是存在许多麻烦的问题，特别是对于一些比较成熟、历史包袱严重的项目。一方面，我们相信有不少人已经尝试过使用一些静态检查工具，这些工具在一些小项目上，经常一下子就能跑出一大堆问题，而对于比较庞大的项目，扫描出太多问题基本相当于扫描不出问题，所以我们不得不想办法让检查工具专注于我们关心的问题。另一方面，一般的静态检查工具的分析过程都比较耗时，少则几分钟，一些需要依赖编译产物的工具耗时可能达到十几分钟（类似 Coverity 这种商业功能需要依赖多维度的数据作为数据流分析的依据，耗时更是可能达到小时的级别），这种量级的时间要求对合入检查流程来说是不可接受的，特别是封版前这种时间十分紧迫的版本阶段，更不用说我们的最终目标是希望在用户本地开发代码阶段就把检查流程添加进来，因此在这个流程上我们需要对静态检查工具的性能提一个非常高的要求。</p><p>总结一下问题，现在摆在我们面的主要有 “两个矛盾”：</p><ol><li>静态检查通常会检查出大量的 “陈年老代码” 带来的历史遗留问题，而这些问题大部分没人维护，也不能随意修改；而合入检查则要求只检查出新增代码带来的新问题。</li><li>静态检查耗时普遍比较 “可观”，越是要求检查精准，越是需要更多耗时；而静态检查则要求越快越好。</li></ol><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><!-- draft - 代码差分算法 - CheckStyle/Lint 增量方案 - 增量报告方案--><h3 id="1-如何让静态检查工具只检查出新增部分代码带来的问题"><a href="#1-如何让静态检查工具只检查出新增部分代码带来的问题" class="headerlink" title="1. 如何让静态检查工具只检查出新增部分代码带来的问题"></a>1. 如何让静态检查工具只检查出新增部分代码带来的问题</h3><p>介绍我们的方案之前，先说一说两个使用得比较普遍的方案：其一，根据代码提交的时间（例如 git 工具就可以检查每一行代码最近的时间），约定一个起始点时间（比如上一个稳定版本）作为 baseline，静态检查工具检查出来的问题，其对应的代码提交记录如果早于这个 baseline 则自动忽略该问题，这样就能从一大堆问题里面筛选出比较 “新鲜” 的问题。其二，选一个稳定版本作为 baseversion，扫描出这个版本所有的问题并把结果记录下来，以后每次静态扫描都和前面 baseversion 保留的记录做比对，屏蔽存量问题（或者直接编写脚本，根据 baseversion 扫描出来的结果，给全部存量问题自动加上 suppression 注释以便后续静态检查在扫描阶段就屏蔽问题）。</p><p>公司内部部分静态扫描服务使用的就是以上两个方案之一（比如 CodeCC 使用的是 baseversion 方案），这样做的好是思路清晰接入点也简单，几乎对于所有的静态检查工具都可以使用这些方案，也不用担心静态检查工具版本升级带来的兼容性问题。不过缺点也是显而易见的，首先是依然要重复检查老问题，白白浪费资源，而且有些新问题结果表现可能和老问题一样，导致这些问题会被当成老问题忽视。</p><p>再来说说我们现在使用的方案：DevOps 实践中，我们需要计算出用户改了哪些代码或文件（也就是用户提交的 “增量代码”），用来检查用户的行为是否合法（比如改了不允许修改的问题，或者动了别人的代码需要 @owner 过来 Review），因此我们首先想到的是可以直接利用这些增量代码，在静态检查结果中匹配出增量代码带来的问题，这样虽然无法一下解决检查效率的问题，但是也能保证匹配出来的问题大概率是和用户改动的代码相关的。再做进一步思考，既然我们已经得到代码的增量数据，我们是不是可以直接对这部分增量的代码做静态检查？这样既不用重复检查那一大堆成年老问题，也可以直接暴露出增量代码带来的问题。答案是肯定的，我们最终采取了这两种方式结合的思路：</p><blockquote><p>直接对增量代码做检查得到一批问题报告，再从中匹配出增量代码带来的问题。</p></blockquote><h3 id="2-如何提高静态检查的效率"><a href="#2-如何提高静态检查的效率" class="headerlink" title="2. 如何提高静态检查的效率"></a>2. 如何提高静态检查的效率</h3><p>静态检查的效率，一方面跟扫描的文件数量相关，另一方面也受工具自身扫描算法、扫描内容、检测规则的粒度、规则的数量等影响。想要提高效率，一方面我们需要尽量减少输入的文件数，而我们上面提到的增量检查思路刚好把这个方面的问题做到最优解。另一方面，至于扫描算法，自己开发更加高效的检查工具显然不太现实，所以我们把目光放到扫描内容和检测规则，好在现在主流的静态检查工具，其检查规则甚至检查粒度，大都支持用户自定义。简单地说，针对源码类型做扫描的工具比如 CheckStyle 和 Lint，需要经过词法分析、语法分析生成抽象语法树，再遍历抽象语法树跟定义的检测规则去匹配，其工作效率会比较高；而像针对 .class 字节码文件做扫描的工具 FindBugs，需要先编译源码成 .class 文件，再通过 BCEL 分析字节码指令并与探测器规则匹配，效率就会大打折扣（Lint 也支持这种检查方式，这里不做展开）。除了以上谈到的两点外，像 Android 这种 Gradle 项目，如果项目 Module 比较多，Gradle Configure 阶段也会需要比较多的耗时。</p><p>实际上，第一个问题的解决思路，已经给现在这个问题指明了一个方向：针对增量代码做检查，既减少输入文件，又降低需要执行检查任务的 Module 数。万事俱备，接下来的事就是选用合适的静态检查工具了。</p><p>对于我们的项目，目标是 “统一代码风格、提高代码质量”。统一风格方面，CheckStyle 当仁不让， 它支持直接对代码源文件进行扫描，并且内置许多成熟的 Style Guides/Conventions 方案（比如 Google/Sun/Oracle），而且自定义规则也非常简单，完全可以自定义自己的代码格式和变量命名规则。剩下的就是如何提高代码质量，我们选用的是 Lint，理由非常简单，Lint 是 Android 官方深度定制工具，和 Android 项目相性最好，功能极其强大，且可定制性和扩展性以及全面性都表现均超乎我们期待。平时编写代码过程中，Android Stuido 智能标注的各种红色（Error）、黄色（Warning）警告，大部分都是 Lint 检查的结果（所以有事没事推荐大家多按 F2 试试，自动跳到下一处 Lint 检查出问题的地方）。除了跟 IDE/Gradle 插件相结合得很好之外，Lint 也像 CheckStyle 一样，支持直接对代码源文件、甚至 XML 资源文件进行检查，不需要计算依赖或者 API References，效率比较理想。而且 Lint 自定义检查规则的功能也非常强大，几乎覆盖对大部分 Java 代码、XML 资源格式的检查。</p><p>我们的整体方案是：</p><ol><li>计算增量代码。</li><li>以增量代码涉及的源文件作为输入（粒度是文件），给项目相关 Module 配置相应的 CheckStyle 和 Lint 任务。</li><li>运行检查任务，根据预置的检查规则进行扫描，得到检查结果。</li><li>从检查结果中筛选出和增量代码相关的问题（粒度是文件修改行数）</li></ol><h2 id="具体方案实现"><a href="#具体方案实现" class="headerlink" title="具体方案实现"></a><strong>具体</strong>方案<strong>实现</strong></h2><!-- draft - 本地增量代码计算 - Lint 增量--><h3 id="1-通过-git-计算增量代码的信息"><a href="#1-通过-git-计算增量代码的信息" class="headerlink" title="1. 通过 git 计算增量代码的信息"></a><strong>1. 通过 git 计算</strong>增量<strong>代码的信息</strong></h3><p>在计算代码增量信息方面，我们需要解决以下几个问题：</p><ol><li>需要计算本地修改代码的增量信息，在体检代码前检查一下有没有新增问题。</li><li>需要计算提交 MR 时，开发分支与主干分支之间代码的增量信息，用于检查 MR 带来的新增问题。</li><li>当用户 MR 检查出问题后在本地修改代码，我们需要计算出 “开发分支与主干分支之间代码的增量信息” 叠加 “用户新修改问题带来的增量信息” 后的最终结果，以便用户检查自己是否已把问题修复。</li></ol><p>我们计算代码增量信息的方案，全靠 <code>git diff</code> 命令：</p><p><img src="/assets/man_git_diff_img_git_diff.png" alt="man: git diff"></p><p>这里先简单介绍一下我们方案需要用到的这几个参数的作用：</p><ol><li><code>name-only</code>：只显示修改文件的名字，不显示内容，这个参数分别刚好满足上面提到的方案的 “文件粒度” 和“文件修改行数粒度”。</li><li><code>-cached</code>：只显示被 staged 过的文件（也就是已经被 add 到 git index 里），计算本地修改代码的时候，需要通过这个参数计算 “已 staged” 和“未 staged”两种文件的综合数据。</li><li><code>-diff-filter=ACMR</code>： 显示哪类文件：Added (A)、Copied (C)、 Modified (M)、Renamed (R)，具体配置请参看官方文档。</li><li><code>-ignore-space-at-eol</code>: 忽略行尾空格或者换行符等修改信息，这里额外说明一下，MR 计算代码修改信息用的也是 git diff 工具而且默认不带这个参数，而 IDEA 的 Annotate 默认是带这个参数的，所以有时候会看到有人提交 MR 显示修改了大量代码（比如批量代码格式化导致修改文件换行符），而当事人本地 IDEA 又看不出自己改了代码。</li><li><code>M100%</code>：这是一个阈值，用来计算前后两个不同名字的文件，内容相似度达到哪个百分比就认为这是一个被 Renamed (R) 的文件。</li></ol><p>关于参数解释，这里推荐一个工具 <a href="https://explainshell.com/explain?cmd=git+diff+--name-only+--cached+--diff-filter%3DACMR+--ignore-space-at-eol+-M100%25" target="_blank" rel="noopener">explainshell.com</a>，不在赘述。现在回答上面提到的几个问题。</p><p>对第一个问题，通过 <code>git diff --diff-filter=ACMR --ignore-space-at-eol -M100%</code> 和 <code>git diff --cached --diff-filter=ACMR --ignore-space-at-eol -M100%</code> 两个命令组合起来，可以综合计算出本地变动代码的增量信息。至于第二个问题，可以先通过 <code>git merge-base &lt;main_branch_revision&gt; HEAD</code> 计算出当前分支跟主干分支之间的共同节点 merge_base_revision，再通过 <code>git diff &lt;merge_base_revision&gt; HEAD</code>，就可以计算出当前开发分支从主干分支拉出来之后的代码变动情况。</p><p>这个方案里最难也最容易被忽略的是第三个问题，不像第一个问题里只要分别计算 staged 和 unstaged 两种文件再加起来就完事了，这里的本地的修改数据不是简单的叠加问题：用户修改了个文件 X，代码提交后，开发分支和主干之间就有一份确定的文件 X 的修改信息 A，这时候用户在本地继续修改文件 X，那本地修改记录里文件 X 也有另一份修改信息 B，这时候 B 跟 A 的修改信息是完全冲突的，我们要的是用户修改文件后本地文件最终状态跟主干之间的代码差异 C，而 A 跟 B 都是错误的信息，而且很明显 C ≠ A + B。</p><p>为了解决第三个问题，我们前后设计了两套方案：</p><ol><li>计算增量信息的时候，先 <code>git add -A &amp;&amp; git commit</code> 自动提交本地修改代码，然后计算 <code>git merge-base &lt;main_branch_revision&gt; HEAD</code>，最后 <code>git reset --soft HEAD~1</code> 把自动提交撤销掉。更详细的操作，还可以先计算修改文件哪些是 staged 的，reset 之后需要把 staged 状态恢复，全面还原文件状态。</li><li>依次计算修改信息 A 和修改信息 B，遍历修改信息 B 的每一行文件修改内容，然后一次拓扑更新 A 的内容，直到遍历完全 B，这时候拓扑后的 A 就是目标的信息 C 了。</li></ol><p>方案 1 的好处就是逻辑清晰，但是提交和撤销动作涉及本地文件修改，容易出现文件修改冲突破坏现场。方案 2 逻辑和算法都比 1 要复杂得多，好在经过几次迭代后我们证明这个路子是可行，现在稳定投产中。</p><p>作为补充说明，<code>git diff</code> 命令输出的格式不太适合直接参与后面的计算工作，需要先转换成程序友好的格式（比如 JSON），这里推荐一款基于 Python 的 git diff 解析工具：<a href="https://github.com/nathforge/gitdiffparser" target="_blank" rel="noopener">git-diff-parser</a>。项目中我们采用的是 Gradle 插件，所以也用 Groovy 实现了类似的解析工作。假设我们修改了 <code>MainActivity.java</code> 文件，新增了 <code>basepacks.txt</code> 文件，<code>git diff</code> 解析前格式是：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/app/src/main/java/com/example/app/MainActivity.java b/app/src/main/java/com/example/app/MainActivity.java</span><br><span class="line">index d3151dd..80ba56b 100644</span><br><span class="line">--- a/app/src/main/java/com/example/app/MainActivity.java</span><br><span class="line">+++ b/app/src/main/java/com/example/app/MainActivity.java</span><br><span class="line">@@ -7,6 +7,8 @@ import android.widget.Toast;</span><br><span class="line"></span><br><span class="line"> import com.jianghongkui.customelint.R;</span><br><span class="line"></span><br><span class="line">+import java.io.IOException;</span><br><span class="line">+</span><br><span class="line"> public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">@@ -15,11 +17,26 @@ public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">         setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-         Toast.makeText(this, &quot;&quot;, 20);</span><br><span class="line">-         assert true;</span><br><span class="line">+        Toast.makeText(this, &quot;&quot;, 20);</span><br><span class="line">+        assert true;</span><br><span class="line">+        String hello = &quot;hello&quot;;</span><br><span class="line">+        System.out.println(hello);</span><br><span class="line">+        Integer.parseInt(&quot;2&quot;);</span><br><span class="line">+        Float.parseFloat(&quot;2&quot;);</span><br><span class="line">+        System.loadLibrary(&quot;hello&quot;);</span><br><span class="line">+        try &#123;</span><br><span class="line">+            getAssets().open(&quot;hello&quot;);</span><br><span class="line">+        &#125; catch (IOException e) &#123;</span><br><span class="line">+            e.printStackTrace();</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        foo(&quot;hello2&quot;);</span><br><span class="line">+        foo(&quot;libandromeda&quot;);</span><br><span class="line">+        System.out.println(&quot;libflutter&quot;);</span><br><span class="line">+        System.out.println(&quot;libflutter_v7.so&quot;);</span><br><span class="line">+    &#125;</span><br><span class="line"></span><br><span class="line">-         System.out.println(&quot;hello&quot;);</span><br><span class="line">-         Integer.parseInt(&quot;2&quot;);</span><br><span class="line">-         Float.parseFloat(&quot;2&quot;);</span><br><span class="line">+    private void foo(String str) &#123;</span><br><span class="line">+        System.loadLibrary(str);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a/add.txt b/add.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..9b07058</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/add.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+asad</span><br><span class="line">+asdasd</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>经过解析之后变成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"app/src/main/java/com/example/app/MainActivity.java"</span>,</span><br><span class="line">        <span class="attr">"changed_lines"</span>: [</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">11</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">21</span>,</span><br><span class="line">            <span class="number">22</span>,</span><br><span class="line">            <span class="number">23</span>,</span><br><span class="line">            <span class="number">24</span>,</span><br><span class="line">            <span class="number">25</span>,</span><br><span class="line">            <span class="number">26</span>,</span><br><span class="line">            <span class="number">27</span>,</span><br><span class="line">            <span class="number">28</span>,</span><br><span class="line">            <span class="number">29</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            <span class="number">31</span>,</span><br><span class="line">            <span class="number">32</span>,</span><br><span class="line">            <span class="number">33</span>,</span><br><span class="line">            <span class="number">34</span>,</span><br><span class="line">            <span class="number">35</span>,</span><br><span class="line">            <span class="number">36</span>,</span><br><span class="line">            <span class="number">37</span>,</span><br><span class="line">            <span class="number">39</span>,</span><br><span class="line">            <span class="number">40</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"deleted_lines"</span>: [</span><br><span class="line">            <span class="number">18</span>,</span><br><span class="line">            <span class="number">19</span>,</span><br><span class="line">            <span class="number">21</span>,</span><br><span class="line">            <span class="number">22</span>,</span><br><span class="line">            <span class="number">23</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"is_new_file"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"add.txt"</span>,</span><br><span class="line">        <span class="attr">"changed_lines"</span>: [</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"deleted_lines"</span>: [],</span><br><span class="line">        <span class="attr">"is_new_file"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>具体代码请参考文末提供的代码仓库。</p><h3 id="2-基于-AGP-插件的-Lint-增量检查方案"><a href="#2-基于-AGP-插件的-Lint-增量检查方案" class="headerlink" title="2. 基于 AGP 插件的 Lint 增量检查方案"></a>2. 基于 AGP 插件的 Lint 增量检查方案</h3><!-- draft1. Android Studio 自带的 lint 检查流程2. 如何实现增量检查3. 如何实现自定义检查规则4. 一些需要注意的点--><p>在增量检查的具体实现上，我们采用的是自定义 Gradle 插件，增加了 <code>:checkIncremental</code> 任务来执行增量的检查任务。其中 CheckStyle 检查的实现是基于 Gradle Api 提供相关 Checkstyle Task，这个本身就支持增量检查，直接配置输入文件就好。Lint 的增量检查就要复杂得多，主要是基于 Android 官方的 AGP (Android Gradle Plugin) 插件提供的 <code>com.android.tools.lint:lint-gradle</code> 库进行实现，以下介绍几个关键的技术点。</p><h4 id="Lint-检查的工作流程"><a href="#Lint-检查的工作流程" class="headerlink" title="Lint 检查的工作流程"></a>Lint 检查的工作流程</h4><p>Android Lint 的工作过程比较简单，由一个基础的 Lint 过程由 Lint Tool（检测工具），Source Files（项目源文件） 和 lint.xml（配置文件） 三个部分组成：Lint Tool 读取 Source Files，根据 lint.xml 配置的规则（issue）输出结果，如下图：</p><p><img src="/assets/lint_gong_zuo_liu_cheng_shi_yi_tu_image_lint_workflow.png" alt="Lint 工作流程示意图"></p><p>Android 项目中，一般我们有三种方式运行 Lint 检查：命令行、IDEA 的 Inspections 检查功能、Gradle Lint 任务，他们都由 <a href="http://tools.android.com/tips/lint" target="_blank" rel="noopener">AGP Android Lint</a> 提供，并由 Android 官方进行维护，虽然检查入口各不相同，但是底层都是同一套 Lint API 实现（提供 Lint 检查实现的 lint-api.jar 和封装好一些常用检查规则的 lint-check.jar，三种工作方式都是基于这两个类库实现）。</p><p>届于 Lint API 涉及的类库比较复杂，这里不做深入讨论，主要介绍一下几个比较关键的 API：</p><ol><li><code>LintDriver</code>: 三种工作方式最后都通过 LintDriver#analyse() 执行实际上的检查工作。</li><li><code>IssueRegistry</code>：管理 Lint 检查规则，配合 lint.xml 使用。Android 有内置的 BuiltinIssueRegistry，用户自定义检查的话，需要重写该类。</li><li><code>LintRequest</code>：执行 Lint 检查时的一个请求类，封装好了需要检查的文件内容，我们需要实现的增量检查，也是要从这里下手。</li><li><code>LintClient</code>：Lint 客户端，集成 Lint 检查的操作、配置，对应某一种具体的工作方式，比如 LintCliClient 对应命令行方式，LintIdeClient 对应 IDEA 的 Inspections，LintGradleClient 对应 Gradle Lint Task。</li></ol><p>用伪代码表示的话大概是：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> registry = <span class="keyword">new</span> IssueRegistry()</span><br><span class="line"><span class="keyword">def</span> client = <span class="keyword">new</span> LintClient(registry) &#123;</span><br><span class="line">    override createLintRequest(file) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LintRequest(file)</span><br><span class="line">    &#125;</span><br><span class="line">    override run() &#123;</span><br><span class="line">        LintDriver.analyze()  <span class="comment">// super impl</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure><h4 id="Lint-自定义检查规则"><a href="#Lint-自定义检查规则" class="headerlink" title="Lint 自定义检查规则"></a><strong>Lint 自</strong>定义<strong>检查规则</strong></h4><p>自定义检查规则，就是要自定义各种检查 Detector 类，具体可以参考官方的指导文档 <a href="http://tools.android.com/tips/lint/writing-a-lint-check" target="_blank" rel="noopener">Writing a Lint Check</a> 或者美团的几篇 Lint 实践文章 <a href="https://tech.meituan.com/tags/lint.html" target="_blank" rel="noopener">美团 Lint</a>。老实说，这方面官方给出的 Example 并不是很详细，具体怎么写还是要靠自己去看官方 Lint API 的源码，以及参考别人的开源代码（如果你比较熟悉 Visitor 访问者模式，或者写过 ASM 插件，应该比较容易上手）。</p><p>这里给出一个我们自己自定义的检查规则作参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 Log 的使用规范</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogIssue</span> <span class="keyword">extends</span> <span class="title">Detector</span> <span class="keyword">implements</span> <span class="title">Detector</span>.<span class="title">UastScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Issue ISSUE = Issue.create(</span><br><span class="line">            <span class="string">"WxLog"</span>,</span><br><span class="line">            <span class="string">"Log 使用不规范, 请使用 platformtools.Log"</span>,</span><br><span class="line">            <span class="string">"请使用项目共用的Log函数, 输出console及xlog文件请使用platformtools.Log, 不希望输出xlog文件请使用android.util.Log"</span>,</span><br><span class="line">            Category.CORRECTNESS,</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">            Severity.ERROR,</span><br><span class="line">            <span class="keyword">new</span> Implementation(LogIssue<span class="class">.<span class="keyword">class</span>, <span class="title">Scope</span>.<span class="title">JAVA_FILE_SCOPE</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethod</span><span class="params">(@NotNull JavaContext context, @NotNull UCallExpression node, @NotNull PsiMethod method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.getEvaluator().isMemberInClass(method, <span class="string">"java.io.PrintStream"</span>)) &#123;</span><br><span class="line">            context.report(ISSUE, context.getLocation(node), ISSUE.getBriefDescription(TextFormat.TEXT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getApplicableMethodNames</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">"print"</span>, <span class="string">"println"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lint-增量检查的实现方案"><a href="#Lint-增量检查的实现方案" class="headerlink" title="Lint 增量检查的实现方案"></a>Lint 增量检查的实现方案</h4><p>上面提到，“我们需要实现的增量检查，需要从 LintRequest 下手”，通过重写 LintClient 中的 createLintRequest 方法，传入我们需要增量检查的文件，以下给出关键的代码，具体的实现细节，请参考我们的代码库。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LintToolClient</span> <span class="keyword">extends</span> <span class="title">LintCliClient</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> LintRequest createLintRequest(List&lt;File&gt; files) &#123;</span><br><span class="line">        LintRequest request = <span class="keyword">super</span>.createLintRequest(files)</span><br><span class="line">        <span class="keyword">for</span> (Project <span class="string">project :</span> request.getProjects()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File <span class="string">file :</span> files) &#123;</span><br><span class="line">                project.addFile(file) <span class="comment">// 具体需要检查的文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LintRequest(<span class="keyword">this</span>, files)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到有三种 Lint 的工作方式，我们采用的是扩展第三种 Lint Gradle 方式（因为这种方式能直接复用现成的 lint.xml 配置文件和 Lint Output 报告格式），最终整体的工作流程是：</p><ol><li>通过 git diff 获得需要检查文件作为 Source Files。</li><li>根据自己的检查需要自定义 LintIssueRegistry（增加了一批自定义的 Detector，考虑的性能需要，移除了那些需要依赖编译产物的内置 Detectors）。</li><li>自定义继承 LintGradleClient 的 LintIncrementalClient（也就是采用 Lint Gradle 工作方式）。</li><li>根据 Source Files，为每一个有文件变动的 Module 创建增量检查用的 Gradle Task；运行检查任务的时候，执行 LintIncrementalClient#run() 实现增量检查</li></ol><p>除了我们采用的第三种 Lint Gradle 方式，这里补充说明一下第二种 IDEA 的 Inspections 功能：通过 “IDEA - Analyse - Inspect Code” 可以迅速针对一个指定的文件做 Lint 检查。如下：</p><p><img src="/assets/idea_inspect_code_image_idea_inspect_code.png" alt="IDEA Inspect Code"></p><p>经过挖掘，我们发现其实现的关键代码在 <a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/lint/LintIdeClient.java" target="_blank" rel="noopener">LintIdeClient.java</a>。通过 Inspections 方案，我们能直接对指定文件进行 Lint 检查，而不需要依赖于 Gradle 环境，这是 Lint 增量检查的最佳方案。不过考虑到 IDEA 版本之间的兼容性问题，而且我们还需要将检查工作合入到 DevOps 自动化流程里，所以最终还是选择了 Gradle Lint 方案。</p><p>最后，关于具体的 Lint 实现有一点需要补充说明：Lint API 25 到 26 之间，无论是 API 接口还是具体的实现，变化都非常大，所以各位参考别人的具体实现代码的时候，一定要先分清当前的 API 版本是多少。</p><h3 id="3-整体工作流程图"><a href="#3-整体工作流程图" class="headerlink" title="3. 整体工作流程图"></a>3<strong>. 整体</strong>工作<strong>流程图</strong></h3><p>没有流程图的方案是没有灵魂的，如下：</p><p><img src="/assets/workflow_image_workflows.png" alt="workflow"></p><h2 id="结果沉淀"><a href="#结果沉淀" class="headerlink" title="结果沉淀"></a>结果沉淀</h2><!-- draft - 检查结果展示 - Incrementals - 专利 - 检查时间--><p>以代码仓库的 Demo 项目为例，如果执行一遍默认的 <code>:app:clean :app:lint</code> 检查任务，耗时 Configure + 检查任务整体耗时大概在 10s 左右，如下：</p><p><img src="/assets/app_clean_app_lint_time_consumed_image_demo_1.png" alt=":app:clean :app:lint time consumed"></p><p>接入增量 Lint 方案后，耗时已经能压缩到 1s 左右：</p><p>![<a href="/assets/app_clean_app_checklint_time_consumed_image_demo_1.png">:app:clean :app:checkLint time consumed</a></p><p>即使加上增量的 CheckStyle 检查任务，再最终补上一个用来做检查结果报告的 <code>checkReport</code> 任务，整体增量检查耗时也能稳定在 1s：</p><p><img src="/assets/checkincremental_time_consumde_image_demo_1.png" alt=":checkIncremental time consumde"></p><p>在实际项目 MR 合入检查流水线里的应用效果如下：</p><p><img src="/assets/mr_he_ru_jian_cha_pipelines_1579101129_18.png" alt="MR 合入检查 Pipelines"></p><p><img src="/assets/mr_dai_ma_zeng_liang_jian_cha_jie_guo_1579101164_53.png" alt="MR 代码增量检查结果"></p><p>在 MR 代码合入检查的静态检查环节上，我们目前一共实现了 CheckStyle、Lint、文件格式（LF/CRLF 换行符问题）、非法文件修改（文件权限）四种检查内容，其中 Lint 增量带来的收益最明显，时间成本从原本的几分钟、十几分钟级别下降到几秒到几十秒的级别（通常只要在封版前涉及大量代码修改的 MR 才需要几十秒的耗时），已经基本满足了我们 DevOps 合入检查的要求（考虑到静态检查环节是我们合入检查几个并行的 Stages 之间耗时最小的一个，可以说相当于没有时间成本）。而且除了时间成本之外，Lint 自定义检查的功能相当于给我们的平台提供了一种定制性比较强的检查工具，比如 Dark Mode 对 XML 的颜色值有使用规范，通过自定义 Detector 可以很轻松得检查每一个新增 XML 文件的 color 属性。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>本文主要以介绍静态检查整体的应用方案为主，以及分享方案落地流程里一些问题，主要是一己的经验之谈。如果你希望了解现有静态检查工具的对比和应用，这方面市场上已经有大量的科普和评测文章请自行检索，如果你希望试用各种检查工具，这里推荐一下公司内部的静态检查服务 CodeCC 和 CodeDog，他们都有详细的使用文档。又或者你想研究 Lint API 具体的工作细节，这里推荐一下美团技术团队编写的几篇 Lint 相关技术文章 <a href="https://tech.meituan.com/tags/lint.html" target="_blank" rel="noopener">美团 Lint</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://tools.android.com/tips/lint" target="_blank" rel="noopener">http://tools.android.com/tips/lint</a> （官方文档）</li><li><a href="https://tech.meituan.com/tags/lint.html" target="_blank" rel="noopener">https://tech.meituan.com/tags/lint.html</a> （美团 Lint 实践）</li><li><a href="https://www.jianshu.com/p/a0f28fbef73f" target="_blank" rel="noopener">https://www.jianshu.com/p/a0f28fbef73f</a> （自定义 Lint 规则）</li><li><a href="https://blog.csdn.net/ouyang_peng/article/details/80374867" target="_blank" rel="noopener">https://blog.csdn.net/ouyang_peng/article/details/80374867</a> （自定义 Lint 规则）</li><li><a href="https://www.jianshu.com/p/4833a79e9396" target="_blank" rel="noopener">https://www.jianshu.com/p/4833a79e9396</a> （增量 Lint 实现）</li><li><a href="https://github.com/lingochamp/okcheck" target="_blank" rel="noopener">https://github.com/lingochamp/okcheck</a> （增量检查，粒度是有代码改动的 Module，一个折中的方案，优点是侵入性小)</li></ol><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 增量静态检查（SPA）在代码合入检查里的应用Date = 2018-04-01Published = trueCategory = DevOpsTag = ['DevOps', 'SPA', '自动化，静态检查']FileLocate = devopsFileName = incremental-spahexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;!-- draft
Android静态代码扫描效率优化与实践 - 美团
[https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA](https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA)
1. 背景
2. 思考
3. 实践
4. 结果
5. 沉淀
6. 总结
文章源代码计划：
1. 高亮
2. 多渠道
3. 注释
--&gt;
&lt;p&gt;静态程序分析，是指在不运行程序的情况下分析检查代码里存在的问题。这项技术在代码质量、漏洞扫描等领域有广泛的使用。常见分析工具包括 CheckStyle、Lint、FindBugs 等，也有商用的 Coverity。本文主要讲述为我们在 Android 项目 Merge Request 合入检查里对静态程序分析技术的应用，核心内容是增量代码的静态分析方案，至于各种检查工具的对比筛选，请参考文末提供的 References。&lt;/p&gt;
    
    </summary>
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="http://kaedea.com/tags/DevOps/"/>
    
      <category term="SPA" scheme="http://kaedea.com/tags/SPA/"/>
    
      <category term="自动化，静态检查" scheme="http://kaedea.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>一种Android应用内全局获取Context实例的装置</title>
    <link href="http://kaedea.com/2017/04/09/android/global-accessing-context/"/>
    <id>http://kaedea.com/2017/04/09/android/global-accessing-context/</id>
    <published>2017-04-09T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.984Z</updated>
    
    <content type="html"><![CDATA[<p>哥白尼·罗斯福·马丁路德·李开复·嫁衣曾经说过</p><blockquote><p>Where there is an Android App, there is an Application context.</p></blockquote><p>没毛病，扎心了。App运行的时候，肯定是存在至少一个Application实例的。同时，Context我们再熟悉不过了，写代码的时候经常需要使用到Context实例，它一般是通过构造方法传递进来，通过方法的形式参数传递进来，或者是通过attach方法传递进我们需要用到的类。Context实在是太重要了，以至于我经常恨不得着藏着掖着，随身带着，这样需要用到的时候就能立刻掏出来用用。但是换个角度想想，既然App运行的时候，Application实例总是存在的，那么为何不设置一个全局可以访问的静态方法用于获取Context实例，这样以来就不需要上面那些繁琐的传递方式。</p><p>说到这里，有的人可能说想这不是我们经常干的好事吗，有必要说的这么玄乎？少侠莫急，请听吾辈徐徐道来。<br><a id="more"></a></p><h2 id="获取Context实例的一般方式"><a href="#获取Context实例的一般方式" class="headerlink" title="获取Context实例的一般方式"></a>获取Context实例的一般方式</h2><p>这再简单不过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo1</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 在构造方法带入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo2 <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 2. 通过attach方法带入return this;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 3. 调用方法的时候，通过形参带入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式应该是最常见的获取Context实例的方式了，优点就是严格按照代码规范来，不用担心兼容性问题；缺点就是API设计严重依赖于Context这个API，如果早期接口设计不严谨，后期代码重构的时候可能很要命。此外还有一个比较有趣的问题，我们经常使用Activity或者Application类的实例作为Context的实例使用，而前者本身又实现了别的接口，比如以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FooActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">FooA</span>, <span class="title">FooB</span>, <span class="title">FooC</span> </span>&#123;</span><br><span class="line">    Foo mFoo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 禁忌·四重存在！</span></span><br><span class="line">        mFoo.foo(<span class="keyword">this</span>, <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Context context, FooA a, FooB b, FooC c)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是我许久前看过的代码，本身不是什么厉害的东西，不过这段代码段我至今印象深刻。设想，如果Foo的接口设计可以不用依赖Context，那么这里至少可以少一个<code>this</code>不是吗。</p><h2 id="获取Context实例的二般方式"><a href="#获取Context实例的二般方式" class="headerlink" title="获取Context实例的二般方式"></a>获取Context实例的二般方式</h2><p>现在许多开发者喜欢设计一个全局可以访问的静态方法，这样以来在设计API的时候，就不需要依赖Context了，代码看起来像是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局获取Context实例的静态方法。</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        sContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在整个项目中，都可以通过<code>Foo#getContext()</code>获取Context实例了。不过目前看起来好像还有点小缺陷，就是使用前需要调用<code>Foo#setContext(Context)</code>方法进行注册（这里暂不讨论静态Context实例带来的问题，这不是本篇幅的关注点）。好吧，以我的聪明才智，很快就想到了优化方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局获取Context实例的静态方法（改进版）。</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FooApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">FooApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样又有带来了另一个问题，一般情况下，我们是把应用的入口程序类<code>FooApplication</code>放在App模块下的，这样一来，Library模块里面代码就访问不到<code>FooApplication#getContext()</code>了。当然把<code>FooApplication</code>下移到基础库里面也是一种办法，不过以我的聪明才智又立刻想到了个好点子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局获取Context实例的静态方法（改进版之再改进）。</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FooApplication</span> <span class="keyword">extends</span> <span class="title">BaseApplication</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基础库里面</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">BaseApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以来，就不用把<code>FooApplication</code>下移到基础库里面，Library模块里面的代码也可以通过<code>BaseApplication#getContext()</code>访问到Context实例了。嗯，这看起来似乎是一种神奇的膜法，因吹斯听。然而，代码写完还没来得及提交，包工头打了个电话来和我说，由于项目接入了第三发SDK，需要把<code>FooApplication</code>继承<code>SdkApplication</code>。<br>……<br>有没有什么办法能让<code>FooApplication</code>同时继承<code>BaseApplication</code>和<code>SdkApplication</code>啊？（场面一度很尴尬，这里省略一万字。）</p><p>以上谈到的，都是以前我们在获取Context实例的时候遇到的一些麻烦：</p><ol><li>类API设计需要依赖Context（这是一种好习惯，我可没说这不好）；</li><li>持有静态的Context实例容易引发的内存泄露问题；</li><li>需要提注册Context实例（或者释放）；</li><li>污染程序的Application类；</li></ol><p>那么，有没有一种方式，能够让我们在整个项目中可以全局访问到Context实例，不要提前注册，不会污染Application类，更加不会引发静态Context实例带来的内存泄露呢？</p><h2 id="一种全局获取Context实例的方式"><a href="#一种全局获取Context实例的方式" class="headerlink" title="一种全局获取Context实例的方式"></a>一种全局获取Context实例的方式</h2><p>回到最开始的话，App运行的时候，肯定存在至少一个Application实例。如果我们能够在系统创建这个实例的时候，获取这个实例的应用，是不是就可以全局获取Context实例了（因为这个实例是运行时一直存在的，所以也就不用担心静态Context实例带来的问题）。那么问题来了，Application实例是什么时候创建的呢？首先先来看看我们经常用来获取Base Context实例的<code>Application#attachBaseContext(Context)</code>方法，它是继承自<code>ContextWrapper#attachBaseContext(Context)</code>的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是谁调用了这个方法呢？可以很快定位到<code>Application#attach(Context)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是谁调用了<code>Application#attach(Context)</code>方法呢？一路下来可以直接定位到<code>Instrumentation#newApplication(Class&lt;?&gt;, Context)</code>方法里（这个方法名很好懂啊，一看就知道是干啥的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for implementing application instrumentation code.  When running</span></span><br><span class="line"><span class="comment"> * with instrumentation turned on, this class will be instantiated for you</span></span><br><span class="line"><span class="comment"> * before any of the application code, allowing you to monitor all of the</span></span><br><span class="line"><span class="comment"> * interaction the system has with the application.  An Instrumentation</span></span><br><span class="line"><span class="comment"> * implementation is described to the system through an AndroidManifest.xml's</span></span><br><span class="line"><span class="comment"> * &lt;instrumentation&gt;.</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        Application app = (Application)clazz.newInstance();</span><br><span class="line">        app.attach(context);</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来是在这里创建了App的入口Application类实例的，是不是想办法获取到这个实例的应用就可以了？不，还别高兴太早。我们可以把Application实例当做Context实例使用，是因为它持有了一个Context实例（base），实际上Application实例都是通过代理调用这个base实例的接口完成相应的Context工作的。在上面的代码中，可以看到系统创建了Application实例app后，通过<code>app.attach(context)</code>把context实例设置给了app。直觉告诉我们，应该进一步关注这个context实例是怎么创建的，可以定位到<code>LoadedApk#makeApplication(boolean, Instrumentation)</code>代码段里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Local state maintained about a currently loaded .apk.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadedApk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String appClass = mApplicationInfo.className;</span><br><span class="line">        <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        <span class="string">"initializeJavaContextClassLoader"</span>);</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// Context 实例创建的地方，可以看出Context实例是一个ContextImpl。</span></span><br><span class="line">            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">            app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里我们定位到了Application实例和Context实例创建的位置，不过距离我们的目标只成功了一半。因为如果我们要想办法获取这些实例，就得先知道这些实例被保存在什么地方。上面的代码一路逆向追踪过来，好像也没看见实例被保存给成员变量或者静态变量，所以暂时还得继续往上捋。很快就能捋到<code>ActivityThread#performLaunchActivity(ActivityClientRecord, Intent)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This manages the execution of the main thread in an</span></span><br><span class="line"><span class="comment"> * application process, scheduling and executing activities,</span></span><br><span class="line"><span class="comment"> * broadcasts, and other operations on it as the activity</span></span><br><span class="line"><span class="comment"> * manager requests.</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">        ComponentName component = r.intent.getComponent();</span><br><span class="line">        Activity activity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建Application实例。</span></span><br><span class="line">            Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            r.paused = <span class="keyword">true</span>;</span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是我们启动Activity的时候，Activity实例创建的具体位置，以上代码段还可以看到喜闻乐见的”Unable to start activity”异常，你们猜猜这个异常是谁抛出来的？这里就不发散了，回到我们的问题来，以上代码段获取了一个Application实例，但是并没有保持住，看起来这里的Application实例就像是一个临时变量。没办法，再看看其他地方吧。接着找到<code>ActivityThread#handleCreateService(CreateServiceData)</code>，不过这里也一样，并没有把获取的Application实例保存起来，这样我们就没有办法获取到这个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Don't set application object here -- if the system crashes,// we can't display an alert, we just want to die die die.</span></span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">                ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                        <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">                mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                mInitialApplication.onCreate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">systemMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里创建Application实例后，把实例保存在ActivityThread的成员变量<code>mInitialApplication</code>中。不过仔细一看，只有当<code>system == true</code>的时候（也就是系统应用）才会走这个逻辑，所以这里的代码也不是我们要找的。不过，这里给我们一个提示，如果能想办法获取到ActivityThread实例，或许就能直接拿到我们要的Application实例。此外，这里还把ActivityThread的实例赋值给一个静态变量<code>sCurrentActivityThread</code>，静态变量正是我们获取系统隐藏API实例的切入点，所以如果我们能确定ActivityThread的<code>mInitialApplication</code>正是我们要找的Application实例的话，那就大功告成了。继续查找到<code>ActivityThread#handleBindApplication(AppBindData)</code>，光从名字我们就能猜出这个方法是干什么的，直觉告诉我们离目标不远了~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">            mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                    + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这里同样把Application实例保存在ActivityThread的成员变量<code>mInitialApplication</code>中，紧接着我们看看谁是调用了<code>handleBindApplication</code>方法，很快就能定位到<code>ActivityThread.H#handleMessage(Message)</code>里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                    <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInitialApplication.onTerminate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Looper.myLooper().quit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bingo！至此一切都清晰了，<code>ActivityThread#mInitialApplication</code>确实就是我们需要找的Application实例。整个流程捋顺下来，系统创建Base Context实例、Application实例，以及把Base Context实例attach到Application内部的流程大致可以归纳为以下调用顺序。</p><blockquote><p>ActivityThread#bindApplication (异步) –&gt; ActivityThread#handleBindApplication –&gt; LoadedApk#makeApplication –&gt; Instrumentation#newApplication –&gt; Application#attach –&gt; ContextWrapper#attachBaseContext</p></blockquote><p>源码撸完了，再回到我们一开始的需求来。现在我们要获取ActivityThread的静态成员变量sCurrentActivityThread。阅读源码后我们发现可以通过<code>ActivityThread#currentActivityThread()</code>这个静态方法来获取这个静态对象，然后通过<code>ActivityThread#getApplication()</code>方法就可能直接获取我们需要的Application实例了。啊，这用反射搞起来简直再简单不过了！说搞就搞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applications</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Application <span class="title">context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CURRENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span>(<span class="string">"StaticFieldLeak"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Application CURRENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object activityThread = getActivityThread();</span><br><span class="line">            Object app = activityThread.getClass().getMethod(<span class="string">"getApplication"</span>).invoke(activityThread);</span><br><span class="line">            CURRENT = (Application) app;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not access Application context by magic code, boom!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object activityThread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = Class.forName(<span class="string">"android.app.ActivityThread"</span>).getMethod(<span class="string">"currentActivityThread"</span>);</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            activityThread = method.invoke(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">            Log.w(TAG, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activityThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码@RunWith(AndroidJUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ApplicationTest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetGlobalContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Application context = Applications.context();</span><br><span class="line">        Assert.assertNotNull(context);</span><br><span class="line">        Log.i(TAG, String.valueOf(context));</span><br><span class="line"><span class="comment">// MyApplication是项目的自定义Application类</span></span><br><span class="line">        Assert.assertTrue(context <span class="keyword">instanceof</span> MyApplication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以来， 无论在项目的什么地方，无论是在App模块还是Library模块，都可以通过<code>Applications#context()</code>获取Context实例，而且不需要做任何初始化工作，也不用担心静态Context实例带来的问题，测试代码跑起来没问题，接入项目后也没有发现什么异常，我们简直要上天了。不对，哪里不对。不科学，一般来说不可能这么顺利的，这一定是错觉。果然项目上线没多久后立刻原地爆炸了，在一些机型上，通过<code>Applications#context()</code>获取到的Context恒为null。</p><p>(╯&gt;д&lt;)╯⁽˙³˙⁾ 对嘛，这才科学嘛。</p><p>通过测试发现，在4.1.1系统的机型上，会稳定出现获取结果为null的现象，看来是系统源码的实现上有一些出入导致，总之先看看源码吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是这么一个幺蛾子，在4.1.1系统上，ActivityThread是使用一个ThreadLocal实例来存放静态ActivityThread实例的。至于ThreadLocal是干什么用的这里暂不展开，简单说来，就是系统只有在UI线程使用sThreadLocal来保存静态ActivityThread实例，所以我们只能在UI线程通过sThreadLocal获取到这个保存的实例，在Worker线程sThreadLocal会直接返回空。</p><p>这样以来解决方案也很明朗，只需要在事先现在UI线程触发一次<code>Applications#context()</code>调用保存Application实例即可。不过项目的代码一直在变化，我们很难保证不会有谁不小心触发了一次优先的Worker线程的调用，那就GG了，所以最好在<code>Applications#context()</code>方法里处理，我们只需要确保能在Worker线程获得ActivityThread实例就Okay了。不过一时半会我想不出切确的办法，也找不到适合的切入点，只做了下简单的处理：如果是优先在Worker线程调用，就先使用UI线程的Handler提交一个任务去获取Context实例，Worker线程等待UI线程获取完Context实例，再接着返回这个实例。</p><p>最终完成的代码可以参考 <a href="https://github.com/kaedea/Feya/blob/master/Application/Feya/src/main/java/me/kaede/feya/context/Applications.java" target="_blank" rel="noopener">Applications</a>。</p><p>在这里需要特别强调的时候，通过这样的方法获取Context实例，只要在<code>Application#attachBaseContext(Context)</code>执行之后才能获取到对象，在之前或者之内获取到的对象都是null，具体原因可以参考上面调用流程中的<code>ActivityThread#handleBindApplication</code>。所以，膜法什么的，还是少用为妙吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.1.1_r1/android/app/ActivityThread.java" target="_blank" rel="noopener">ActivityThread.java</a></p><!-- draft著作信息： 本文章出自 [Kaede](http://www.kaedea.com/about) 的博客，原创文章若无特别说明，均遵循 [CC BY-NC 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh) 知识共享许可协议4.0（署名-非商用-相同方式共享），可以随意摘抄转载，但必须标明署名及原地址。--><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 一种Android应用内全局获取Context实例的装置Date = 2017-04-9 00:00:00Published = trueCategory = AndroidTag = ['Android', 'Context', 'Hook']FileLocate = androidFileName = global-accessing-contexthexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哥白尼·罗斯福·马丁路德·李开复·嫁衣曾经说过&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Where there is an Android App, there is an Application context.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没毛病，扎心了。App运行的时候，肯定是存在至少一个Application实例的。同时，Context我们再熟悉不过了，写代码的时候经常需要使用到Context实例，它一般是通过构造方法传递进来，通过方法的形式参数传递进来，或者是通过attach方法传递进我们需要用到的类。Context实在是太重要了，以至于我经常恨不得着藏着掖着，随身带着，这样需要用到的时候就能立刻掏出来用用。但是换个角度想想，既然App运行的时候，Application实例总是存在的，那么为何不设置一个全局可以访问的静态方法用于获取Context实例，这样以来就不需要上面那些繁琐的传递方式。&lt;/p&gt;
&lt;p&gt;说到这里，有的人可能说想这不是我们经常干的好事吗，有必要说的这么玄乎？少侠莫急，请听吾辈徐徐道来。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="Context" scheme="http://kaedea.com/tags/Context/"/>
    
      <category term="Hook" scheme="http://kaedea.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>西方程序员跑得比谁都快</title>
    <link href="http://kaedea.com/2017/03/21/android/naughty-proguard-tuduki/"/>
    <id>http://kaedea.com/2017/03/21/android/naughty-proguard-tuduki/</id>
    <published>2017-03-21T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p>昨天刚刚发表了一篇文章（<a href="http://kaedea.com/2017/03/20/android/naughty-proguard/">ProGuard又搞了个大新闻</a>），主要吐槽的是项目里面使用ProGuard工具导致的一个诡异的坑。其中根本的原因就是，ProGuard混淆Java注解类的时候，把两个方法混淆成同样的名字，导致dx工具在打包<code>.dex</code>文件的时候报错。</p><p>本来以为这件事情算是告一段落了，没想到自己还是太Naive了。今天早上突然收到了ProGuard开发者发来的一份邮件，Exciting！邮件里谈到了这次的坑出现的真正原因 —— Java源码和字节码（bytecode）里方法的重载（OverLoading）。</p><a id="more"></a><h2 id="被雪藏的问题真正原因"><a href="#被雪藏的问题真正原因" class="headerlink" title="被雪藏的问题真正原因"></a>被雪藏的问题真正原因</h2><p>在上一篇文章里，我分析到这次问题的原因是</p><blockquote><p>ProGuard工具在混淆注解类类Route.java的时候，把它的两个字段都混淆成a了，按道理应该是一个a和一个b，不知道是不是ProGuard的BUG，还是Route与其他库冲突了。</p></blockquote><p>本来我以为是ProGuard的BUG，把注解类的两个字段都混淆成一样的名字，或者是ProGuard受到别的库的影响才出现了这个BUG。显然，在Java代码里面，是不允许有两个名字相同且形参一样的方法的，哪怕是它们的返回值不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] foo() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"wor"</span>, <span class="string">"ld"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是无法重载的，IDE会提示错误并且无法编译。虽然现在不少的新编程语言支持这样返回值类型不同的方法重载，但是在Java里行不通，原因也很简单，类似下面的方法立刻就会产生歧义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 无法确定调用的是哪个方法。</span></span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题的原因虽然只是这么简单，但是其实在<code>.class</code>文件的字节码（bytecode）里，这样的重载方法是被允许的。为什么呢？简单点说，在字节码里面，对类的文件结构的描述十分严谨，方法调用必须有指定的返回类型，所以像上面那样的调用是不存在的，自然也就不存在产生歧义的问题。</p><p>假设现在有这样一个正常的类（上面的示例代码的正常版）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] foo1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"wor"</span>, <span class="string">"ld"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        foo1();</span><br><span class="line">        String s = foo2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类编译成<code>.class</code>字节码文件后，它的文件结构大概是这样的。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">+ Program class: com/bilibili/routertest/Hello</span><br><span class="line"> ...</span><br><span class="line">Interfaces (count = 0):</span><br><span class="line">Constant Pool (count = 30):</span><br><span class="line"> ...</span><br><span class="line">Fields (count = 0):</span><br><span class="line"></span><br><span class="line">Methods (count = 4):</span><br><span class="line">  - Method:       &lt;init&gt;()V</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      = public Hello()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  + Method:       foo1()[Ljava/lang/String;</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      = public java.lang.String[] foo1()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  + Method:       foo2()Ljava/lang/String;</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      = public java.lang.String foo2()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  + Method:       main()V</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      = public void main()</span><br><span class="line">    Class member attributes (count = 1):</span><br><span class="line">    + Code attribute instructions (code length = 11, locals = 2, stack = 1):</span><br><span class="line">      [0] aload_0 v0</span><br><span class="line">      [1] invokevirtual#7</span><br><span class="line">        + Methodref [com/bilibili/routertest/Hello.foo1 ()[Ljava/lang/String;]</span><br><span class="line">      [4] pop</span><br><span class="line">      [5] aload_0 v0</span><br><span class="line">      [6] invokevirtual#8</span><br><span class="line">        + Methodref [com/bilibili/routertest/Hello.foo2 ()Ljava/lang/String;]</span><br><span class="line">      [9] astore_1 v1</span><br><span class="line">      [10] return</span><br><span class="line">      Code attribute exceptions (count = 0):</span><br><span class="line">      Code attribute attributes (attribute count = 1):</span><br><span class="line">      + Line number table attribute (count = 3)</span><br><span class="line">        [0] -&gt; line 12</span><br><span class="line">        [5] -&gt; line 13</span><br><span class="line">        [10] -&gt; line 14</span><br><span class="line"></span><br><span class="line">Class file attributes (count = 1):</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>我们重点关心其中的<code>main()V</code>方法，可以清楚的看到，上面的Java源码中，main方法调用了foo1方法，虽然没有处理返回值，但是在字节码文件结构对应的方法里明确地指明了改该方法的的返回值类型是<code>[Ljava/lang/String</code>，区别于foo2方法的<code>Ljava/lang/String</code>。也就是说，字节码里面并不会存在我们上面提到的方法调用的歧义问题，因此可以支持相同形参不同返回值的方法的重载。</p><p>对于这个课题感兴趣的同学可以参考这篇出自Oracle的调研文章：<a href="https://community.oracle.com/docs/DOC-983207" target="_blank" rel="noopener">Return-Type-Based Method Overloading in Java Blog</a>。</p><h2 id="总结一些人参经验"><a href="#总结一些人参经验" class="headerlink" title="总结一些人参经验"></a>总结一些人参经验</h2><p>关于造成该问题原因的一些阐述。</p><ol><li>上一篇文章提到的ProGuard构建问题其实不是ProGuard的BUG，而是Android SDK的dx工具的BUG。</li><li>不是只有在开启MultiDex的时候才会出现这个问题，不开启问题也会存在，这个问题与MultiDex完全没有关系。</li><li>ProGuard混淆的是字节码而不是Java源码，字节码支持相同形参不同返回值的方法的重载，ProGuard为了最大限度压缩代码量，对后者的重载提供了支持。</li><li>不仅注解类，普通的类也会出现类似的问题。</li></ol><p>解决该问题的一些方法。</p><ol><li>如果不开启ProGuard的<code>overloadaggressively</code>功能，ProGuard不会对字节码中相同形参不同返回值的方法进行重载（这个功能默认不开启）。</li><li>尝试将注解类的RetentionPolicy级别降级为SOURCE级别。</li><li>不要让注解类出现相同形参不同返回值不同名字的方法，不然可能被混淆成重载的方法。</li><li>Keep住相应的注解类。</li></ol><p>以下是ProGuard开发者给出的建议。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unfortunately, dx has a bug: it crashes on this overloading. Workarounds:</span><br><span class="line"></span><br><span class="line">- Do not use the option &apos;-overloadaggressively&apos; in your ProGuard configuration.</span><br><span class="line"></span><br><span class="line">- Alternatively, keep the original annotation method names:</span><br><span class="line"></span><br><span class="line">    -keepclassmembernames @interface * &#123; &lt;methods&gt;; &#125;</span><br><span class="line"></span><br><span class="line">The dx tool should then accept the code.</span><br><span class="line"></span><br><span class="line">If it works, you can post this solution in your blog.</span><br></pre></td></tr></table></figure><p>最后，感叹作者的反馈这么迅速。引用作者的一句原话，<code>It&#39;s a fast world!</code>，西方程序员跑的比谁都快。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 西方程序员跑得比谁都快Date = 2017-03-21 00:00:00Published = trueCategory = AndroidTag = ['Android', 'ProGuard', 'Annotation', 'AGP']FileLocate = androidFileName = naughty-proguard-tudukihexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天刚刚发表了一篇文章（&lt;a href=&quot;http://kaedea.com/2017/03/20/android/naughty-proguard/&quot;&gt;ProGuard又搞了个大新闻&lt;/a&gt;），主要吐槽的是项目里面使用ProGuard工具导致的一个诡异的坑。其中根本的原因就是，ProGuard混淆Java注解类的时候，把两个方法混淆成同样的名字，导致dx工具在打包&lt;code&gt;.dex&lt;/code&gt;文件的时候报错。&lt;/p&gt;
&lt;p&gt;本来以为这件事情算是告一段落了，没想到自己还是太Naive了。今天早上突然收到了ProGuard开发者发来的一份邮件，Exciting！邮件里谈到了这次的坑出现的真正原因 —— Java源码和字节码（bytecode）里方法的重载（OverLoading）。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="ProGuard" scheme="http://kaedea.com/tags/ProGuard/"/>
    
      <category term="Annotation" scheme="http://kaedea.com/tags/Annotation/"/>
    
      <category term="AGP" scheme="http://kaedea.com/tags/AGP/"/>
    
  </entry>
  
  <entry>
    <title>ProGuard 又搞了个大新闻</title>
    <link href="http://kaedea.com/2017/03/20/android/naughty-proguard/"/>
    <id>http://kaedea.com/2017/03/20/android/naughty-proguard/</id>
    <published>2017-03-20T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，Android项目经常开启ProGuard功能来混淆代码，一方面可以降低应用被反编译后代码的友善度，增加被逆向的难度，另一方面开可以通过精简Java API的名字来减少代码的总量，从而精简应用编译后的体积。</p><p>ProGuard有个比较坑爹的问题。在开发阶段，我们一般不启用ProGuard，只有在构建Release包的时候才开启。因此，如果有一些API被混淆了会出现BUG，那么在开发阶段我们往往无法察觉BUG，只有在构建发布包的时候才发现，甚至要等发布到线上了才能发现，这种时候解决问题的成本就很大了。<br>不过今天被ProGuard坑的不是混淆API导致的BUG，这货在之前相当长的一段时间里一直相安无事，最近突然又搞了个大新闻，而且问题排查起来相当蹊跷、诡异。</p><a id="more"></a><h2 id="新闻发生时候的背景"><a href="#新闻发生时候的背景" class="headerlink" title="新闻发生时候的背景"></a>新闻发生时候的背景</h2><p>最近在给项目的开发一个模块之间通讯用的路由框架，它需要有一些处理注解的APT功能，大概是长这个样子的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(uri = <span class="string">"action://sing/"</span>, desc = <span class="string">"念两句诗"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PoemAction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能大概是这样的，我先编写一个叫做 <code>PoemAction</code>，它的业务功能主要是帮你念上两句诗。然后客户只需要调用 <code>Router.open(&quot;action://sing/&quot;)</code> 就可以当场念上两句诗，这也是现在一般路由框架的功能。其中的<code>desc</code>没有别的功能，只是为了在生成路由表的时候加上一些注释，说明当前的路由地址是干什么的，看起来像是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoGeneratedRouteTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Route <span class="title">find</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"action://sing/"</span>.equals(uri)) &#123;</span><br><span class="line"><span class="comment">// 念两句诗return PoemActionRoute;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，代码很完美，单元测试和调试阶段都没有发现任何问题，好，合并进develop分支了。搞定收工，我都不禁想赞美自己的才能了，先去栖霞路玩会儿先。半个小时候突然收到了工头 <a href="https://yrom.net/" target="_blank" rel="noopener">Yrom·半仙·灵魂架构师·Wang</a> 的电话，我还以为他也想来玩呢，结果他说不知道谁在项目的代码里下毒，导致构建机上有已经有几十个构建任务失败了。我了个去，我刚刚提交的代码，该不会是我的锅吧，赶紧回来。</p><h2 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h2><p>异常看起来是这样的。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:app:transformClassesWithMultidexlistForRelease&apos;.</span><br><span class="line">&gt; java.lang.UnsupportedOperationException (no error message)</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br></pre></td></tr></table></figure><p>这看起来好像是MultiDex的问题啊，但是没道理Debug构建没问题，而只有Release构建出问题了，<code>transformClassesWithMultidexlistForRelease</code>任务的源码暂时也没有精力去看了，先解决阻塞同事开发的问题要紧。老规矩，使用 <strong>二分定位法</strong> 挨个回滚到develop上面的commit记录，逐个查看是那次提交导致的，结果还真是我的提交导致的。</p><p>难道是开了混淆，导致一些类找不到？但是类找不到只是运行时的异常而已，应该只会在运行APP的时候抛出“ClassNotFoundException”，不应该导致构建失败啊。难道是APT生成的类格式不对，导致Javac在编译该类的时候失败？于是我打开由APT工具生成的<code>AutoGeneratedRouteTable.java</code>类文件瞧瞧，发文件类的格式很完美，没有问题，甚至由于担心是中文引起的问题，我还把“念两句诗”改成“Sing two poems”，问题依旧。</p><p>总之一时半会无法排查出问题所在，还是赶紧解决APK的构建问题，现在因为构建失败的原因，旁边已经有一票同事正在摩拳擦掌准备把我狠狠的批判一番。所以我打算先去掉APT功能，不通过自动生成注册类的方式，而是通过手动代码注册的方式让路由工作，就当我以为事情告一段落的时候，我才发现我还是“too young”啊，构建机给了同样的错误反馈。</p><p>…………<br>……<br>…</p><p>这TM就尴尬了啊，我现在导致构建失败的提交与上一次正常构建的提交之间的差异就是给<code>PeomAction</code>加多了注解而已啊，而且这个注解现在都没有用到了，难道是注解本身的存在就会导致构建失败？</p><p>突然我想起来，注解类本身我是没有加入混淆的，因为代码里没有用反射的反射获取注解，而且我设计注解类本身的目的也只是为了帮我自动生成注册类而已，这些类是编译时生成的，所以不会受到混淆功能的影响。抱着死马当活马医的心态，我把注解里面的<code>desc</code>字段去掉了，万万没想到构建问题居然就解决了，而且就算我开启APT功能，问题还是没有重现，这…… 这与构建出问题的状态的差别只有一段注释的差别啊，没问题的代码看起来是这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoGeneratedRouteTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Route <span class="title">find</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"action://sing/"</span>.equals(uri)) &#123;</span><br><span class="line">            (这里的注释没有了)</span><br><span class="line">            <span class="keyword">return</span> PoemActionRoute;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这难道是真实存在的某种膜法在干扰我的构建过程？突然我又想起来，因为注解类本身不需要写什么代码，所以我创建<code>Route.java</code>这个类后基本就没有对它进行过编辑了，我甚至已经忘了我对它写过什么代码，所以我决定看看是不是我写错了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Route &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解类看起来再普通不过，一般写完之后也不需要再怎么修改了，而且这个类我是直接参(co)考(py)另外一个优秀的Java APT项目 <a href="https://github.com/airbnb/DeepLinkDispatch" target="_blank" rel="noopener">DeepLinkDispatch</a> 的，想必也不会有什么大坑。目前看起来唯一有更改可能性的地方就是<code>Target</code>和<code>Retention</code>这两个属性，至于这俩的作用不属于此文章的范畴，不做展开。</p><p>首先，<strong>我试着把**</strong><code>Retention</code><strong> <strong>的级别由原来的</strong></strong><code>CLASS</code><strong> <strong>改成</strong></strong><code>SOURCE</code><strong> <strong>级别，没想到就这么一个小改动，编译居然通过了！如果不修改</strong></strong><code>Retention</code><strong> <strong>的级别，把注解里的</strong></strong><code>desc</code><strong> <strong>字段移除，只保留一个</strong></strong><code>value</code><strong> </strong>字段，问题也能解决，真是神奇啊**，顿时我好像感受到了一股来自古老东方的神秘力量。</p><p>在我一直以来的认知里，<code>RetentionPolicy.SOURCE</code>是源码级别的注解，比如<code>@Override</code>、<code>@WorkerThread</code>、<code>@VisibleForTest</code>等这些注解类，这类的注解一般是配合IDE工作的，不会给代码造成任何实际影响，IDE会获取这些注解，并向你提示哪些代码可能有问题，在编译阶段这类注解加与不加没有任何实际的影响。看一下源码的解释吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此，<code>RetentionPolicy.CLASS</code>级别的注解会被保留到<code>.class</code>文件里，所以混淆的时候，注解类也会参与混淆，大概是混淆的时候出的问题吧。总之，先看看注解类<code>Route.java</code>被混淆后变成什么样子，查看 <code>build/output/release/mapping.txt</code> 文件。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">moe.studio.router.Route -&gt; bl.buu:</span><br><span class="line">    java.lang.String[] value() -&gt; a</span><br><span class="line">    java.lang.String desc() -&gt; a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>果然不出我所料，<strong>ProGuard工具在混淆注解类类**</strong><code>Route.java</code><strong> <strong>的时候，把它的两个字段都混淆成</strong></strong><code>a</code><strong> </strong>了**（按道理应该是一个a和一个b，不知道是不是ProGuard的BUG，还是Route与其他库冲突了）。</p><p>所以，最后的解决方案就是把<code>Retention</code>的级别由原来的<code>CLASS</code>降级成<code>SOURCE</code>，或者把注解类的字段改成一个。顺便一说，现在大多的Java APT项目用的还是<code>CLASS</code>，它们之所以没有遇到类似的问题，大多是因为他们都选择把整个注解类都KEEP住，不进行混淆了。</p><h2 id="一些姿势"><a href="#一些姿势" class="headerlink" title="一些姿势"></a>一些姿势</h2><p>通过这个事件我也发现了不少问题。其一，无论单元测试写得再完美，集成进项目之前还是有必要进行一次Release构建，以确保避免一些平时开发的时候容易忽略的问题，不然小心自己打自己的脸。以下是一次打脸现场。</p><p><img src="/assets/28777207_file_1489980325292_11b0a.png" alt></p><p>所以我决定，给项目的构建机加上一次 <strong>Daily Building</strong> 的功能，每天都定期构建一次，以便尽早发现问题。</p><p>其二，除了构建的问题之外，年轻人果然还是要多多学习，<strong>提高一下自己的知识水平</strong>。设想，如果我的Java基础够扎实的话，也就不会像这次一样，犯下<code>RetentionPolicy</code>错用这样低级的错误。如果有仔细阅读过 <code>transformClassesWithMultidexlistForRelease</code> 任务以及ProGuard工具的的源码的话，也许能很快定位到问题发生的根本原因，从而釜底抽薪一举解决问题，不像这次一样，阻塞一大半天开发进度。</p><p>以下放出这次定位问题的大致过程。<br>① 先定位 <code>transformClassesWithMultidexlistForRelease</code> 任务的源码。通过任务名字，可以很快地定位到 <code>MultiDexTransform.java</code> 这个类里面来，以下是这个类在执行任务时候做的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(@NonNull TransformInvocation invocation)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// Re-direct the output to appropriate log levels, just like the official ProGuard task.</span></span><br><span class="line">        LoggingManager loggingManager = invocation.getContext().getLogging();</span><br><span class="line">        loggingManager.captureStandardOutput(LogLevel.INFO);</span><br><span class="line">        loggingManager.captureStandardError(LogLevel.WARN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File input = verifyInputs(invocation.getReferencedInputs());</span><br><span class="line">            shrinkWithProguard(input);</span><br><span class="line">            computeList(input);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException | ProcessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，MultiDexTransform的主要工作是在<code>shrinkWithProguard</code>和<code>computeList</code>两个方法里面完成的。其中<code>shrinkWithProguard</code>的工作可以定位到ProGuard工具的<code>ProGuard#execute</code>方法里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(VERSION);</span><br><span class="line"></span><br><span class="line">    GPL.check();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.dump != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以定位到ProGuard最后执行的<code>dump()</code>方法里面，该方法生成了一个<code>dump.txt</code>文件，里面用文本的形式，记录了整个项目用到的所有类（混淆后的）的文件结构。查看任务的LOG信息以及<code>dump.txt</code>文件的内容，发现所有内容都正常生成，因此可以初步确定问题不是由于<code>shrinkWithProguard</code>引起的。</p><p>接着看看<code>computeList</code>方法，这个方法可以定位到以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">createMainDexList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull File allClassesJarFile,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull File jarOfRoots,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull EnumSet&lt;MainDexListOption&gt; options)</span> <span class="keyword">throws</span> ProcessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">    ProcessInfoBuilder builder = <span class="keyword">new</span> ProcessInfoBuilder();</span><br><span class="line"></span><br><span class="line">    String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX_JAR);</span><br><span class="line">    <span class="keyword">if</span> (dx == <span class="keyword">null</span> || !<span class="keyword">new</span> File(dx).isFile()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"dx.jar is missing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.setClasspath(dx);</span><br><span class="line">    builder.setMain(<span class="string">"com.android.multidex.ClassReferenceListBuilder"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.contains(MainDexListOption.DISABLE_ANNOTATION_RESOLUTION_WORKAROUND)) &#123;</span><br><span class="line">        builder.addArgs(<span class="string">"--disable-annotation-resolution-workaround"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.addArgs(jarOfRoots.getAbsolutePath());</span><br><span class="line">    builder.addArgs(allClassesJarFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    CachedProcessOutputHandler processOutputHandler = <span class="keyword">new</span> CachedProcessOutputHandler();</span><br><span class="line"></span><br><span class="line">    mJavaProcessExecutor.execute(builder.createJavaProcess(), processOutputHandler)</span><br><span class="line">            .rethrowFailure()</span><br><span class="line">            .assertNormalExitValue();</span><br><span class="line"></span><br><span class="line">    LineCollector lineCollector = <span class="keyword">new</span> LineCollector();</span><br><span class="line">    processOutputHandler.getProcessOutput().processStandardOutputLines(lineCollector);</span><br><span class="line">    <span class="keyword">return</span> ImmutableSet.copyOf(lineCollector.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，这里调用了Android SDK里面的<code>dx.jar</code>工具，入口类是 <code>com.android.multidex.ClassReferenceListBuilder</code>，并传入了两个参数，分别是<code>jarOfRoots</code>文件和<code>allClassesJarFile</code>文件。</p><p>② 定位到<code>dx.jar</code>工具里具体出问题的地方，通过上面的分析以及构建失败输出的LOG，可以看到Gradle插件调用了<code>dx.jar</code>并传入了<code>build/intermediates/multi-dex/release/componentClasses.jar</code>和<code>build/intermediates/transforms/proguard/release/jars/3/1f/main.jar</code>两个文件。直接调用该命令试试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.android.dx.cf.iface.ParseException: name already added: string&#123;<span class="string">"a"</span>&#125;</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.parse(AttributeListParser.java:<span class="number">156</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.parseIfNecessary(AttributeListParser.java:<span class="number">115</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.getList(AttributeListParser.java:<span class="number">106</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.parse0(DirectClassFile.java:<span class="number">558</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.parse(DirectClassFile.java:<span class="number">406</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.parseToEndIfNecessary(DirectClassFile.java:<span class="number">397</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.getAttributes(DirectClassFile.java:<span class="number">311</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.hasRuntimeVisibleAnnotation(MainDexListBuilder.java:<span class="number">191</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.keepAnnotated(MainDexListBuilder.java:<span class="number">167</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.&lt;init&gt;(MainDexListBuilder.java:<span class="number">121</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.main(MainDexListBuilder.java:<span class="number">91</span>)</span><br><span class="line">        at com.android.multidex.ClassReferenceListBuilder.main(ClassReferenceListBuilder.java:<span class="number">58</span>)</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: name already added: string&#123;<span class="string">"a"</span>&#125;</span><br><span class="line">        at com.android.dx.rop.annotation.Annotation.add(Annotation.java:<span class="number">208</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AnnotationParser.parseAnnotation(AnnotationParser.java:<span class="number">264</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AnnotationParser.parseAnnotations(AnnotationParser.java:<span class="number">223</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AnnotationParser.parseAnnotationAttribute(AnnotationParser.java:<span class="number">152</span>)</span><br><span class="line">        at com.android.dx.cf.direct.StdAttributeFactory.runtimeInvisibleAnnotations(StdAttributeFactory.java:<span class="number">616</span>)</span><br><span class="line">        at com.android.dx.cf.direct.StdAttributeFactory.parse0(StdAttributeFactory.java:<span class="number">93</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeFactory.parse(AttributeFactory.java:<span class="number">96</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.parse(AttributeListParser.java:<span class="number">142</span>)</span><br><span class="line">        ... <span class="number">11</span> more</span><br></pre></td></tr></table></figure><p>从异常的堆栈可以直接看出，dx工具在执行<code>AnnotationParser#parseAnnotation</code>方法的时候出错了，原因是有两个相同的字段<code>a</code>，这也刚好印证了上面<code>mapping.txt</code>文件里面的错误信息。</p><p>③ 最后定位到源码里具体出问题的地方，查看dx工具里的<code>com.android.dx.rop.annotation.Annotation.java</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;CstString, NameValuePair&gt; elements;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add an element to the set of (name, value) pairs for this instance.</span></span><br><span class="line"><span class="comment">     * It is an error to call this method if there is a preexisting element</span></span><br><span class="line"><span class="comment">     * with the same name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair &#123;<span class="doctag">@code</span> non-null;&#125; the (name, value) pair to add to this instance</span></span><br><span class="line"><span class="comment">     */</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(NameValuePair pair)</span> </span>&#123;</span><br><span class="line">        throwIfImmutable();</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"pair == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CstString name = pair.getName();</span><br><span class="line">        <span class="keyword">if</span> (elements.get(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name already added: "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        elements.put(name, pair);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到此，<strong>从成功定位到产生异常的具体地方</strong>。</p><p>④ 此外，从<code>:app:assembleRelease --debug --stacktrace</code>的异常堆栈里是无法直接看出具体出异常的地方的错误信息的，不过可以通过<code>:app:assembleRelease --full-stacktrace</code>命令输出更多的错误堆栈，从而直观地看出一些猫腻来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.android.ide.common.process.ProcessException: Error <span class="keyword">while</span> executing java process with main <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">multidex</span>.<span class="title">ClassReferenceListBuilder</span> <span class="title">with</span> <span class="title">arguments</span> </span>&#123;build/intermediates/multi-dex/release/componentClasses.jar build/intermediates/transforms/proguard/release/jars/<span class="number">3</span>/<span class="number">1f</span>/main.jar&#125;</span><br><span class="line">        at com.android.build.gradle.internal.process.GradleProcessResult.buildProcessException(GradleProcessResult.java:<span class="number">74</span>)</span><br><span class="line">        at com.android.build.gradle.internal.process.GradleProcessResult.assertNormalExitValue(GradleProcessResult.java:<span class="number">49</span>)</span><br><span class="line">        at com.android.builder.core.AndroidBuilder.createMainDexList(AndroidBuilder.java:<span class="number">1384</span>)</span><br><span class="line">        at com.android.build.gradle.internal.transforms.MultiDexTransform.callDx(MultiDexTransform.java:<span class="number">309</span>)</span><br><span class="line">        at com.android.build.gradle.internal.transforms.MultiDexTransform.computeList(MultiDexTransform.java:<span class="number">265</span>)</span><br><span class="line">        at com.android.build.gradle.internal.transforms.MultiDexTransform.transform(MultiDexTransform.java:<span class="number">186</span>)</span><br></pre></td></tr></table></figure><p>从上面的堆栈信息可以直接看出Gradle插件在调用dx工具的时候出现异常了（Process的返回值不是0，也就是Java程序里面调用了System.exit(0)之外的结束方法），对应的类为<code>ClassReferenceListBuilder</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> keepAnnotated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (argIndex &lt; args.length -<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[argIndex].equals(DISABLE_ANNOTATION_RESOLUTION_WORKAROUND)) &#123;</span><br><span class="line">            keepAnnotated = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"Invalid option "</span> + args[argIndex]);</span><br><span class="line">            printUsage();</span><br><span class="line">            System.exit(STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        argIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (args.length - argIndex != <span class="number">2</span>) &#123;</span><br><span class="line">        printUsage();</span><br><span class="line">        System.exit(STATUS_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainDexListBuilder builder = <span class="keyword">new</span> MainDexListBuilder(keepAnnotated, args[argIndex],</span><br><span class="line">                args[argIndex + <span class="number">1</span>]);</span><br><span class="line">        Set&lt;String&gt; toKeep = builder.getMainDexList();</span><br><span class="line">        printList(toKeep);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">"A fatal error occurred: "</span> + e.getMessage());</span><br><span class="line">        System.exit(STATUS_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由其中的 <code>MainDexListBuilder builder = new MainDexListBuilder(keepAnnotated, args[argIndex], args[argIndex + 1])</code> 也能进一步定位到上面的 <code>com.android.dx.rop.annotation.Annotation.java</code> 出问题的地方。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>推荐阅读 <a href="https://www.easydone.cn/2017/01/02/" target="_blank" rel="noopener">ProGuard在插件化里的应用</a>。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = ProGuard 又搞了个大新闻Date = 2017-03-20 00:00:00Published = trueCategory = AndroidTag = ['Android', 'ProGuard', 'Annotation']FileLocate = androidFileName = naughty-proguardhexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，Android项目经常开启ProGuard功能来混淆代码，一方面可以降低应用被反编译后代码的友善度，增加被逆向的难度，另一方面开可以通过精简Java API的名字来减少代码的总量，从而精简应用编译后的体积。&lt;/p&gt;
&lt;p&gt;ProGuard有个比较坑爹的问题。在开发阶段，我们一般不启用ProGuard，只有在构建Release包的时候才开启。因此，如果有一些API被混淆了会出现BUG，那么在开发阶段我们往往无法察觉BUG，只有在构建发布包的时候才发现，甚至要等发布到线上了才能发现，这种时候解决问题的成本就很大了。&lt;br&gt;不过今天被ProGuard坑的不是混淆API导致的BUG，这货在之前相当长的一段时间里一直相安无事，最近突然又搞了个大新闻，而且问题排查起来相当蹊跷、诡异。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="ProGuard" scheme="http://kaedea.com/tags/ProGuard/"/>
    
      <category term="Annotation" scheme="http://kaedea.com/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 注释优化插件：Comment Formatter</title>
    <link href="http://kaedea.com/2016/12/01/tools/comment-formatter/"/>
    <id>http://kaedea.com/2016/12/01/tools/comment-formatter/</id>
    <published>2016-12-01T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//               +---------------------------------------------+</span></span><br><span class="line"><span class="comment">//               | public static final FiledA mFiledA; // xxx  |</span></span><br><span class="line"><span class="comment">//               | private static final FiledB mFiledB; // xxx |</span></span><br><span class="line"><span class="comment">//               | public FiledC mFiledC; // xxx               |</span></span><br><span class="line"><span class="comment">//               | protected final FiledD mFiledD; // xxx      |</span></span><br><span class="line"><span class="comment">//               | FiledE mFiledE; // xxx                      |</span></span><br><span class="line"><span class="comment">//               |                     |                       |</span></span><br><span class="line"><span class="comment">//               |                     v                       |</span></span><br><span class="line"><span class="comment">//               | public static final FiledA mFiledA;  // xxx |</span></span><br><span class="line"><span class="comment">//               | private static final FiledB mFiledB; // xxx |</span></span><br><span class="line"><span class="comment">//               | public FiledC mFiledC;               // xxx |</span></span><br><span class="line"><span class="comment">//               | protected final FiledD mFiledD;      // xxx |</span></span><br><span class="line"><span class="comment">//               | FiledE mFiledE;                      // xxx |</span></span><br><span class="line"><span class="comment">//               +---------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>Comment Formatter is an IntelliJ IDEA plugin (also works in Android Studio) that formats comments as above. It will force all the comments to align to the longest one.</p><p><strong>Getting Started</strong></p><ol><li>Install <code>CommentFormatter</code> from <a href="https://github.com/kaedea/comment-formatter/releases" target="_blank" rel="noopener">release</a> or <a href="https://plugins.jetbrains.com/plugin/9337?pr=idea" target="_blank" rel="noopener">IntelliJ Plugin Repository</a>.</li><li>Select all the lines which you wanna format.</li><li>Select <code>Tool - Format comment</code> or toggle <code>Ctrl + Cmd + L</code> to format.</li></ol><p><a href="https://github.com/kaedea/comment-formatter" target="_blank" rel="noopener">Check it out</a>.</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = IDEA 注释优化插件：Comment FormatterDate = 2016-12-01Published = trueCategory = UtilityTag = ['生产工具', 'IDEA Plugin']FileLocate = toolsFileName = comment-formatterhexo.comments = truehexo.layout = linkhexo.link = https://github.com/kaedea/comment-formatter-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Utility" scheme="http://kaedea.com/categories/Utility/"/>
    
    
      <category term="生产工具" scheme="http://kaedea.com/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDEA Plugin" scheme="http://kaedea.com/tags/IDEA-Plugin/"/>
    
  </entry>
  
  <entry>
    <title>通过预安装给 MultiDex 加速</title>
    <link href="http://kaedea.com/2016/11/22/android/pre-multidex/"/>
    <id>http://kaedea.com/2016/11/22/android/pre-multidex/</id>
    <published>2016-11-22T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p>在Android Kikat及以前的Android系统上，构建或安装Apk会出现“<strong>65535方法数超标</strong>”以及“<strong>INSTALL_FAILED_DEXOPT</strong>”问题，MultiDex是Google为了解决这个问题问题而开发的一个Support库。MultiDex出现的具体背景、使用方式可以参考<a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给App启用 MultiDex功能</a>，而MultiDex Support库的工作机制、源码分析可以参考<a href="http://kaedea.com/2016/11/11/android/multidex-source-code/">MultiDex工作原理分析和优化方案</a>。</p><p>MultiDex的使用虽然很简单便捷，但是有个比较蛋疼的问题，就是在App第一次冷启动的时候会产生明显的卡顿现象。经过测试和统计，根据Apk包的大小、Android系统版本的不同，这个卡顿时间一般是2000到5000毫秒左右，极端的情况下甚至可以到20000+毫秒。通过之前的分析，我们知道具体的卡顿产生在MultiDex解压、优化dex这两个过程，而且只在第一次冷启动的时候才会触发这两个过程。那么优化的方式也很简单，在安装Apk前先对新版本的Apk做好解压和优化工作，就能在安装后第一次冷启动的时候避开这两个耗时的过程了。</p><a id="more"></a><h2 id="MultiDex是如何判断是否需要重新解压和优化dex的"><a href="#MultiDex是如何判断是否需要重新解压和优化dex的" class="headerlink" title="MultiDex是如何判断是否需要重新解压和优化dex的"></a>MultiDex是如何判断是否需要重新解压和优化dex的</h2><p>在之前的章节里面讲到，MultiDex在第一次做完解压和优化dex之后，会保留当前Apk的一些信息，下一次启动时候后读取这些配置信息再判断是否需要重新解压和优化dex文件。<br>这个判断主要是在MultiDexExtractor#load(Context, ApplicationInfo, File, boolean)方法里进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ...</span><br><span class="line">                files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                putStoredApkInfo(context,</span><br><span class="line">                        getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次调用这个方法的时候，forceReload为false，则不需要强制重新解压dex。然后调用了<code>isModified</code>这个方法判断当前App的Apk包是否被修改过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isModified</span><span class="params">(Context context, File archive, <span class="keyword">long</span> currentCrc)</span> </span>&#123;</span><br><span class="line">    SharedPreferences prefs = getMultiDexPreferences(context);</span><br><span class="line">    <span class="keyword">return</span> (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))</span><br><span class="line">            || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isModified</code>方法主要是判断当前App的Apk包的CRC值是否和上一次解压dex时记录的Apk包CRC一样（CRC值可以认为是一个稀疏的MD5算法，它的时间复杂度低很多，但是计算结果容易产生冲突），以及Apk文件的修改时间（文件的Last Modified Time）是否一致。如果这两项都一致的话就认为Apk文件没有产生变化（没有覆盖安装过），因此上一次解压和优化dex得到的缓存文件可以复用。</p><p>当然，光Apk包没有修改过这一项条件还不够，接下来调用了这个判断主要是在MultiDexExtractor#loadExistingExtractions(Context, File, File)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">loadExistingExtractions</span><span class="params">(Context context, File sourceApk, File dexDir)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line">    <span class="keyword">int</span> totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;File&gt;(totalDexNumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> secondaryNumber = <span class="number">2</span>; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">        File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">        <span class="keyword">if</span> (extractedFile.isFile()) &#123;</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line">            <span class="keyword">if</span> (!verifyZipFile(extractedFile)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Invalid ZIP file."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing extracted secondary dex file '"</span> +</span><br><span class="line">                    extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先通过SharePreference读取上一次MultiDex保存的Apk包的dex数量totalDexNumber，然后挨个加载预定的文件路径上的dex文件，加载文件的的同时还通过<code>verifyZipFile</code>方法判断dex文件的合法性。如果这个过程出现异常就认为获取上一次缓存的dex文件失败，需要重新解压。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyZipFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zipFile.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to close zip file: "</span> + file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZipException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"File "</span> + file.getAbsolutePath() + <span class="string">" is not a valid zip file."</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Got an IOException trying to open zip file: "</span> + file.getAbsolutePath(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>verifyZipFile</code>这个方法非常简单，解压dex文件的时候，解压出来的文件被保存成Zip包，这个方法这是检查缓存的dex文件是否是Zip包。感觉不靠谱，虽然检查MD5值比较耗时不适合这种情景，不过好歹也像检查Apk包的CRC值和修改时间一样，检查dex缓存文件的CRC和修改时间啊。不过读取SharePreference配置是一个IO操作，如果保存的数值太多的话，也是有增加耗时和IO异常的风险的。</p><p>到这里我们的方案就清晰了：</p><ol><li>在安装新Apk前，先做好dex的解压和优化，得到dex压缩包（.zip）列表和dexopt后的odex文件（.dex）列表。</li><li>把dex/odex文件保存到一个内部存储路径PATH_A，同时使用SP记录新版本Apk的CRC、dex数量，以及解压出来的每一个dex的CRC值。</li><li>安装新版本Apk后，启动时在执行MultiDex前，把PATH_A路径上的缓存文件移动（rename）到MultiDex的缓存路径PATH_B上，同时保存当前Apk的CRC、修改时间以及dex数量到MultiDex对应的SP配置上。</li><li>执行原有MultiDex逻辑，让MultiDex以为之前已经做过解压和优化dex工作，从而绕开第一次MultiDex时候的耗时。</li><li>第一次成功启动新Apk后，对dex进行校验工作，如果校验失败则清除dex缓存，强制让App在下一次启动的时候再执行一遍MultiDex。</li></ol><h2 id="预解压（PreMultiDex）详细的流程图"><a href="#预解压（PreMultiDex）详细的流程图" class="headerlink" title="预解压（PreMultiDex）详细的流程图"></a>预解压（PreMultiDex）详细的流程图</h2><p>注：</p><ol><li>流程图的绿色部分为文件锁（FileLock）操作，主要是为了多进程同步。</li><li>红色部分为耗时的操作。</li><li>Dex路径为MultiDex过程中用于存储解压出来的dex文件的路径（/data/data//code_cache）。</li><li>PreDex路径为存储预解压得到的缓存文件的内部路径（/data/data//code_cache_pre）。</li><li>MultiDex从Apk包解压出来的dex文件会被压缩成Zip包（.zip），而执行dexopt操作后生成的odex文件文件名为.dex，这两个容易搞混。</li></ol><h3 id="安装新Apk前先解压和优化dex"><a href="#安装新Apk前先解压和优化dex" class="headerlink" title="安装新Apk前先解压和优化dex"></a>安装新Apk前先解压和优化dex</h3><p>这个环节必须在升级Apk前，由旧版本的Apk进行，也就是要求App拥有<strong>自主更新</strong>的逻辑。</p><p><img src="/assets/006y8lvagw1fam9ukwfv1j30jr0vvgpm.jpg" alt></p><h3 id="第一次运行新Apk时，移动预先安装好的dex文件"><a href="#第一次运行新Apk时，移动预先安装好的dex文件" class="headerlink" title="第一次运行新Apk时，移动预先安装好的dex文件"></a>第一次运行新Apk时，移动预先安装好的dex文件</h3><p>从旧版的Apk覆盖安装新的Apk后，第一次运行App时MultiDex主要的耗时过程。这时需要把在旧版本Apk预安装得到的dex缓存文件移动到MultiDex使用的存储路径上。</p><p><img src="/assets/006y8lvagw1fam9pz6n4rj30kr19aq9o.jpg" alt></p><h3 id="第一次运行新Apk后，检查dex文件是否正确"><a href="#第一次运行新Apk后，检查dex文件是否正确" class="headerlink" title="第一次运行新Apk后，检查dex文件是否正确"></a>第一次运行新Apk后，检查dex文件是否正确</h3><p>原有的MultiDex，dex文件时同步从Apk包里解压出来的，所以不存在dex文件和Apk版本对不上的问题。而<strong>PreMultiDex</strong>的方案的一个问题ui是，解压dex文件和使用dex文件这两个过程是分开的，无论版本控制做得再精确，理论上也存在版本出错的问题（比如从A版本解压得到了dex文件，而用户却选择覆盖安装了B版本，这时候由于代码逻辑的不严谨导致B版本的Apk使用了A版本解压出来的dex文件）。如果想要确保dex文件的正确性，需要对Apk包里面的dex文件和解压出来的dex文件做一下MD5值校验，而这个过程比较耗时，不适合在App启动的时候做，不然<strong>PreMultiDex</strong>就失去了意义。因此，需要在第一次运行新Apk后，启动dex的校验工作，在Worker线程对dex进行校验，如果校验失败则清除dex缓存，强制让App在下一次启动的时候再执行一遍MultiDex。</p><p><img src="/assets/006y8lvagw1fam9polrlrj30k313jwjf.jpg" alt></p><h3 id="恢复MultiDex"><a href="#恢复MultiDex" class="headerlink" title="恢复MultiDex"></a>恢复MultiDex</h3><p>在MultiDex校验失败后，需要清空MultiDex的缓存文件，禁用<strong>PreMultiDex</strong>功能，并且强制让App在下一次启动的时候再执行一遍MultiDex。</p><p><img src="/assets/006y8lvagw1fam9pce8p3j30dt0lognc.jpg" alt></p><h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><h3 id="dex文件、odex文件？"><a href="#dex文件、odex文件？" class="headerlink" title="dex文件、odex文件？"></a>dex文件、odex文件？</h3><p>dex文件是Android虚拟机使用的可执行文件（从Java类编译得到），相当于JVM虚拟机用的class文件。但是与class文件不同，Android系统并不能直接使用dex文件，需要先使用dexopt工具对dex文件进行一次优化工作（Optimize），优化得到的odex文件才能被虚拟机加载。不同的Android设备需要不同格式的odex文件，所以这个过程只能在Android设备上进行，而不能在构建Apk的时候就处理好。</p><p>dex文件在Apk包里的文件后缀名是<strong>.dex</strong>，MultiDex从Apk包里解压出dex文件后会压缩成Zip包，文件后缀名是<strong>.zip</strong>。对dex文件进行dexopt操作后，会生成相同文件名的odex文件，后缀名是<strong>.dex</strong>，odex文件会比dex文件大许多，不要搞混这些文件。</p><p>至于为什么MultiDex解压dex文件时会进行压缩工作，可能是因为压缩后的压缩包会占用比较小的内部存储空间，因为MultiDex本来就是给旧版本的Android系统使用，一些早期的Android设备拥有的内部存储空间非常有限，而这些dex文件对于App的运行时必须的，所以才需要尽量压缩dex的体积。压缩过程会有明显的耗时，经过测试，如果不进行压缩，直接从Apk里解压dex文件，则MultiDex过程会有大约<strong>1/3</strong>的加速效果。</p><h3 id="dexopt缓存"><a href="#dexopt缓存" class="headerlink" title="dexopt缓存"></a>dexopt缓存</h3><p>MultiDex其实并没有刻意保留dexopt后的缓存，如果只保留dex文件，而不保留odex文件，那么下一次启动执行MultiDex的时候，不需要重新解压dex文件，但是依然需要dexopt并产生odex文件，这个过程大概会占用MultiDex总耗时的一般左右。如果odex文件存在，但是已经损坏了，或者是一个非法的odex文件，依然会触发dexopt工作。也就是说，加载dex文件并创建DexFile对象的时候，Android系统会判断odex的缓存，以及缓存文件是否正确，具体过程在<a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a>里实现，有兴趣的同学可以找找dex文件结构分析的文章，这里就不挖坑了。</p><h3 id="关于dex文件校验"><a href="#关于dex文件校验" class="headerlink" title="关于dex文件校验"></a>关于dex文件校验</h3><p>其实，如果dex文件和Apk的版本对不上的话，一般在启动App的时候就会出现ClassNotFound异常而导致App崩溃，接着再次启动由于没有重新MultiDex也会继续崩溃。而崩溃的时候，可能App崩溃上报系统还没来得及初始化，所以没有办法发现崩溃的问题。</p><p>为了防止这种问题，可以开发一个<strong>恢复模式</strong>或者<strong>安全模式</strong>的功能，当App出现连续的崩溃的时候，会进入恢复模式的状态，清空一些可能导致异常的数据（比如PreMultiDex的缓存），这样就能避免App因为连续崩溃而不能使用。至于怎么实现恢复，这已经是另一个领域的功能了，这里不再展开。<br>参考链接： <a href="https://android.googlesource.com/platform/frameworks/multidex/" target="_blank" rel="noopener">Google Multidex</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 通过预安装给 MultiDex 加速Date = 2016-11-22 00:00:00Published = trueCategory = AndroidTag = ['Android', 'MultiDex', 'APM', '启动速度']FileLocate = androidFileName = pre-multidexhexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android Kikat及以前的Android系统上，构建或安装Apk会出现“&lt;strong&gt;65535方法数超标&lt;/strong&gt;”以及“&lt;strong&gt;INSTALL_FAILED_DEXOPT&lt;/strong&gt;”问题，MultiDex是Google为了解决这个问题问题而开发的一个Support库。MultiDex出现的具体背景、使用方式可以参考&lt;a href=&quot;http://kaedea.com/2015/09/02/android/enable-multidex/&quot;&gt;给App启用 MultiDex功能&lt;/a&gt;，而MultiDex Support库的工作机制、源码分析可以参考&lt;a href=&quot;http://kaedea.com/2016/11/11/android/multidex-source-code/&quot;&gt;MultiDex工作原理分析和优化方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;MultiDex的使用虽然很简单便捷，但是有个比较蛋疼的问题，就是在App第一次冷启动的时候会产生明显的卡顿现象。经过测试和统计，根据Apk包的大小、Android系统版本的不同，这个卡顿时间一般是2000到5000毫秒左右，极端的情况下甚至可以到20000+毫秒。通过之前的分析，我们知道具体的卡顿产生在MultiDex解压、优化dex这两个过程，而且只在第一次冷启动的时候才会触发这两个过程。那么优化的方式也很简单，在安装Apk前先对新版本的Apk做好解压和优化工作，就能在安装后第一次冷启动的时候避开这两个耗时的过程了。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="APM" scheme="http://kaedea.com/tags/APM/"/>
    
      <category term="MultiDex" scheme="http://kaedea.com/tags/MultiDex/"/>
    
      <category term="启动速度" scheme="http://kaedea.com/tags/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex 工作原理分析和优化方案</title>
    <link href="http://kaedea.com/2016/11/11/android/multidex-source-code/"/>
    <id>http://kaedea.com/2016/11/11/android/multidex-source-code/</id>
    <published>2016-11-11T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p>动态加载技术（插件化）系列已经坑了有一段时间了，不过UP主我并没有放弃治疗哈，相信在不就的未来就可以看到“系统Api Hook模式”和插件化框架Frontia的更新了。今天要讲的是动态加载技术的亲戚 —— MultiDex。他们的核心原理之一都是dex文件的加载。</p><p>MultiDex 是Google 为了解决 “<strong>65535方法数超标</strong>” 以及 “<strong>INSTALL_FAILED_DEXOPT</strong>” 问题而开发的一个Support库，具体如何使用MultiDex现在市面已经有一大堆教程（可以参考<a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>），这里不再赘述。这篇日志主要是配合源码分析MultiDex的工作原理，以及提供一些MultiDex优化的方案。</p><a id="more"></a><h2 id="Dex的工作机制"><a href="#Dex的工作机制" class="headerlink" title="Dex的工作机制"></a>Dex的工作机制</h2><p>等等，这个章节讲的不是MultiDex吗，怎么变成Dex了？没错哈，没有Dex，哪来的MultiDex。在Android中，对Dex文件操作对应的类叫做DexFile。在<a href="http://kaedea.com/2016/02/07/android-dynamical-loading-02-classloader/">CLASSLOADER 的工作机制</a>中，我们说到：</p><blockquote><p>对于 Java 程序来说，编写程序就是编写类，运行程序也就是运行类（编译得到的class文件），其中起到关键作用的就是类加载器 ClassLoader。</p></blockquote><p>Android程序的每一个Class都是由ClassLoader#loadClass方法加载进内存的，更准确来说，<strong>一个ClassLoader实例会有一个或者多个DexFile实例</strong>，调用了ClassLoader#loadClass之后，ClassLoader会通过类名，在自己的DexFile数组里面查找有没有那个DexFile对象里面存在这个类，如果都没有就抛ClassNotFound异常。ClassLoader通过调用DexFile的一个叫defineClass的Native方法去加载指定的类，这点与JVM略有不同，后者是直接调用ClassLoader#defineCLass方法，反正最后实际加载类的方法都叫defineClass就没错了🌝。</p><h3 id="创建DexFile对象"><a href="#创建DexFile对象" class="headerlink" title="创建DexFile对象"></a>创建DexFile对象</h3><p>首先来看看造DexFile对象的构方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCookie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mFileName;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(file.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mCookie = openDexFile(fileName, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        mFileName = fileName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">        mFileName = sourceName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        String slashName = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">return</span> loadClassBinaryName(slashName, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(<span class="keyword">byte</span>[] fileContents)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>通过以前分析过的源码，我们知道ClassLoader主要是通过DexFile.loadDex这个静态方法来创建它需要的DexFile实例的，这里创建DexFile的时候，保存了Dex文件的文件路径mFileName，<strong>同时调用了openDexFile的Native方法打开Dex文件</strong>并返回了一个mCookie的整型变量（我不知道这个干啥用的，我猜它是一个C++用的资源句柄，用于Native层访问具体的Dex文件）。在Native层的openDexFile方法里，主要做了检查当前创建来的Dex文件是否是有效的Dex文件，还是是一个带有Dex文件的压缩包，还是一个无效的Dex文件。</p><h3 id="加载Dex文件里的类"><a href="#加载Dex文件里的类" class="headerlink" title="加载Dex文件里的类"></a>加载Dex文件里的类</h3><p>加载类的时候，ClassLoader又是通过DexFile#loadClass这个方法来完成的，这个方法里调用了defineClass这个Native方法，<strong>看来DexFile才是加载Class的具体API，加载Dex文件和加载具体Class都是通过Native方法完成</strong>，ClassLoader有点名不副实啊。</p><h2 id="MultiDex的工作机制"><a href="#MultiDex的工作机制" class="headerlink" title="MultiDex的工作机制"></a>MultiDex的工作机制</h2><p>当一个Dex文件太肥的时候（方法数目太多、文件太大），在打包Apk文件的时候就会出问题，就算打包的时候不出问题，在Android 5.0以下设备上安装或运行Apk也会出问题（具体原因可以参考<a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>）。既然一个Dex文件不行的话，那就把这个硕大的Dex文件拆分成若干个小的Dex文件，刚好一个ClassLoader可以有多个DexFile，这就是MultiDex的基本设计思路。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>MultiDex的工作流程具体分为两个部分，一个部分是打包构建Apk的时候，将Dex文件拆分成若干个小的Dex文件，这个Android Studio已经帮我们做了（设置 “multiDexEnabled true”），另一部分就是在启动Apk的时候，同时加载多个Dex文件（具体是加载Dex文件优化后的Odex文件，不过文件名还是.dex），这一部分工作从Android 5.0开始系统已经帮我们做了，但是在Android 5.0以前还是需要通过MultiDex Support库来支持（MultiDex.install(Context)）。</p><p>所以我们需要关心的是第二部分，这个过程的简单示意流程图如下。</p><p><img src="/assets/4d91c7cd_4563_4391_a0a2_9ef1d8624c9c_untitled.png" alt></p><p>（图中红色部分为耗时比较大的地方）</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>现在官方已经部署的MultiDex Support版本是<code>com.android.support:multidex:1.0.1</code>，但是现在仓库的master分支已经有了许多新的提交（其中最明显的区别是加入了FileLock来控制多进程同步问题），所以这里分析的源码都是最新的master分支上的。</p><p>MultiDex Support的入口是<code>MultiDex.install(Context)</code>，先从这里入手吧。（这次我把具体的分析都写在代码的注释了，这样看是不是更简洁明了些？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"install"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判读是否需要执行MultiDex。if (IS_VM_MULTIDEX_CAPABLE) &#123;</span></span><br><span class="line">            Log.i(TAG, <span class="string">"VM has multidex support, MultiDex support library is disabled."</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed. SDK "</span> + Build.VERSION.SDK_INT</span><br><span class="line">                    + <span class="string">" is unsupported. Min SDK version is "</span> + MIN_SDK_VERSION + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ApplicationInfo applicationInfo = getApplicationInfo(context);</span><br><span class="line">            <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Looks like running on a test Context, so just return without patching.return;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果这个方法已经调用过一次，就不能再调用了。synchronized (installedApk) &#123;</span></span><br><span class="line">                String apkPath = applicationInfo.sourceDir;</span><br><span class="line">                <span class="keyword">if</span> (installedApk.contains(apkPath)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                installedApk.add(apkPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果当前Android版本已经自身支持了MultiDex，依然可以执行MultiDex操作，// 但是会有警告。if (Build.VERSION.SDK_INT &gt; MAX_SUPPORTED_SDK_VERSION) &#123;</span></span><br><span class="line">                    Log.w(TAG, <span class="string">"MultiDex is not guaranteed to work in SDK version "</span></span><br><span class="line">                            + Build.VERSION.SDK_INT + <span class="string">": SDK version higher than "</span></span><br><span class="line">                            + MAX_SUPPORTED_SDK_VERSION + <span class="string">" should be backed by "</span></span><br><span class="line">                            + <span class="string">"runtime with built-in multidex capabilty but it's not the "</span></span><br><span class="line">                            + <span class="string">"case here: java.vm.version=\""</span></span><br><span class="line">                            + System.getProperty(<span class="string">"java.vm.version"</span>) + <span class="string">"\""</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取当前的ClassLoader实例，后面要做的工作，就是把其他dex文件加载后，// 把其DexFile对象添加到这个ClassLoader实例里就完事了。</span></span><br><span class="line">                ClassLoader loader;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    loader = context.getClassLoader();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Failure while trying to obtain Context class loader. "</span> +</span><br><span class="line">                            <span class="string">"Must be running in test mode. Skip patching."</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.e(TAG,</span><br><span class="line">                            <span class="string">"Context class loader is null. Must be running in test mode. "</span></span><br><span class="line">                            + <span class="string">"Skip patching."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 5. 清除旧的dex文件，注意这里不是清除上次加载的dex文件缓存。// 获取dex缓存目录是，会优先获取/data/data/&lt;package&gt;/code-cache作为缓存目录。// 如果获取失败，则使用/data/data/&lt;package&gt;/files/code-cache目录。// 这里清除的是第二个目录。</span></span><br><span class="line">                  clearOldDexDir(context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  Log.w(TAG, <span class="string">"Something went wrong when trying to clear old MultiDex extraction, "</span></span><br><span class="line">                      + <span class="string">"continuing without cleaning."</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 获取缓存目录（/data/data/&lt;package&gt;/code-cache）。</span></span><br><span class="line">                File dexDir = getDexDir(context, applicationInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 加载缓存文件（如果有）。</span></span><br><span class="line">                List&lt;File&gt; files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 检查缓存的dex是否安全if (checkValidZipFiles(files)) &#123;</span></span><br><span class="line"><span class="comment">// 9. 安装缓存的dex</span></span><br><span class="line">                    installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 9. 从apk压缩包里面提取dex文件</span></span><br><span class="line">                    Log.w(TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (checkValidZipFiles(files)) &#123;</span><br><span class="line"><span class="comment">// 10. 安装提取的dex</span></span><br><span class="line">                        installSecondaryDexes(loader, dexDir, files);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Multidex installation failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Multi dex installation failed ("</span> + e.getMessage() + <span class="string">")."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"install done"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体代码的分析已经在上面代码的注释里给出了，从这里我们也可以看出，整个MultiDex.install(Context)的过程中，关键的步骤就是<code>MultiDexExtractor#load</code>方法和<code>MultiDex#installSecondaryDexes</code>方法。</p><p>（这部分是题外话）其中有个<strong>MultiDex#clearOldDexDir(Context)</strong><strong>方法，这个方法的作用是删除</strong><strong>/data/data//files/code-cache</strong>，一开始我以为这个方法是删除上一次执行MultiDex后的缓存文件，不过这明显不对，不可能每次MultiDex都重新解压dex文件一边，这样每次启动会很耗时，<strong>只有第一次冷启动的时候才需要解压dex文件</strong>。后来我又想是不是以前旧版的MultiDex曾经把缓存文件放在这个目录里，现在新版本只是清除以前旧版的遗留文件？但是我找遍了整个MultiDex Repo的提交也没有见过类似的旧版本代码。后面我仔细看<strong>MultiDex#getDexDir</strong>这个方法才发现，原来MultiDex在获取dex缓存目录是，会优先获取<strong>/data/data//code-cache</strong>作为缓存目录，如果获取失败，则使用<strong>/data/data//files/code-cache</strong>目录，而后者的缓存文件会在每次App重新启动的时候被清除。感觉MultiDex获取缓存目录的逻辑不是很严谨，而获取缓存目录失败也是MultiDex工作工程中少数有重试机制的地方，看来MultiDex真的是一个临时的兼容方案，Google也许并不打算认真处理这些历史的黑锅。</p><p>接下来再看看MultiDexExtractor#load这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"MultiDexExtractor.load("</span> + applicationInfo.sourceDir + <span class="string">", "</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">final</span> File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取当前Apk文件的crc值。long currentCrc = getZipCrc(sourceApk);</span></span><br><span class="line"><span class="comment">// Validity check and extraction must be done only while the lock file has been taken.</span></span><br><span class="line">        File lockFile = <span class="keyword">new</span> File(dexDir, LOCK_FILENAME);</span><br><span class="line">        RandomAccessFile lockRaf = <span class="keyword">new</span> RandomAccessFile(lockFile, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel lockChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileLock cacheLock = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;File&gt; files;</span><br><span class="line">        IOException releaseLockException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lockChannel = lockRaf.getChannel();</span><br><span class="line">            Log.i(TAG, <span class="string">"Blocking on lock "</span> + lockFile.getPath());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 加上文件锁，防止多进程冲突。</span></span><br><span class="line">            cacheLock = lockChannel.lock();</span><br><span class="line">            Log.i(TAG, lockFile.getPath() + <span class="string">" locked"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 先判断是否强制重新解压，这里第一次会优先使用已解压过的dex文件，如果加载失败就强制重新解压。// 此外，通过crc和文件修改时间，判断如果Apk文件已经被修改（覆盖安装），就会跳过缓存重新解压dex文件。if (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 加载缓存的dex文件</span></span><br><span class="line">                    files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Failed to reload existing extracted secondary dex files,"</span></span><br><span class="line">                            + <span class="string">" falling back to fresh extraction"</span>, ioe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 加载失败的话重新解压，并保存解压出来的dex文件的信息。</span></span><br><span class="line">                    files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                    putStoredApkInfo(context,</span><br><span class="line">                            getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 4. 重新解压，并保存解压出来的dex文件的信息。</span></span><br><span class="line">                Log.i(TAG, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">                files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cacheLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cacheLock.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"Failed to release lock on "</span> + lockFile.getPath());</span><br><span class="line"><span class="comment">// Exception while releasing the lock is bad, we want to report it, but not at// the price of overriding any already pending exception.</span></span><br><span class="line">                    releaseLockException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lockChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closeQuietly(lockChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            closeQuietly(lockRaf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releaseLockException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> releaseLockException;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"load found "</span> + files.size() + <span class="string">" secondary dex files"</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个过程主要是获取可以安装的dex文件列表，可以是上次解压出来的缓存文件，也可以是重新从Apk包里面提取出来的。需要注意的时，如果是重新解压，这里会有明显的耗时，而且解压出来的dex文件，会被压缩成.zip压缩包，压缩的过程也会有明显的耗时（这里压缩dex文件可能是问了节省空间）。</p><p>如果dex文件是重新解压出来的，则会保存dex文件的信息，包括解压的apk文件的crc值、修改时间以及dex文件的数目，以便下一次启动直接使用已经解压过的dex缓存文件，而不是每一次都重新解压。</p><p>需要特别提到的是，里面的<strong>FileLock</strong>是最新的master分支里面新加进去的功能，现在最新的<code>1.0.1</code>版本里面是没有的。</p><p>无论是通过使用缓存的dex文件，还是重新从apk中解压dex文件，获取dex文件列表后，下一步就是安装（或者说加载）这些dex文件了。最后的工作在<code>MultiDex#installSecondaryDexes</code>这个方法里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span></span><br><span class="line"><span class="function">        InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在不同的SDK版本上，ClassLoader（更准确来说是DexClassLoader）加载dex文件的方式有所不同，所以这里做了V4/V14/V19的兼容（Magic Code）。</p><p>Build.VERSION.SDK_INT &lt; 14</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 4 to 13.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V4</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> extraSize = additionalClassPathEntries.size();</span><br><span class="line">            Field pathField = findField(loader, <span class="string">"path"</span>);</span><br><span class="line">            StringBuilder path = <span class="keyword">new</span> StringBuilder((String) pathField.get(loader));</span><br><span class="line">            String[] extraPaths = <span class="keyword">new</span> String[extraSize];</span><br><span class="line">            File[] extraFiles = <span class="keyword">new</span> File[extraSize];</span><br><span class="line">            ZipFile[] extraZips = <span class="keyword">new</span> ZipFile[extraSize];</span><br><span class="line">            DexFile[] extraDexs = <span class="keyword">new</span> DexFile[extraSize];</span><br><span class="line">            <span class="keyword">for</span> (ListIterator&lt;File&gt; iterator = additionalClassPathEntries.listIterator();</span><br><span class="line">                    iterator.hasNext();) &#123;</span><br><span class="line">                File additionalEntry = iterator.next();</span><br><span class="line">                String entryPath = additionalEntry.getAbsolutePath();</span><br><span class="line">                path.append(<span class="string">':'</span>).append(entryPath);</span><br><span class="line">                <span class="keyword">int</span> index = iterator.previousIndex();</span><br><span class="line">                extraPaths[index] = entryPath;</span><br><span class="line">                extraFiles[index] = additionalEntry;</span><br><span class="line">                extraZips[index] = <span class="keyword">new</span> ZipFile(additionalEntry);</span><br><span class="line">                extraDexs[index] = DexFile.loadDex(entryPath, entryPath + <span class="string">".dex"</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本是最简单的。// 只需要创建DexFile对象后，使用反射的方法分别扩展ClassLoader实例的以下字段即可。</span></span><br><span class="line">            pathField.set(loader, path.toString());</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mPaths"</span>, extraPaths);</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mFiles"</span>, extraFiles);</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mZips"</span>, extraZips);</span><br><span class="line">            expandFieldArray(loader, <span class="string">"mDexs"</span>, extraDexs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>14 &lt;= Build.VERSION.SDK_INT &lt; 19</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 14, 15, 16, 17 and 18.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V14</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展ClassLoader实例的"pathList"字段。</span></span><br><span class="line">            Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">                Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory)</span><br><span class="line">                        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</span><br><span class="line">                        NoSuchMethodException &#123;</span><br><span class="line">            Method makeDexElements =</span><br><span class="line">                    findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">File</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从API14开始，DexClassLoader会使用一个DexpDexPathList类来封装DexFile数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JAR_SUFFIX = <span class="string">".jar"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_SUFFIX = <span class="string">".zip"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            ZipFile zip = <span class="keyword">null</span>;</span><br><span class="line">            DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line"><span class="comment">// Raw dex file (not inside a zip/jar).try &#123;</span></span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                    || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zip = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to open zip file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.logW(<span class="string">"Unknown file type for: "</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<strong>DexPathList#makeDexElements</strong>方法，可以加载我们上面解压得到的dex文件，从代码也可以看出，<strong>DexPathList#makeDexElements</strong>其实也是通过调用<strong>DexFile#loadDex</strong>来加载dex文件并创建DexFile对象的。V14中，通过反射调用<strong>DexPathList#makeDexElements</strong>方法加载我们需要的dex文件，在把加载得到的数组扩展到ClassLoader实例的”pathList”字段，从而完成dex文件的安装。</p><p>从DexPathList的代码中我们也可以看出，ClassLoader是支持直接加载.dex/.zip/.jar/.apk的dex文件包的（我记得以前在哪篇日志中好像提到过类似的问题…）。</p><p>19 &lt;= Build.VERSION.SDK_INT</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 19.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">            expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                    suppressedExceptions));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                Field suppressedExceptionsField =</span><br><span class="line">                        findField(dexPathList, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">                IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                        (IOException[]) suppressedExceptionsField.get(dexPathList);</span><br><span class="line">                <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dexElementsSuppressedExceptions =</span><br><span class="line">                            suppressedExceptions.toArray(</span><br><span class="line">                                    <span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    IOException[] combined =</span><br><span class="line">                            <span class="keyword">new</span> IOException[suppressedExceptions.size() +</span><br><span class="line">                                            dexElementsSuppressedExceptions.length];</span><br><span class="line">                    suppressedExceptions.toArray(combined);</span><br><span class="line">                    System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined,</span><br><span class="line">                            suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                    dexElementsSuppressedExceptions = combined;</span><br><span class="line">                &#125;</span><br><span class="line">                suppressedExceptionsField.set(dexPathList, dexElementsSuppressedExceptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">                Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">                        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</span><br><span class="line">                        NoSuchMethodException &#123;</span><br><span class="line">            Method makeDexElements =</span><br><span class="line">                    findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">File</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ArrayList</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory,</span><br><span class="line">                    suppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>V19与V14差别不大，只不过<strong>DexPathList#makeDexElements</strong>方法多了一个ArrayList参数，如果在执行<strong>DexPathList#makeDexElements</strong>方法的过程中出现异常，后面使用反射的方式把这些异常记录进DexPathList的<strong>dexElementsSuppressedExceptions</strong>字段里面。</p><p>无论是V4/V14还是V19，在创建DexFile对象的时候，都需要通过DexFile的Native方法<strong>openDexFile</strong>来打开dex文件，其具体细节暂不讨论（涉及到dex的文件结构，很烦，有兴趣请阅读<a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a>），这个过程的主要目的是给当前的dex文件做Optimize优化处理并生成相同文件名的odex文件，App实际加载类的时候，都是通过odex文件进行的。因为每个设备对odex格式的要求都不一样，所以这个优化的操作只能放在安装Apk的时候处理，主dex的优化我们已经在安装apk的时候搞定了，其余的dex就是在<code>MultiDex#installSecondaryDexes</code>里面优化的，而后者也是MultiDex过程中，另外一个耗时比较多的操作。（在MultiDex中，提取出来的dex文件被压缩成.zip文件，又优化后的odex文件则被保存为.dex文件。）</p><p>到这里，MultiDex的工作流程就结束了。怎么样，是不是觉得和以前谈到动态加载技术（插件化）的时候说的很像？没错，谁叫它们的核心都是dex文件呢。Java老师第一节课就说“<strong>类就是编程</strong>”，搞定类你就能搞定整个世界啊！</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>MultiDex有个比较蛋疼的问题，就是会产生明显的卡顿现象，通过上面的分析，我们知道具体的卡顿产生在<strong>解压dex文件</strong>以及<strong>优化dex</strong>两个步骤。不过好在，在Application#attachBaseContext(Context)中，UI线程的阻塞是不会引发ANR的，只不过这段长时间的卡顿（白屏）还是会影响用户体验。<br>目前，优化方案能想到的有两种。</p><h3 id="PreMultiDex方案"><a href="#PreMultiDex方案" class="headerlink" title="PreMultiDex方案"></a>PreMultiDex方案</h3><p>大致思路是，在安装一个新的apk的时候，先在Worker线程里做好MultiDex的解压和Optimize工作，安装apk并启动后，直接使用之前Optimize产生的odex文件，这样就可以避免第一次启动时候的Optimize工作。</p><p><img src="/assets/02dd6659_1487_4691_a0a6_d9c1ad849079_untitled.png" alt></p><p>安装dex的时候，核心是创建DexFile对象并使用其Native方法对dex文件进行opt处理，同时生产一个与dex文件（.zip）同名的已经opt过的dex文件（.dex）。如果安装dex的时候，这个opt过的dex文件已经存在，则跳过这个过程，这会节省许多耗时。所以优化的思路就是，下载Apk完成的时候，预先解压dex文件，并预先触发安装dex文件以生产opt过的dex文件。这样覆盖安装Apk并启动的时候，如果MultiDex能命中解压好的dex和odex文件，则能避开耗时最大的两个操作。</p><p>不过这个方案的缺点也是明显的，第一次安装的apk没有作用，而且事先需要使用内置的apk更新功能把新版本的apk文件下载下来后，才能做PreMultiDex工作。</p><h3 id="异步MultiDex方案"><a href="#异步MultiDex方案" class="headerlink" title="异步MultiDex方案"></a>异步MultiDex方案</h3><p>这种方案也是目前比较流行的<strong>Dex手动分包方案</strong>，启动App的时候，先显示一个简单的Splash闪屏界面，然后启动Worker线程执行MultiDex#install(Context)工作，就可以避免UI线程阻塞。不过要确保启动以及启动MultiDex#install(Context)所需要的类都在主dex里面（手动分包），而且需要处理好进程同步问题。</p><p>参考资料：</p><ul><li><a href="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="noopener">Configure Apps with Over 64K Methods</a></li><li><a href="https://android.googlesource.com/platform/frameworks/multidex/" target="_blank" rel="noopener">Google Multidex</a></li><li><a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a></li></ul><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = MultiDex 工作原理分析和优化方案Date = 2016-11-11 00:00:00Published = trueCategory = AndroidTag = ['Android', 'MultiDex', '源码分析']FileLocate = androidFileName = multidex-source-codehexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态加载技术（插件化）系列已经坑了有一段时间了，不过UP主我并没有放弃治疗哈，相信在不就的未来就可以看到“系统Api Hook模式”和插件化框架Frontia的更新了。今天要讲的是动态加载技术的亲戚 —— MultiDex。他们的核心原理之一都是dex文件的加载。&lt;/p&gt;
&lt;p&gt;MultiDex 是Google 为了解决 “&lt;strong&gt;65535方法数超标&lt;/strong&gt;” 以及 “&lt;strong&gt;INSTALL_FAILED_DEXOPT&lt;/strong&gt;” 问题而开发的一个Support库，具体如何使用MultiDex现在市面已经有一大堆教程（可以参考&lt;a href=&quot;http://kaedea.com/2015/09/02/android/enable-multidex/&quot;&gt;给 App 启用 MultiDex 功能&lt;/a&gt;），这里不再赘述。这篇日志主要是配合源码分析MultiDex的工作原理，以及提供一些MultiDex优化的方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://kaedea.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MultiDex" scheme="http://kaedea.com/tags/MultiDex/"/>
    
  </entry>
  
  <entry>
    <title>Android Logging 的正确姿势</title>
    <link href="http://kaedea.com/2016/10/02/android/log-utility/"/>
    <id>http://kaedea.com/2016/10/02/android/log-utility/</id>
    <published>2016-10-02T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.984Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LOG 是任何一种编程语言的第一个API，通常被初学者用来打印 Hello, World!。 有研究显示，不使用 LOG 或者使用姿势错误的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情需要书写，不能是一整张白纸。</p></blockquote><p>LogCat是Android开发者们最熟悉不过的日志打印工具，几乎每一个Android项目里面都包含着大量的Log相关代码。不过，或许是因为Log实在是太过于普通，所以许多人在使用它的时候就显得非常随意，这些错误的使用姿势却会在不经意间给我们带来不少的大坑。</p><a id="more"></a><h2 id="Log相关的一些问题"><a href="#Log相关的一些问题" class="headerlink" title="Log相关的一些问题"></a>Log相关的一些问题</h2><h3 id="没有关闭调试用的LOG"><a href="#没有关闭调试用的LOG" class="headerlink" title="没有关闭调试用的LOG"></a>没有关闭调试用的LOG</h3><p>许多同学喜欢在开发阶段用Log输出当前的一些环境数据，用于调试代码，但是在调试完成后却忘了关闭这些Log，导致发版出去的应用里面还会继续输出这些LOG，这样不仅会造成不必要的性能丢失，也会暴露一些敏感的数据，这些都是我们不愿看到的。</p><p>首先，我们要给Log进行分级，规定“DEBUG版本输出哪一些级别的LOG并屏蔽哪一些级别的LOG，而RELEASE版本又输出另一些级别的LOG并屏蔽另一些级别的LOG”，这样在开发阶段能够输出我们调试需要的LOG，而同时又能保证放送的版本能够屏蔽这些敏感的LOG。但是在开发阶段我们不应该特意去注意这些细节，所以必须开发一个Log工具库，在框架层级解决这个需求。</p><p>同时，需要注意的是，<strong>用于作为“开启/关闭Log”的开关必须是一个常量</strong>，而不能是一个变量（使用常量的话，在编译代码的时候，如果常量为false），编译器会直接把调试部分的Log代码直接去掉，而使用变量作为开关的话，这个判断逻辑会继续保留，一方面会造成性能丢失，另一方面在运行时也可以通过Hack手段强行开启这部分Log代码。</p><p>另外，“开启/关闭Log”的开关必须写在Log方法外部，也就是说必须先判断“开启/关闭Log”条件，再调用Log方法，因为在调用Log方法的时候已经造成了性能丢失，而且调用方法的时候，会先构造好改方法需要的参数（按照参数顺序从右往左），再调用方法，而许多人喜欢在调用Log方法的时候计算需要打印出来的内容，这里是最容易造成性能丢失的地方。因此，如果为了图方便，写一个Log工具类，在工具类内部去判断是否应该开启或关闭Log，事实上已经造成了不少的性能丢失。正确的使用姿势应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">  Log.v(TAG, <span class="string">"log something"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在循环体内部打印LOG"><a href="#在循环体内部打印LOG" class="headerlink" title="在循环体内部打印LOG"></a>在循环体内部打印LOG</h3><p>尽管Log造成的性能损失很小，但是如果在循环体内部循环调用Log方法的话，那总体的丢失的非常可观了，所以不应该在循环体内部使用Log，正确的做法是在循环体内部拼接需要打印的内容，等跳出循环体再一次打印出来。</p><p>除了常见的循环体外，还要一个需要注意的场景就是Adapter。ListView/RecyclerView是Android开发中最常用的控件，因此Adapter使用的情景也很多。滚动屏幕的时候，ListView/RecyclerView会在通过Adapter频繁地绑定ItemView和数据，而且这些都是在UI线程里进行的，所以如果在绑定的过程中调用Log，可能会造成明显的卡顿。</p><p>至于Log到底会丢失多少性能，一般情况下，Log的性能丢失很小，毕竟是这么常见的系统Api，肯定是身经百战，早就是“best performance”了。不过我曾经有个RecyclerView在<strong>MIUI</strong>上非常卡，一开始我是RecyclerView布局没优化好，最终定位到Adapter内部的一处Log上，卡顿的地方出现在Log的Native实现。<strong>MIUI</strong> 到底对用户输出的日志做了什么处理呢？非常神奇。</p><h3 id="无法获取重要LOG内容"><a href="#无法获取重要LOG内容" class="headerlink" title="无法获取重要LOG内容"></a>无法获取重要LOG内容</h3><p>在调试代码的时候，我们经常通过LOG来定位Bug。同理，当线上的版本出现问题的时候，我们也希望能通过LOG来定位问题所在。但是问题是用户的设备上的打印出来的LOG我们根本没有方法获取，唯一的手段就是当用户设备出现问题的时候，把设备借过来连上IDE用LogCat查看输出的LOG……显然这是不可行的。</p><p>这种时候，我们可以在打印重要LOG（比如重要路径的触发点、或者一些异常类的信息）的时候，一并把这些信息记录到文件里。在用户反馈系统里面，一并将这些文件上传到我们的用户反馈服务器，这样在处理反馈问题的时候，就能拿到重要的参考日志了。</p><h2 id="BLog"><a href="#BLog" class="headerlink" title="BLog"></a>BLog</h2><p>BLog 是 Android SDK 的 LOG 工具 {@link android.util.Log} 的加强版，以方便在开发时用来 操作调试日志。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>简单易用的API；</li><li>支持输出线程信息；</li><li>支持设置LogLevel，方便在生产环境关闭调试用的LOG；</li><li>支持将LOG内容写入文件，以便通过文件LOG定位用户反馈的问题；</li></ol><p>注意，尽管BLog支持关闭Log的输出，但是在你调用 <code>BLog.v(String)</code> 的时候，其实已经造成了性能 丢失，所以请尽量使用正确的姿势来使用BLog，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">  BLog.v(TAG, <span class="string">"log verbose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p><a href="https://github.com/kaedea/b-log" target="_blank" rel="noopener">https://github.com/kaedea/b-log</a><br>补充 2016-11-20 因为现在公司项目上也采用了BLog这个工具，开源公司项目相关的代码需要安装既定的流程来，所以暂时不公开源码。有兴趣的同学可以试下联系我交♂流。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Android Logging 的正确姿势Date = 2016-10-02 00:00:00Published = trueCategory = AndroidTag = ['Android', 'Logging', 'APM']FileLocate = androidFileName = log-utilityhexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LOG 是任何一种编程语言的第一个API，通常被初学者用来打印 Hello, World!。 有研究显示，不使用 LOG 或者使用姿势错误的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情需要书写，不能是一整张白纸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LogCat是Android开发者们最熟悉不过的日志打印工具，几乎每一个Android项目里面都包含着大量的Log相关代码。不过，或许是因为Log实在是太过于普通，所以许多人在使用它的时候就显得非常随意，这些错误的使用姿势却会在不经意间给我们带来不少的大坑。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="APM" scheme="http://kaedea.com/tags/APM/"/>
    
      <category term="Logging" scheme="http://kaedea.com/tags/Logging/"/>
    
  </entry>
  
  <entry>
    <title>黑苹果初体验 - 富士通 LH532</title>
    <link href="http://kaedea.com/2016/09/23/living/living-hackintosh-lh532/"/>
    <id>http://kaedea.com/2016/09/23/living/living-hackintosh-lh532/</id>
    <published>2016-09-23T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/bb50f6df_4c0f_424a_b9b3_04870fa7b35c_untitled.png" alt></p><p>高中开始折腾电脑DIY，当然硬件玩不起，只是折腾系统，一开始折腾重装Windows系统，玩腻了就折腾Linux，到后来开始打算折腾Mac。在普通PC上安装苹果的OSX系统（现在叫MacOS）的行为叫做黑苹果（Mackintosh），相反的，苹果自家产品自带的系统叫做白苹果（Mackintosh）。不过安装黑苹果比起Windows和Linux实在是难多了，所以那时候看教程看得一脸懵逼就结束了。</p><p>最近在公司开始正式切换到Mac系统上进行开发工作，但是回到家里就得用WIN10（Fujitsu LH532）进行开发，有个非常头疼的问题，就是Mac上的快捷键和Windows大相径庭，所以又产生了安装黑苹果的想法。看了一周的攻略之后，我迫不及待地开始了。</p><a id="more"></a><h2 id="学习攻略"><a href="#学习攻略" class="headerlink" title="学习攻略"></a>学习攻略</h2><p>首先需要学习一些安装黑苹果中需要用到的基本姿势，目前主要有以下渠道。<br><a href="http://www.tonymacx86.com/" target="_blank" rel="noopener">http://www.tonymacx86.com/</a><br>这个可以说是黑苹果的鼻祖，最前沿的阵地，在这里你可以学习到最新的黑苹果调教姿势，也可以在这里查询哪些PC硬件适合安装黑苹果，自己的电脑遇到兼容性问题也可以在这里搜索是不是有别人遇到类似的问题。唯一的要求，就是你的英文要够好。<br><a href="http://bbs.pcbeta.com/forum.php?gid=86" target="_blank" rel="noopener">PCbeta 黑苹果乐园</a><br>PCbeta 是国内PC电脑DIY强迫患者的集聚地，在这里你也可以找到不少详细的黑苹果安装攻略。<br>在我学习黑苹果基础姿势的时候，最头疼的问题，就是这些攻略教程实在是太多太杂了，而且质量参差不齐，杂乱无序，看来看去，许多术语都没有解释，莫名其妙，所以我才花了一个星期的时间才初步看明白了。</p><h2 id="简单易懂的说明方式"><a href="#简单易懂的说明方式" class="headerlink" title="简单易懂的说明方式"></a>简单易懂的说明方式</h2><p>假设你已经知道了怎么安装Windows，那你应该知道安装系统无非就是两个步骤：</p><ol><li>先通过安装媒介（光盘或者U盘）引导Windows安装程序并安装系统；</li><li>进入系统后安装硬件所需要的驱动；</li></ol><p>当然现在的Windows系统相对容易安装许多，它自带了许多最新的驱动，所以对于常见的PC硬件来说，有可能都不需要自己额外再安装驱动。而且，Windows有许多GHOST版本的安装镜像，里面事先打好了各种驱动和常见的软件、补丁程序，所以有时候你都不用进行第二步。<br>对于安装黑苹果系统来说步骤也差不多，只不过，Mac系统对硬盘格式有要求，所以首先你可能要处理自己的硬盘的格式问题。其次，因为Mac系统是不被允许安装在苹果之外的产品上的，所以不能直接引导Mac系统安装程序，需要额外的软件来辅助引导。最后，MacOS自带的驱动程序许多情况下都不能兼容一般的PC硬件，所以安装完系统后，还要进行一系列的安装驱动的工作。<br>简单来说，安装黑苹果需要经过以下步骤。</p><h3 id="确认硬盘的格式"><a href="#确认硬盘的格式" class="headerlink" title="确认硬盘的格式"></a>确认硬盘的格式</h3><p>现在的硬盘主要有MBR和GPT格式，MacOS只能安装到GPT格式上，如果需要安装到MBR格式的硬盘上，需要在安装镜像上打上额外的补丁程序。当然现在有许多别人打好补丁的系统安装镜像，这种镜像叫做“懒人版”安装镜像。具体怎么区分硬盘格式和打补丁就不讨论了，请善用搜索工具。<br>我的LH532的硬盘是三星的SSD，是MBR格式的，为了图方便使用了懒人版。</p><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>搞好了系统安装镜像之后，并不能直接启动安装，需要制作一个用于引导的启动盘，以前启动盘的媒介大多是光驱启动，现在一般制作成U盘启动，也可以是硬盘划一个分区出来启动。制作启动盘的过程在Windows上和在MAC略有差别（后者相对简单），但是基本过程都是一样的，就是将系统安装镜像烧录到指定的媒介上。</p><h3 id="选用对应的引导辅助工具"><a href="#选用对应的引导辅助工具" class="headerlink" title="选用对应的引导辅助工具"></a>选用对应的引导辅助工具</h3><p>以前安装多系统的时候也需要引导辅助工具，比如EasyBCD，可以方便地引导到Windows或者Linux系统。引导问题也是黑苹果最核心的问题，现在的引导工具有Clover（四叶草），一般用来引导安装到GPT格式的硬盘上。另外有Chameleon（变色龙），用来引导安装到MBR格式的硬盘上。<br>把相应的引导辅助工具制作成U盘启动，就可以启动引导辅助工具来引导MacOS的系统镜像了。注意，这里并不像安装Windows那样直接引导系统镜像并运行安装程序就完事，除了使用相应的引导辅助工具之外，还需要根据自己电脑的配置，在引导辅助程序里面设置好相应的配置文件（Clover参考config.plist，变色龙参考Boot.plist），这也是安装黑苹果的关键步骤之一，能不能正常完成系统的安装工作就这一步，毕竟只要能成功进入系统，其他驱动问题都可以在系统内解决，如果连安装工作都无法完成，就没法进行下一步工作了。推荐搜索和自己配置（特别是主板）一致的设置方式。<br>这里也有另一种观点，传统使用光盘或者U盘引导安装Windows系统，都是利用Bios自带的引导功能，但是Bios的引导功能很有限，不足以引导安装Mac。所以可以把EsayBCD、Chameleon、Clover等引导工具看成一个微型的操作系统，电脑启动的时候Bios只负责引导到这些微型操作系统，之后“引导到Mac系统、双系统甚至多系统”等复杂工作在微型操作系统里面完成。<br>很明显，我的LH532用的是变色龙引导，plist也是在网上找到别人的LH532的调教方式。</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>如果上一步完成了，应该就能成功启动系统安装程序并安装系统了。接下来就是安装驱动程序了，到了这一步就因人而异了，如果有些硬件不能正常工作（比如常见网卡、声卡和显卡，俗称“三卡”问题），就搜索改硬件对应型号的驱动吧，现在主流的配置一般都有别人提供的驱动。</p><h2 id="Fujitsu-LH532-OS-X-El-Capitan"><a href="#Fujitsu-LH532-OS-X-El-Capitan" class="headerlink" title="Fujitsu LH532 OS X El Capitan"></a>Fujitsu LH532 OS X El Capitan</h2><p>折腾了一天，我的笔记本的黑苹果总算搞定了，安装了WIN10 + El Capitan双系统。怎么说呢，黑苹果用起来比Windows还稳定。经过几年的的“折磨”后，我的LH532用WIN10时不时总会蓝屏，但是用El Capitan却一直很稳定，当然还是有一些问题的。</p><ol><li>无线网卡/蓝牙无法驱动，我自己买了个USB无线网卡；</li><li>屏幕亮度无法调节，这个也很坑，好在我现在用的是外接显示器；</li><li>ALPS触摸板可用但是无法使用双指；</li><li>有时候电脑进入睡眠后无法唤醒；</li></ol><p>好吧，感觉LH532能这样续命已经超出我的期待了，性能跑分居然还能顶上中配的MBP13。虽然安装了双系统，但是用上El Capitan之后，我就很少用回WIN10了。<br>安装过程中用到的工具和驱动打包：<a href="https://pan.baidu.com/s/1slKVaAp" target="_blank" rel="noopener">Hackintosh/Feya_LH532</a><br>参考链接：<a href="http://osx86.cn/os-x-ei-capitan-10-11-gm1-install.html" target="_blank" rel="noopener">OS X EI Capitan 10.11 GM1 黑苹果懒人版变色龙引导安装教程</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 黑苹果初体验 - 富士通 LH532Date = 2016-09-23 00:00:00Published = trueCategory = LifeTag = ['Hackintosh', '黑苹果']FileLocate = livingFileName = living-hackintosh-lh532hexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/bb50f6df_4c0f_424a_b9b3_04870fa7b35c_untitled.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;高中开始折腾电脑DIY，当然硬件玩不起，只是折腾系统，一开始折腾重装Windows系统，玩腻了就折腾Linux，到后来开始打算折腾Mac。在普通PC上安装苹果的OSX系统（现在叫MacOS）的行为叫做黑苹果（Mackintosh），相反的，苹果自家产品自带的系统叫做白苹果（Mackintosh）。不过安装黑苹果比起Windows和Linux实在是难多了，所以那时候看教程看得一脸懵逼就结束了。&lt;/p&gt;
&lt;p&gt;最近在公司开始正式切换到Mac系统上进行开发工作，但是回到家里就得用WIN10（Fujitsu LH532）进行开发，有个非常头疼的问题，就是Mac上的快捷键和Windows大相径庭，所以又产生了安装黑苹果的想法。看了一周的攻略之后，我迫不及待地开始了。&lt;/p&gt;
    
    </summary>
    
      <category term="Life" scheme="http://kaedea.com/categories/Life/"/>
    
    
      <category term="Hackintosh" scheme="http://kaedea.com/tags/Hackintosh/"/>
    
      <category term="黑苹果" scheme="http://kaedea.com/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 主题 NEXT</title>
    <link href="http://kaedea.com/2016/09/17/front/front-hexo-theme-next/"/>
    <id>http://kaedea.com/2016/09/17/front/front-hexo-theme-next/</id>
    <published>2016-09-17T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/86859476.jpg" alt></p><p>又到了折腾博客主题的时间了，好吧，我承认我用在主题上的时间远比用在写博客上的时间要多多了 (〃ﾉωﾉ)。这次用的是Hexo中最受欢迎的主题（没有之一）的<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NEXT</a>。</p><!-- ColumnList start --><!-- Column 0 start --><a id="more"></a><!-- Column end --><!-- Column 1 start --><!-- Column end --><!-- ColumnList end --><p>在原来主题的基础上，做了以下微调：</p><ol><li>修改 <strong>embed</strong> 标签的样式；</li><li>修改 <strong>Header</strong> 样式，加入头部Banner；</li><li>增加页面加载进度条；</li><li>增加对内部或外部链接的判断，以区别是否打开新TAB；</li><li>增加中英混排时自动增加空格的功能；</li></ol><p>最后，放出修改后的repo：<a href="https://github.com/kaedea/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = Hexo 主题 NEXTDate = 2016-09-17 00:00:00Published = trueCategory = BlogTag = ['Blog', 'Hexo', '主题']FileLocate = frontFileName = front-hexo-theme-nexthexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/86859476.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;又到了折腾博客主题的时间了，好吧，我承认我用在主题上的时间远比用在写博客上的时间要多多了 (〃ﾉωﾉ)。这次用的是Hexo中最受欢迎的主题（没有之一）的&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NEXT&lt;/a&gt;。&lt;/p&gt;
&lt;!-- ColumnList start --&gt;
&lt;!-- Column 0 start --&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://kaedea.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://kaedea.com/tags/Hexo/"/>
    
      <category term="主题" scheme="http://kaedea.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计一个框架化框架 Frontia</title>
    <link href="http://kaedea.com/2016/07/10/android-dynamical-loading-08-satrt-frontia/"/>
    <id>http://kaedea.com/2016/07/10/android-dynamical-loading-08-satrt-frontia/</id>
    <published>2016-07-10T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.984Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/4df27cf7_e064_4741_ae49_f4bca8a82724_untitled.png" alt></p><p>结合动态加载系列文章的分析，现在开始设计并开发一个Android的插件化框架，命名为Frontia。Frontia有“前端”的意思，寓意着Android插件能像前端开发那样动态发版，同时，这一词出自Macross动画系列，有“繁星”的意思，“我们的征途是星辰大海 KIRA!!(&lt;ゝω·)☆”。</p><a id="more"></a><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul><li>Author : <a href="https://github.com/kaedea" target="_blank" rel="noopener">Kaede</a></li><li>Index : <a href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index">ANDROID动态加载系列</a></li><li>GitHub : <a href="https://github.com/kaedea/android-dynamical-loading" target="_blank" rel="noopener">kaedea/android-dynamical-loading</a></li></ul><p>Frontia是一个Android的插件化框架（基于ClassLoader的动态加载技术），相比其他开源项目，Frontia 的特点是扩展性强，更加专注于插件的下载、更新、安装、管理，以及插件和宿主之间的交互。在深入介绍Frontia之前，我们先想想开发一个插件化框架需要考虑的问题有哪些。</p><h2 id="满足多种业务需求的插件"><a href="#满足多种业务需求的插件" class="headerlink" title="满足多种业务需求的插件"></a>满足多种业务需求的插件</h2><p>现在的插件化需求有许多花样，首先，有的只需要将一些特定的类（或者接口的实现类）插件化，比如一些游戏的SDK，需要把登录功能和支付功能的实现插件化，这样SDK就能实现动态升级。其次，有一些业务需要将so库给做成插件化，因为一些so库需要同时内置多个CPU类型（x86/arm64等）的版本，所以会占用非常可观的体积，如果这些so库并不是核心的业务，完全可以做成插件，等到需要的时候再动态加载。再则，也有一些相对独立的业务需要独立升级，而不希望随着APP一起发版。比如“游戏广场”这样的一个业务，APP只提供一个入口启动游戏广场，启动后接下来就不管了，这样的业务可以做成插件，插件可以动态升级（游戏广场可以自由设计自己的界面，甚至增加新的页面），也可以在多个APP之间使用同一插件业务（许多APP都有游戏广场的推广业务）。<br>考虑到种种需求，我们的插件有时只需要加载一些普通的类，有时候需要加载res资源，有时候需要加载so库，有时候需要加载新的组件类（Activity、Service等）甚至调用宿主APP的某些功能（比如获取用户账号信息）。因此，我们的插件化框架在处理插件加载的具体过程时，应该能够灵活地扩展，以满足以上以及将来的各种插件需求。</p><h2 id="插件的更新策略"><a href="#插件的更新策略" class="headerlink" title="插件的更新策略"></a>插件的更新策略</h2><p>除了处理插件的加载问题外，插件化框架还需要处理插件的更新问题，要不然插件化开发就没有意义了。加载插件前，我们需要从服务器下载插件，或者判断是否需要从服务器下载新的插件版本，下载新版本插件失败的时候，我们有又需要判断本地是否有可用的旧版本。因此，插件化框架需要提供一个完善的插件更新策略，以从服务器的插件版本列表和本地的缓存插件版本列表中，挑选出最佳的插件版本（目标插件）。<br>当我们插件的某个版本出现严重问题的时候，我们希望所有的下载过这个版本的插件的APP都要抛弃这个插件，所以插件化框架需要有“及时吊销”功能。当我们插件的最新版本更新了某些重要的功能，我们希望所有的APP都立刻升级到这个插件版本，如果下载最新版本插件失败，需要重新下载或者直接抛弃插件，而不能使用旧版本的插件，也就是说框架需要“强制升级”功能。</p><h2 id="插件的安装策略"><a href="#插件的安装策略" class="headerlink" title="插件的安装策略"></a>插件的安装策略</h2><p>同一个版本的插件只需要下载一次就可以了，不能重复下载。插件化框架需要将下载下来的插件需要存放到指定的目录（我们可以把这个过程当作是“安装插件”），以便于知道当前APP已经安装了哪些插件，以及这些插件有哪些版本，这样我们才可以判断需不需要从服务器下载新版本的插件。<br>同时，存放在本地文件系统上的插件是不安全的，可能被其他人恶意修改，但插件被加载进宿主APP后，它就是APP程序的一部分，可以访问APP的所有内存数据，插件化框架还需要提供对本地已安装插件的安全校验功能。</p><h2 id="插件投入生产前需要解决的问题"><a href="#插件投入生产前需要解决的问题" class="headerlink" title="插件投入生产前需要解决的问题"></a>插件投入生产前需要解决的问题</h2><p>上面谈到的问题大致可以归类成插件的更新、安装以及加载问题，这些都是插件化框架应该解决的基本问题。当然除了这些问题之外，在将插件化开发引入实际生产的项目中的时候，还有一些问题不得不考虑，比如在开发插件的时候如何快捷地调试和构建插件，当插件出现BUG的时候如何快速定位问题（因为一个插件的BUG可能是由“具体的设备型号 + 具体的宿主APP版本号 + 具体的插件版本号”导致的，这也是插件化开发的诟病，尽量不要吧频繁变动的业务插件化），如何做好数据上报统计以评估插件的工作效果，当然，必不可少的，我们还需要一个可靠的服务器来托管我们插件（理想的情景是，我们调试完把代码推到构建系统，构建系统构建完把插件入库并把插件的版本信息上传到服务器，服务器更新新插件版本的可用信息，整个过程不需要手动操作）。</p><p>类似之前谈到的Android动态加载技术需要解决的两个主要问题，插件化开发投入生产需要解决的问题大致可归纳如下：</p><ul><li>插件的更新、安装、加载策略；</li><li>插件的安全性校验；</li><li>插件与宿主的通讯（互调）方式，甚至插件间互相调用的方式；</li><li>插件调试和构建的方法；</li><li>出现BUG时定位问题的方法；</li><li>插件数据统计；</li><li>插件托管的服务器（插件的持续集成）；</li></ul><p>一言以蔽之，插件化开发不仅仅需要解决一个开发框架的问题，从整体上来看更像是需要解决一个开发平台的问题，除了解决代码的问题（粗体部分），还需解决生产工具或者效率的问题。</p><p>Frontia项目致力于解决以上问题，最后，放上项目的地址：<a href="https://github.com/kaedea/android-dynamical-loading/tree/develop/android-frontia" target="_blank" rel="noopener">android-frontia</a> 。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 设计一个框架化框架 FrontiaDate = 2016-07-10 00:00:00Published = trueCategory = AndroidTag = ['Android', '动态化', 'Frontia']FileLocate = FileName = android-dynamical-loading-08-satrt-frontiahexo.comments = truehexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/4df27cf7_e064_4741_ae49_f4bca8a82724_untitled.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;结合动态加载系列文章的分析，现在开始设计并开发一个Android的插件化框架，命名为Frontia。Frontia有“前端”的意思，寓意着Android插件能像前端开发那样动态发版，同时，这一词出自Macross动画系列，有“繁星”的意思，“我们的征途是星辰大海 KIRA!!(&amp;lt;ゝω·)☆”。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态化" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    
      <category term="Frontia" scheme="http://kaedea.com/tags/Frontia/"/>
    
  </entry>
  
  <entry>
    <title>自动给你的博客的中英文间加上空格</title>
    <link href="http://kaedea.com/2016/06/26/front-auto-space/"/>
    <id>http://kaedea.com/2016/06/26/front-auto-space/</id>
    <published>2016-06-26T00:00:00.000Z</published>
    <updated>2021-10-22T09:55:05.988Z</updated>
    
    <content type="html"><![CDATA[<!-- draft![](/assets/09924d84_d08c_4599_9470_492271d8f6b9_untitled.png)--><p>关于“是否应该在中文和英文之间加上空格”的争论在 <code>知乎</code> 上的争论历来已久，我本喜欢加上空格，只是对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。<br><a id="more"></a></p><blockquote><p>漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。</p></blockquote><p>吓得我赶紧加上空格了。 (〃ﾉωﾉ)</p><h2 id="自动加空格的工具-pangu-js"><a href="#自动加空格的工具-pangu-js" class="headerlink" title="自动加空格的工具 pangu.js"></a>自动加空格的工具 <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a></h2><p><a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a> 是一个综合的开源项目，包括了各种平台的“自动加空格”的工具（库），比如浏览器插件、Java、Object-C、Ruby等。比如我自己，需要用在自己的博客上，所以选择了JavaScript。</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>1、先在你的网页里引入以下JS文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/pangu/3.2.1/pangu.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>2、然后在适当的时刻（比如加载完网页的时候）调用以下语句即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script pangu.spacingPage();</span><br></pre></td></tr></table></figure><p>当然 <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a> 还有其他多种用法，具体使用方式请自行参考GitHub项目里的使用教程。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'6871ebd'Title = 自动给你的博客的中英文间加上空格Date = 2016-06-26 00:00:00Published = trueCategory = BlogTag = ['JavaScript', '中文排版', 'Blog']FileLocate = FileName = front-auto-spacehexo.comments = truehexo.metaAlignment = centerhexo.autoThumbnailImage = falsehexo.thumbnailImagePosition = "right"hexo.thumbnailImage = /assets/09924d84_d08c_4599_9470_492271d8f6b9_untitled.png-->]]></content>
    
    <summary type="html">
    
      &lt;!-- draft

![](/assets/09924d84_d08c_4599_9470_492271d8f6b9_untitled.png)

--&gt;
&lt;p&gt;关于“是否应该在中文和英文之间加上空格”的争论在 &lt;code&gt;知乎&lt;/code&gt; 上的争论历来已久，我本喜欢加上空格，只是对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。&lt;br&gt;
    
    </summary>
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="JavaScript" scheme="http://kaedea.com/tags/JavaScript/"/>
    
      <category term="中文排版" scheme="http://kaedea.com/tags/%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88/"/>
    
      <category term="Blog" scheme="http://kaedea.com/tags/Blog/"/>
    
  </entry>
  
</feed>
