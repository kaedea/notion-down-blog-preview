<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kaede Akatsuki</title>
  
  <subtitle>中二病也要开发 Android</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kaedea.com/"/>
  <updated>2021-08-25T12:01:00.853Z</updated>
  <id>http://kaedea.com/</id>
  
  <author>
    <name>Kaede Akatsuki</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android App 电量统计原理与优化</title>
    <link href="http://kaedea.com/2021/08/14/android-apm-battery-stats-opt/"/>
    <id>http://kaedea.com/2021/08/14/android-apm-battery-stats-opt/</id>
    <published>2021-08-14T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.853Z</updated>
    
    <content type="html"><![CDATA[<!-- changelog2021-07-27修订 2Add: 1. 项目使用效果2021-07-21修订 1Add: 1. 拓展阅读2021-07-20初稿--><!-- draft1. 背景1. 耗电问题表现1. 耗电统计原理1. 计算公式1. Android 硬件模块电量统计    1. BatteryStatsService1. Matrix BatteryCanary    1. ProcStat1. 线程池1. UI 线程、Looper 线程    1. EventSlice    1. StackTrace1. 案例1. 其他耗电指标1. 拓展阅读    1. Benchmarks1. 竞品--><h2 id="App-“耗电综合征”"><a href="#App-“耗电综合征”" class="headerlink" title="App “耗电综合征”"></a>App “耗电综合征”</h2><p>当我们说一个 App 耗电的时候我们在说什么？</p><p>我们可能是指 App 吃 CPU 导致系统掉电快，也可能是在说系统告警 App 后台扫描频繁消耗电量，还可能是在说使用 App 时手机发烫严重…… 是的，相对于 Crash、ANR 等常见的 APM 指标，Android App 电量优化更像是一个综合性的问题。</p><p>一方面，造成 App 耗电的原因是多种多样的，比如 CPU/GPU Load、屏幕、传感器以及其他硬件开销等，每个分类的排查思路是大相径庭的，再加上 AOSP 没有 “官方” 的耗电异常检测框架，各个 OEM 厂商自家系统对 App 耗电的监控方案又各不相同（且没有充分的公开文档），所以检测方案需要结合具体 App 项目实际和用户反馈状况，针对具体的耗电类型做出考量和取舍。另一方面，耗电问题也经常是比较 “主观” 的，比如用户感觉 App 新版本掉电比较快了，或者在户外气温比较高的环境使用 App 时感觉设备发烫了，又或只是单纯的因为使用时间变长了导致系统耗电排行靠前了等等，这些通常都是一些比较微妙的主观感受，难以量化问题。</p><p>因此，** 如何检测各种类型的耗电异常，以及如何提炼耗电问题的规则（划红线）是优化电量指标的关键所在 **。微信 Android 项目在与 App 耗电异常这项 “疑难杂症” 日常斗智斗勇的过程中，产出了一些比较实用的工具和优化思路。本文针对 Anroid App 的耗电问题，具体分为 “App 电量统计原理”、“耗电异常监控方案”、以及相关的 “优化案例” 三部分进行解析和分享。</p><a id="more"></a><h2 id="App-电量统计原理"><a href="#App-电量统计原理" class="headerlink" title="App 电量统计原理"></a>App 电量统计原理</h2><h3 id="电量计算公式"><a href="#电量计算公式" class="headerlink" title="电量计算公式"></a>电量计算公式</h3><p>了解 App 电量统计原理之前，有必要先复习一下电量计算公式：</p><blockquote><p>电量 = 功率 × 时间</p></blockquote><p>其中需要注意一点的是， 功率 = 电压 × 电流。而在数码产品中，元器件一般对电流比较敏感，而电压基本是恒定的，所以我们直接使用电流来代替功率，这也是我们经常说 “毫安时”（mAh）而不说 “千瓦时 / 度”（kWh）的原因。</p><h3 id="Android-硬件模块的电量统计方式"><a href="#Android-硬件模块的电量统计方式" class="headerlink" title="Android 硬件模块的电量统计方式"></a>Android 硬件模块的电量统计方式</h3><p>了解计算公式之后，App 的电量统计思路就比较清晰了：</p><blockquote><p>App 电量 = SUM (模块功率 × 模块时间)</p></blockquote><p>其中模块主要是指 Android 设备的各种硬件模块，主要可以分为以下三类。</p><p><img src="/assets/4dcaf5d8_79f9_40e1_b58f_f5044b852a03_untitled.png" alt=""></p><p>第一类，像  Camera/FlashLight/MediaPlayer/ 一般传感器等之类的模块，其工作功率基本和额定功率保持一致，所以模块电量的计算只需要统计模块的使用时长再乘以额定功率即可。</p><p>第二类，像 Wifi/Mobile/BlueTooth 这类数据模块，其工作功率可以分为几个档位。比如，当手机的 Wifi 信号比较弱的时候，Wifi 模块就必须工作在比较高的功率档位以维持数据链路。所以这类模块的电量计算有点类似于我们日常的电费计算，需要 “阶梯计费”。</p><p>第三类，也是最复杂的模块，CPU 模块除了每一个 CPU Core 需要像数据模块那样阶梯计算电量之外，CPU 的每一个集群（Cluster，一般一个集群包含一个或多个规格相同的 Core）也有额外的耗电，此外整个 CPU 处理器芯片也有功耗。简单计算的话，CPU 电量 = SUM (各核心功耗) + 各集群（Cluster）功耗 + 芯片功耗 。如果往复杂方向考虑的话，CPU 功耗还要考虑超频以及逻辑运行的信息熵损耗等电量损耗（这方面有兴趣的话可以自行拓展查证，Android 系统 CPU 的电量统计只计算到芯片功耗这一层）。屏幕模块的电量计算就更麻烦了，很难把屏幕功耗合理地分配给各个 App， 因此 Android 系统只是简单地计算 App 屏幕锁（WakeLock）的持有时长，按固定系数增加 App CPU 的统计时长，粗略地把屏幕功耗算进 CPU 里面。</p><p>最后，需要特别注意的是，** 以上提到的各种功率和时间在 Android 系统上的统计都是估算的 **，可想而知最终计算出来的电量数值可能与实际值相差巨大，Facebook 的工程师对此也有所吐槽：<a href="https://github.com/facebookincubator/Battery-Metrics/blob/master/docs/mistrustbatterylevel.md" target="_blank" rel="noopener">Mistrusting OS Level Battery Levels</a>，这点大家心里要有一点概念。</p><h2 id="Android-系统电量统计服务"><a href="#Android-系统电量统计服务" class="headerlink" title="Android 系统电量统计服务"></a>Android 系统电量统计服务</h2><p>Android 系统的电量统计工作，是由一个叫 <strong>BatteryStatsService</strong> 的系统服务完成的。</p><p>先了解一下其中四个比较关键的角色：</p><ol><li>功率：power_profile.xml，Android 系统使用此文件来描述设备各个硬件模块的额定功率，包括上面提到的多档位功率和 CPU 电量算需要到的各种参数值。</li><li>时长：StopWatch &amp; SamplingCounter，其中 StopWatch ⏱  是用来计算 App 各种硬件模块的使用时长，而 SamplingCounter 则是用来采样统计 App 在不同 CPU Core 和不同 CpuFreq 下的工作时长。</li><li>计算：PowerCalculators，每个硬件模块都有一个相应命名的 PowerCalculator 实现，主要是用来完成具体的电量统计算法。</li><li>存储：batterystats.bin，电量统计服务相关数据的持久化文件。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>BatteryStatsService 的工作流程大致可以分为两个部分：时长统计 &amp; 功耗计算。</p><p><img src="/assets/8e770ef6_890e_406f_ba93_69f634d2b753_untitled.png" alt=""></p><h4 id="BatteryStatsService-时长统计流程"><a href="#BatteryStatsService-时长统计流程" class="headerlink" title="BatteryStatsService 时长统计流程"></a>BatteryStatsService 时长统计流程</h4><p>BatteryStatsService 框架的核心是 ta 持有的一个叫 <strong>BatteryStats</strong> 的类，BatteryStats 又持有一个 <strong>Uid []</strong> 数组，每一个 Uid 实例实际上对应一个 App，当我们安装或者卸载 App 的时候，BatteryStats 就会更新相应的 Uid 元素以保持最新的映射关系。同时 BatteryStats 持有一系列的 StopWatch 和 SamplingCounter，当 App 开始使用某些硬件模块的功能时，BatteryStats 就会调用相应 Uid 的 StopWatch 或 SamplingCounter 来统计其硬件使用时长。</p><p>这里以 Wifi 模块来举例：当 App 通过 WifiManager 系统服务调用 Wifi 模块开始扫描的时候，实际上会通过 <code>WifiManager#startScan () --&gt; WifiScanningServiceImp --&gt; BatteryStatsService#noteWifiScanStartedFromSource () --&gt; BatteryStats#noteWifiScanStartedLocked (uid)</code> 等一连串的调用，通知 BatteryStats 开启 App 相应 Uid 的 Wifi 模块的 StopWatch 开始计时。当 App 通过 WifiManager 停止 Wifi 扫描的时候又会通过类似的流程调用 <code>BatteryStats#noteWifiScanStoppedLocked (uid)</code> 结束 StopWatch 的计时，这样一来就通过 StopWatch 完成 App 对 Wifi 模块使用时长的统计。</p><h4 id="BatteryStatsService-功耗计算流程"><a href="#BatteryStatsService-功耗计算流程" class="headerlink" title="BatteryStatsService 功耗计算流程"></a>BatteryStatsService 功耗计算流程</h4><p>具体电量计算方面，BatteryStats 是通过 ta 依赖的一个 <strong>BatteryStatsHelper</strong> 的辅助类来完成的。BatteryStatsHelper 通过组合使用 Uid 里的时长数据、PoweProfile 里的功率数据（power_profile.xml 的解析实例）以及具体各个模块的 PowerCalculator 算法，计算出每一个 App 的综合电量消耗，并把计算结果保存在 <strong>BatterySipper []</strong> 数组里（按计算值从大到小排序）。</p><p>还是以 Wifi 模块来举例：当需要计算 App 电量消耗的时候，BatteryStats 会通过调用 <code>BtteryStatsHelper#refreshStats () --&gt; #processAppUsage ()</code> 来刷新 BatterySipper [] 数组以计算最新的 App 电量消耗数据。而其中 Wifi 模块单独的电量统计就是在 processAppUsage 方法中通过 WifiPowerCalculator 来完成的：Wifi 模块电量 = PowerProfile 预置的 Idle 功率 × Uid 统计的 Wifi Idle 时间 + 上行功率 × 上行时间 + 下行功率 × 下行时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WifiPowerCalculator</span> <span class="keyword">extends</span> <span class="title">PowerCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        app.wifiPowerMah =</span><br><span class="line">                ((idleTime * mIdleCurrentMa) + (txTime * mTxCurrentMa) + (rxTime * mRxCurrentMa))</span><br><span class="line">                / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>作为补充，这里罗列几个 BatteryStatsService 系统服务的应用场景来说明其工作方式。</p><h4 id="Android-系统-App-耗电排行"><a href="#Android-系统-App-耗电排行" class="headerlink" title="Android 系统 App 耗电排行"></a>Android 系统 App 耗电排行</h4><p>通过以上分析，我们其实已经知道 Android 系统 App 耗电排行是通过读取 BatteryStatsHelper 里的 BatterySipper [] 数据来实现排行的。一般情况下，BatteryStats 的统计口径是 <code>STATS_SINCE_CHARGED</code>, 也就距离上次设备充满电到现在的状态。不过个别 OEM 系统上这里的统计细节有所不同，有的 Android 设备系统可以显示最近数天甚至一周以上的 App 的电量统计数据，具体实现细节不得而知，姑且推断是根据 BatteryStatsHelper 自行定制的服务。</p><h4 id="adb-dumpsys-batterystats-amp-adb-bugreport"><a href="#adb-dumpsys-batterystats-amp-adb-bugreport" class="headerlink" title="adb dumpsys batterystats &amp; adb bugreport"></a>adb dumpsys batterystats &amp; adb bugreport</h4><p>或许你已经知道怎么通过 <code>adb dumpsys batterystats</code> 或者 <code>adb bugreport</code> Dump 出系统的电量统计数据，以及如何配合 Battery Historian 工具来分析这些数据，实际上这些 adb 命令都是通过 BatteryStatsService 查询 BatteryStats 里持有的 Uid [] 来获得相应的电量统计数据，具体实现可以参考 <code>com.android.server.am.BatteryStatsService#dump</code>。</p><h4 id="CPU-Load-Usage"><a href="#CPU-Load-Usage" class="headerlink" title="CPU Load/Usage"></a>CPU Load/Usage</h4><p>“CPU Load xx%  yy% zz%” 之类的数据相信大家都或多或少见过，ANR 的 traces.txt、以上的 batterystats 和 bugreport Dump 出来的数据，以及 adb top 命令里都会显示类似的 CPU 负载数据，实际上这个数据也是通过 CPU 模块的统计时长来计算：CPU Load = SUM (App CPU Core 时长时间) / CPU 工作时间。需要注意的是 App CPU 时长是按 CPU Core 为单位分开计算的，所以计算结果完全可能超过 100%，比如一个 8 核心的 CPU 计算结果的理论上限是 800%。</p><h2 id="BatteryCanary"><a href="#BatteryCanary" class="headerlink" title="BatteryCanary"></a>BatteryCanary</h2><p>经过以上分析，我们知道 BatteryStatsService 里已经有比较详细的 App 电量统计数据。不过上帝刚给我们开了一扇窗，转身就把门给拆了。实际上这个系统服务对 App 是隐藏的，也就是说在 App 里我们无法直接访问 BatteryStatsService 里的数据（HealthStats 服务能间接访问一部分数据），不过这也不是说我们完全没有办法。</p><p>** 既然我们已经知道了 Android 系统的调用统计原理，那么用类似的计算方案在 App 内部进行电量统计应该也能得到一个近似解 **。这也是 Matrix BatteryCanary 的核心原理，具体实现大致可以分为两部分：线程监控 &amp; 系统服务调用监控。</p><h3 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h3><p>实际上，我们除了通过 <code>SystemClock.currentThreadTimeMillis ()</code> 来获取当前 Java 线程的工作时间此外，并没有直接的办法能够直接获取 App 所有线程的工作时长和状态，幸运的是 Linux 的 proc 命令可以给我们提供一些帮助。</p><p>Linux 命令 <code>proc/[pid]/stat</code> 和 <code>proc/[pid]/task/[tid]/stat</code> 可以 Dump 当前 App 进程和线程的统计信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat /proc/&lt;mypid&gt;/task/&lt;tid&gt;/<span class="built_in">stat</span></span><br><span class="line">10966 (terycanary.test) S 699 699 0 0 -1 1077952832 6187 0 0 0 22 2 0 0 20 0 17 0 9087400 5414273024 24109 18446744073709551615 421814448128 421814472944 549131058960 0 0 0 4612 1 1073775864 1 0 0 17 7 0 0 0 0 0 421814476800 421814478232 422247952384 549131060923 549131061022 549131061022 549131063262 0</span><br></pre></td></tr></table></figure><p>这里比较关键的数据是 <code>进程 / 线程名</code>、<code>进程 / 线程状态</code>，以及第 13 - 16 位的 <code>utime</code>、<code>stime</code>、<code>cutime</code> 和 <code>cstime</code>。utime 和 stime 分别是进程 / 线程的用户时间和系统时间，而 cutime/cstime 是当前进程等在子进程的时间（在 Android 进程上大都是 0）。实际上我们对这些数据内容也不完全是陌生的，Logcat 里一些线程相关的 syslog 也有类似的输出，如下图所示。</p><p><img src="/assets/19e02336_b567_42a8_8bff_b5b8a9d0f361_untitled.png" alt=""></p><p>在这里有一点需要单独拎出来讲：<strong>utime 和 stime 具体代表什么意义呢？</strong> 我们已经知道它们是表示线程的工作时长，但实际上其单位 jiffy 并不是一个时间的单位，而是一个频率的单位！</p><p>就如你所看到的，上图截图中有个圈起来的线程数据：HZ=100。这个数值代表当前 Linux 系统给进程（具体点说是线程）分配 CPU Slice 资源的周期频率是 100Hz，换句话说就是系统软件中断的频率是每秒 100 次。假如一个周期的这 100 个 CPU Slice 全部分配给某个线程，那么这个线程的 CPU 开销就是 100 Jiffies，共占用 CPU 一个周期的时间 （1 秒）。</p><blockquote><p>Android Linux 上，100 Jiffies ≈ 1 Second</p></blockquote><p>所以我们可以记住一个比较重要的结论：在 Android 系统上，Jiffy 和 Millis 的换算关系大概是 1 比 10。（100 Hz 是一个 Linux 系统的编译参数，在不同的 Linux 版本上这个值可能是不同的。）</p><h3 id="系统服务调用监控"><a href="#系统服务调用监控" class="headerlink" title="系统服务调用监控"></a>系统服务调用监控</h3><p>系统服务调用监控就比较简单了，主要分为 SystemService Hook 和 ASM 插桩两种方案，具体实现大家应该都比较熟悉了，这里不再赘述。不同需要注意的是，SystemService Hook 在不同 Android API Level 上面存在较多的兼容性问题（特别是在新 API Level 的变动上面坑比较多），而 SystemService ASM 经常会插漏一些运行时动态加载的插件。具体生产环境的应用上，以 ASM 为主 Hook 为辅的方案比较合适。</p><h3 id="一些实现细节"><a href="#一些实现细节" class="headerlink" title="一些实现细节"></a>一些实现细节</h3><p>以上提到的监控方案，已经能兜住大部分的 App 耗电监控需要，不过在实际具体项目的实现细节上，依然存在不少的挑战。</p><h4 id="App-状态统计"><a href="#App-状态统计" class="headerlink" title="App 状态统计"></a>App 状态统计</h4><p>电量监控跟其他质量指标监控相比有个不同的地方就是 ta 是一个过程，其他异常比如 Crash / ANR 发生的时候是瞬时的。比如 Crash 发生的时候，可以一并获取 App 的前后台状态再上报，这样我们就能有效区分前台、后台 Crash（这很重要，因为前台 Crash 优先级要高许多）。然而电量上报就不能这么做了，因为我们监控到一个 App 在 10 分钟的统计窗口里出现了耗电异常，当我们上报的时候获取得到 App 状态是后台的，然而 App 完全有可能前面 9 分钟都是前台的，最后 1 分钟才进入了后台，因此这样我们统计出来的状态数据是有失真的。同样，设备充电、亮灭屏等状态也有类似的问题。</p><p><img src="/assets/b1e246bc_f6fe_4a80_b0dd_52814e79bb21_untitled.png" alt=""></p><p>这个问题早期给我们带来不少麻烦，甚至造成一些电量 Bug 交付的乌龙。好在我们很快就发现这个问题并做出了改善：类似 CPU Slice，我们使用一种叫做 Event Slice 的方案来计算一段时间窗口内 App 的状态占比。根据上图，在设备状态发生变化的时候，我们记下每一个 Event 的 Stamp，统计 App 状态时，根据统计窗口的起始时间和结束时间，我们就可以计算出这段时长内 App 每个事件状态的占比。</p><h4 id="线程池问题细分"><a href="#线程池问题细分" class="headerlink" title="线程池问题细分"></a>线程池问题细分</h4><p>通过 procStat 监控到的异常线程，如果其业务相关性比较强的话一般都能很快解决。不过如果出现异常的是线程池之类的线程就比较麻烦了：和上面的状态统计一样，线程出现异常的时候，正在执行的 Runnable 任务，不一定就是真正导致异常的元凶。</p><p>为了解决这个问题，我们设计了一下两种方案：</p><ol><li>Runnable Jiffies 统计：我们给线程池的每一个 TaskRunnable 实例都包裹一层 RunnableWrapper，并在 <code>Wrapper#run</code> 里执行 TaskRunnable 的前后，分别计算当前线程的 Jiffies 差值 Delta，已得到当前  TaskRunnable 的实际 Jiffies 开销。</li><li>Task Slice 方案：在方案 1 的基础上，我们已经得到每个线程池线程上执行的 TaskRunnable Jiffies 信息，然后应用类似 Event Slice 的统计方案，我们就能得出每个线程池线程某一段出现异常的 Jiffies Delta 窗口里，执行的 TaskRunnable 的占比信息，从而推断出哪些 TaskRunnable 是导致线程耗电的元凶。</li></ol><h4 id="线程异常现场"><a href="#线程异常现场" class="headerlink" title="线程异常现场"></a>线程异常现场</h4><p>通过线程 Jiffies 和线程 State，我们可以监控到某些线程出现了异常，比如 App 待机的时候线程一直处于 Running 状态（State R）并且持续消耗 Jiffies。毋庸置疑，我们已经发现了 App 耗电异常的原因和问题现场。这时候新的挑战出现了，虽然我们已经足够确信目标线程出现耗电异常，但是这类有问题的线程并不是一直有 Log 输出的（特别是处于死循环状态的线程），缺乏现场日志，我们分析和优化耗电异常的效率将大大降低。</p><p>虽然我们很快想到了用 Thread 相关的 API 来 Dump Java 线程异常现场的 StackTrace，但是对于 Native 线程却是一丁点儿办法都没有。无奈之下，一开始我们也只能用一些比较笨的办法来处理，比如 Review 可疑代码并加多 Log，甚至通过 tkill/tgkill 的方式来主动触发 Native 线程 Crash 从而把 StackTrace Dump 出来。后来我们发现一种成本比较低的方案：通过主动模拟 ANR 触发系统 Dump 线程 Trace Log  从而获取所有线程的 StackTrace（目前由 Matrix AnrDumper 工具实现）。</p><p>以上陈述的各种方案，已经帮我们项目监控到了大部分的耗电问题，以下列举一些优化案例作为分享。</p><h2 id="案例分享"><a href="#案例分享" class="headerlink" title="案例分享"></a>案例分享</h2><p>很多看似复杂的耗电异常问题（特别是高耗），最终排查下来都是一些看似简单的 “低级错误” 导致，如果一个个单独拎出来讲解的话，总有一股 “走近科学” 的味道，所以这里聚合成几类问题分别进行讲解。</p><h3 id="长时、频繁任务"><a href="#长时、频繁任务" class="headerlink" title="长时、频繁任务"></a>长时、频繁任务</h3><p>相信不少人同我一样有一个朴素的开发观念，那就是对于一个长时任务就应该把 ta 丢进 Worker 线程、线程池里去执行。换句话说，只要不在 UI 线程执行，大家对 ta 性能开销的敏感度或者心理预期就大大降低了。然而，这类长时任务，或者频繁的短时任务有时候也会造成 App 后台 CPU 负载异常。</p><p>比如微信部分为了优化用户体验的 PreLoad 逻辑（Emoji 资源、朋友圈资源等），会直接被丢进线程池里执行，有时候 App 已经待机好长一段时间了，相关的预载逻辑还在执行，从而导致系统 CPU Load 异常告警。又比如，有个古老的轻量 IO 逻辑为了方便是直接在 UI 线程里执行的，后来我们发现这里产生 ANR 了，然后就把这个逻辑挪到了 Woker 线程里执行并解决了 ANR，然而这个逻辑实际上在极端的条件下是因为出现死循环才导致的 ANR，这样简单的处理方案会导致 Woker 线程进入死循环并且不宜被发现。</p><p>类似的 “低级错误” 还有好多，这给我们提供一个深刻的教训：** 运行时间在分钟量级以上的任务都应该考虑待机耗电问题，而不是简单地异步化就完事了 **。在这方面，BatteryCanary 提供了电量相关的生命周期接口和事件回调，用于在 App 进入待机后的某个恰当时机来退出长时、频繁任务。</p><h3 id="前后台判断"><a href="#前后台判断" class="headerlink" title="前后台判断"></a>前后台判断</h3><p>Android App 耗电异常发发生后台的状态的案例比较多，实际上 Android 系统的性能优化也一直朝着收敛 App 后台活动范围的方向发展，所以我们有必要在 App 进入后台并持续一段适合的时间后，执行一些退出和析构逻辑，并严格限制后台 Task。不幸的是，我们也在这里翻车了。</p><p>早期微信小程序框架并没有提供 ** 持续定位 ** 的接口，部分需要持续定位的小程序则是通过循环调用单次定位接口来实现目的，而有时候定位服务需要通过 Wifi 或者 Bluetooth 来实现辅助定位，所以一旦小程序进入后台后还在循环调用单次定位接口来实现实时导航等服务时，我们不仅获取了一堆系统的后台 GPS/Wifi/Bluetoosh 扫描异常告警，还成功把 App 推上系统耗电排行榜的宝座。</p><p>另一次翻车则与播放器有关：微信的视频播放有个自动播放的逻辑，当视频 Prepared 完毕就可以自动 Loop 播放，当 App 进入后台时候停止视频播放，然而这里有个遗留的代码缺陷：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (player.isPrepared) &#123;</span><br><span class="line">        player.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你已经看出问题了，当 App 进入后台时，如果 Player 还没有完成 Prepare，那么 ta 将彻底失去 stop 的机会，当缓冲完毕的时候，播放器就会一直在后台 Loop 播放了。</p><p>此外，Android App 前后台状态的判断有很多种办法，这里必须指出的是部分方案是有版本兼容性问题的，比如有个方案是通过判断 App 自身是否在 <code>ActivityManager#getRunningAppTasks</code> 数组顶部来判断 App 是否在前台，然而 Android L 之后这个 API 只会返回 App 自身相关的 Tasks，也就是说结果会恒为前台，最终导致有些需要通过这个 API 来判断并限制后台活动的任务就会失控。（作为目前比较靠谱的方案，可以考虑通过 <code>ActivityManager.RunningAppProcessInfo#importance</code> 的值来判断 App 前后台状态。）</p><h3 id="Loop-退出逻辑不完备"><a href="#Loop-退出逻辑不完备" class="headerlink" title="Loop 退出逻辑不完备"></a>Loop 退出逻辑不完备</h3><p>Loop 循环控制异常是耗电问题的重灾区。</p><h4 id="while-true"><a href="#while-true" class="headerlink" title="while(true) {}"></a>while(true) {}</h4><p>有些算法实现使用 <code>while (true) {}</code> 之类的 Loop 结构来完成通常会比较简单和直观，然而这里也是比较容易翻车的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//case 1: 退出判断不在当前 while block 内部</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (shouldExit ()) &#123;<span class="keyword">break</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case 2: 有限状态机 + 责任链</span></span><br><span class="line"><span class="keyword">var</span> playerStatus = int (status)</span><br><span class="line"><span class="keyword">val</span> consumers = listOf (consumers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="keyword">for</span> (<span class="keyword">var</span> cosumer : consumers) &#123;<span class="keyword">if</span> (consumer.accept (playerStatus)) &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Case 1，因为作为 Exit Conditioning 的判断方法 <code>shouldExit ()</code> 不在 while 循环体内部，很容易在后续的代码迭代过程中因为调整了 shouldExit 的实现细节，导致 while block 出现了死循环的破绽。而对于 Case 2，这实际上是微信播放器某个老版本的实现，通过 “状态机 + 责任链” 的模式能有效地解耦播放器各个业务模块的控制逻辑，但是这样的设计实际上也是把 while block 的 Exit Conditioning 挪到了外部的 Consumer 里，容易因为出现某个新添加进来 playerStatus 所有的 consumers 都无法消耗，从而出现 while 死循环。</p><h4 id="Loop-嵌套"><a href="#Loop-嵌套" class="headerlink" title="Loop 嵌套"></a>Loop 嵌套</h4><p>目前 Android 项目中，Java 8 或者 Kotlin 相对 Java 7 的占比还是比较小（特别是规模比较大的项目），因此在处理一些比较复杂的数据结构时，相比起使用新语言特性中 Collection 相关的 “流式编程”，我们更加偏向使用传统 Loop 嵌套的方式来实现数据结构的转化，而且其中往往还伴随着比较严重的 “胶水代码”，这也给 Loop 循环控制埋下了隐患。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop 套娃</span></span><br><span class="line"><span class="keyword">while</span> (condition1) &#123;<span class="keyword">while</span> (condition2) &#123;<span class="keyword">if</span> (exit == <span class="literal">true</span>) &#123;<span class="keyword">break</span> or <span class="keyword">continue</span> or <span class="keyword">return</span>?&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们项目中，就发现不止一处在类似以上代码的 Loop 嵌套结构中，因为 “忘记” 自己当前在哪一层，使用了错误的中断或者退出语句，结果导致了外层或者内层 Loop 死循环的悲剧。</p><h4 id="Loop-Sleep"><a href="#Loop-Sleep" class="headerlink" title="Loop + Sleep"></a>Loop + Sleep</h4><p>我们经常需要周期性地执行某些逻辑，所以我们也写了不少以下结构的代码来实现 Polling 操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop + Sleep = Polling</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doSomething()</span><br><span class="line">        sleep(<span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这样的写法也有不小的隐患：一旦 try-catch 代码块出现了异常，则 Loop 逻辑可能再也没有办法进入预设的 Sleep 状态，结果是还是死循环。令人意想不到的是，除了 Java 外，Native 代码也有类似的 Polling 问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = poll(fds, fdsCount, <span class="number">10</span> * <span class="number">1000L</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现个别机型会因为某些具体未知的原因（比如 App 进入后台因为系统限制 fd 出现了异常）导致 poll 系统调用失败，异常的 poll 调用会立即返回，而不是按照预想的每次 block 住线程 1000ms，最终也导致了 Native 线程出现了死循环。</p><p>以上 Loop 问题产生的原因虽然各不相同，但是结果却 “出奇” 地殊途同归：线程死循环。这是导致 App 出现系统耗电排行 “屠榜” 的重要原因，我综合地将以上所有的 Loop 问题原因归纳为 “Loop 退出逻辑不完备，或者不健壮”。在编写类似 Loop 结构体的时候必须格外谨慎，最好是在 App 进入待机状态后有一个全局退出逻辑来作为兜底冗余。</p><h2 id="使用-BatteryCanary"><a href="#使用-BatteryCanary" class="headerlink" title="使用 BatteryCanary"></a>使用 BatteryCanary</h2><p>当我们发现 App 耗电的时候能做些什么？</p><p>现在，除了像以往一样通过 adb top 查看 App 进程 / 线程异常，或者通过 adb dumpsys batterystats  和 Battery  Historian 查看 App 耗电数据之外，我们还能通过 BatteryCanary 实现 App 耗电问题的检测和线上监控。</p><p>文章最后，简单推广一下 BatteryCanary 的使用方式，主要包括以下两部分。</p><h3 id="Battery-Lifecycle"><a href="#Battery-Lifecycle" class="headerlink" title="Battery Lifecycle"></a>Battery Lifecycle</h3><p><img src="/assets/10481e77_fcba_4e78_89d0_c5b7d55a59bd_untitled.png" alt=""></p><p>BatteryCanary 默认会将一系列与电量相关的生命周期和事件输出到 Log 里，通过过滤 TAG <code>Matrix.battery.LifeCycle</code> 就可以获得相应的日志。</p><h3 id="Battery-电量报告-amp-Thread-Dump"><a href="#Battery-电量报告-amp-Thread-Dump" class="headerlink" title="Battery 电量报告 &amp; Thread Dump"></a>Battery 电量报告 &amp; Thread Dump</h3><p>除了 Battery 生命周期事件之外，BatteryCanary 还会周期性的 Dump 当前 App 的电量统计报告。当出现线程状态以及 Jiffies 开销异常的时候，还会将线程的 StackTrace Dump 出来。</p><p><img src="/assets/e9ea8aee_750b_4298_b2c3_2c6efad5fbaa_untitled.png" alt=""></p><p>以上方某用户反馈的耗电问题为例，可以按照以下流程来排查耗电问题：</p><ol><li>fg=bg, during=86：当前电量报告的统计口径为 App 进入后台 86 分钟的一段时间窗口。</li><li>avg (jffies/min)=6016：这 86 分钟内，当前进程每分钟的 CPU 开销为 6016 Jiffies，根据前面的分析， 6016 Jiffies = 6016 × 10 Millis ≈ 1 Min，也就是说当前进程在后台这一个多小时里，一直占满一个 CPU Core 以上的资源。</li><li>inc_thread_num &amp; cur_thread_num：进程当前一共 175 条线程，统计期间减少了 5 条。</li><li>(~/R) Thread-29 (27479) 5940/510924 jiffies：Top 1 的问题线程是 “Thread-29”，tid 为 27479，统计期间一共消耗 510924 Jiffies（每分钟 5940）。</li><li>scanning：统计期间进程 Bluetooth/Wifi/GPS 调用为 0。</li><li>app_stats：统计期间进程的前后台、充电、亮灭屏等状态。</li></ol><p>根据以上的排查结果，可以发现导致 App 耗电的主要原因是 “Thread-29” 线程在后台期间一直 Running，在电量统计报告的下方也可以看到该线程的 StackTrace Dump，从中可以定位到该线程一直在 mg_mgr_poll 方法中循环…… 至此，后续的工作就简单多了。</p><p><img src="/assets/279c062c_1e96_4d84_8175_b5215c19b5ba_untitled.png" alt=""></p><p>目前，BatteryCanary 作为 Matrix 项目集成的一个插件模块，已经在微信 Android 项目上稳定运行多个版本，并且帮助我们成功定位和优化多个严重的耗电问题，欢迎各位前来食用和反馈：<a href="https://github.com/Tencent/matrix。" target="_blank" rel="noopener">https://github.com/Tencent/matrix。</a></p><hr><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>以下内容为拓展阅读，罗列的数据仅供参考，具体以大家实际测试和使用感受为准。</p><h3 id="Benchmarks"><a href="#Benchmarks" class="headerlink" title="Benchmarks"></a>Benchmarks</h3><p>电量监控本身势必给 App 带来额外的功耗，所以全量应用在线上环境的时候要格外小心。BatteryCanary 框架的监控功耗主要是在系统服务调用（统计 App、Device 状态需要）和 procStat 数据解析这两个方面。</p><p>Pixel 1/Pixel 4/Pixel 5 设备上的测试数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Linux procStat 数据解析</span></span><br><span class="line"><span class="comment"># Benchmark 1. 连续 10000 次 procStat 解析</span></span><br><span class="line">Pixel 1: 耗时均值约 3467 ms，平均每次解析耗时 0.34 ms</span><br><span class="line">Pixel 4: 耗时均值约 1100 ms，平均每次解析耗时 0.11 ms  </span><br><span class="line">Pixel 5: 耗时均值约 1000 ms，平均每次解析耗时 0.10 ms  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 线程池 Task 监控</span></span><br><span class="line"><span class="comment"># 1. 整体额外开销大概在 2% ~ 5%</span></span><br><span class="line"><span class="comment"># 2. 看起来 CPU 比较差、闪存比较老旧的设备上，监控带来的额外消耗平摊下来占比反而比较小</span></span><br><span class="line"><span class="comment"># 3. 线程池的监控 Benchmarks 模拟的是极端状况，在短频、长时的状况下要乐观许多</span></span><br><span class="line"><span class="comment"># Benchmark 2. 线程池串行执行 100 个 Task（100ms），计算开启线程池监控的额外消耗</span></span><br><span class="line">Pixel 1: 耗时对比增量均值约 +4.2%</span><br><span class="line">Pixel 4: 耗时对比增量均值约 +4.7%</span><br><span class="line">Pixel 5: 耗时对比增量均值约 +4.9%</span><br><span class="line"></span><br><span class="line"><span class="comment"># Benchmark 3. 低并发执行 100 个 Task（100ms），计算开启线程池监控的额外消耗</span></span><br><span class="line">Pixel 1: 耗时对比增量均值约 +3.5%</span><br><span class="line">Pixel 4: 耗时对比增量均值约 +5.1%</span><br><span class="line">Pixel 5: 耗时对比增量均值约 +5.0%</span><br><span class="line"></span><br><span class="line"><span class="comment"># Benchmark 4. 高并发执行 100 个 Task（100ms），计算开启线程池监控的额外消耗</span></span><br><span class="line">Pixel 1: 耗时对比增量均值约 +2.0%</span><br><span class="line">Pixel 4: 耗时对比增量均值约 +5.5%</span><br><span class="line">Pixel 5: 耗时对比增量均值约 +5.5%</span><br></pre></td></tr></table></figure><h3 id="Facebook-Battery-Metrics"><a href="#Facebook-Battery-Metrics" class="headerlink" title="Facebook Battery-Metrics"></a>Facebook Battery-Metrics</h3><p>目前 Android 平台电量相关的开源方案并不多，我们只发现 Facebook 有个电量统计相关的开源项目 Battery-Metrics 能满足类似的需求，其基本设计思路与 BatteryCanary 类似，都是模拟 BatteryStatsService 的统计行为来测量 App 的电量消耗。不过 Battery-Metrics 的设计初衷是其工程师不 “信任” Android 系统的耗电报告，因此编写此框架来统计他们自己想要的电量指标，两者在具体实现和数据取舍上的区别比较大。</p><ol><li>BatteryCanary 最核心的功能是通过监控线程异常来定位 App 的耗电 Bug，主要包括线程电量统计、堆栈信息和线程池问题细分等；BatteryMetrics 似乎比较关心 App 整体的耗电，CPU 模块的电量统计只有进程层级的。</li><li>BatteryCanary 通过 Hook、ASM 等手段实现 App 系统服务调用的监控；BatteryMetrics 则是设计一系列调用服务统计的 MetricsCollectors，需要在 App 调用系统服务时显式地调用一下 Collector 进行统计。</li><li>BatteryCanary 默认会监控 App 进入后台后的待机功耗，并统计 App、Device 的状态变化，用来检测用户实际使用感受中耗电比较敏感的场景；BatteryMetrics 则比较偏向线下电量压测，通过一堆  Collectors 收集尽可能多的数据来测试 App 功耗指标。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>[1] Matrix BatteryCanary: <a href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-battery-canary" target="_blank" rel="noopener">https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-battery-canary</a><br>[2] power_profile.xml: <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/res/res/xml/power_profile.xml" target="_blank" rel="noopener">https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/res/res/xml/power_profile.xml</a><br>[3] BatteryStatsHelper: <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java;l=568?q=BatteryStatsHelper" target="_blank" rel="noopener">https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/BatteryStatsHelper.java;l=568?q=BatteryStatsHelper</a><br>[4] Facebook Battery-Metrics: <a href="https://github.com/facebookincubator/Battery-Metrics" target="_blank" rel="noopener">https://github.com/facebookincubator/Battery-Metrics</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = Android App 电量统计原理与优化Date = 2021-08-14Published = trueCategory = AndroidTag = ['Android', 'APM', '电量优化']FileLocate = FileName = android-apm-battery-stats-opthexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;!-- changelog
2021-07-27
修订 2
Add: 

1. 项目使用效果

2021-07-21
修订 1
Add: 

1. 拓展阅读

2021-07-20
初稿
--&gt;

&lt;!-- draft

1. 背景
1. 耗电问题表现
1. 耗电统计原理
1. 计算公式
1. Android 硬件模块电量统计
    1. BatteryStatsService
1. Matrix BatteryCanary
    1. ProcStat
1. 线程池
1. UI 线程、Looper 线程
    1. EventSlice
    1. StackTrace
1. 案例
1. 其他耗电指标
1. 拓展阅读
    1. Benchmarks
1. 竞品

--&gt;


&lt;h2 id=&quot;App-“耗电综合征”&quot;&gt;&lt;a href=&quot;#App-“耗电综合征”&quot; class=&quot;headerlink&quot; title=&quot;App “耗电综合征”&quot;&gt;&lt;/a&gt;App “耗电综合征”&lt;/h2&gt;&lt;p&gt;当我们说一个 App 耗电的时候我们在说什么？&lt;/p&gt;
&lt;p&gt;我们可能是指 App 吃 CPU 导致系统掉电快，也可能是在说系统告警 App 后台扫描频繁消耗电量，还可能是在说使用 App 时手机发烫严重…… 是的，相对于 Crash、ANR 等常见的 APM 指标，Android App 电量优化更像是一个综合性的问题。&lt;/p&gt;
&lt;p&gt;一方面，造成 App 耗电的原因是多种多样的，比如 CPU/GPU Load、屏幕、传感器以及其他硬件开销等，每个分类的排查思路是大相径庭的，再加上 AOSP 没有 “官方” 的耗电异常检测框架，各个 OEM 厂商自家系统对 App 耗电的监控方案又各不相同（且没有充分的公开文档），所以检测方案需要结合具体 App 项目实际和用户反馈状况，针对具体的耗电类型做出考量和取舍。另一方面，耗电问题也经常是比较 “主观” 的，比如用户感觉 App 新版本掉电比较快了，或者在户外气温比较高的环境使用 App 时感觉设备发烫了，又或只是单纯的因为使用时间变长了导致系统耗电排行靠前了等等，这些通常都是一些比较微妙的主观感受，难以量化问题。&lt;/p&gt;
&lt;p&gt;因此，** 如何检测各种类型的耗电异常，以及如何提炼耗电问题的规则（划红线）是优化电量指标的关键所在 **。微信 Android 项目在与 App 耗电异常这项 “疑难杂症” 日常斗智斗勇的过程中，产出了一些比较实用的工具和优化思路。本文针对 Anroid App 的耗电问题，具体分为 “App 电量统计原理”、“耗电异常监控方案”、以及相关的 “优化案例” 三部分进行解析和分享。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="APM" scheme="http://kaedea.com/tags/APM/"/>
    
      <category term="电量优化" scheme="http://kaedea.com/tags/%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>基于 Notion 的笔记写作和博客分享自动化方案</title>
    <link href="http://kaedea.com/2021/05/20/devops/notion-to-markdown-file-automating-solution/"/>
    <id>http://kaedea.com/2021/05/20/devops/notion-to-markdown-file-automating-solution/</id>
    <published>2021-05-20T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fwoodcuts_16.jpg" alt="Page Cover"></p><!-- draft1. 背景1. Notion1. Solution & Workflows1. 流程图    1. refer：[https://github.com/soruly/trace.moe#overview](https://github.com/soruly/trace.moe#overview)1. NotionDown--><p>个人认为，笔记（Note）、写作（Writing）和分享（Share）是 <code>个人知识管理</code> 重要的组成部分。笔记是知识元素，写作是知识汇总，分享是知识升华。固然每个人具体实践的方式会尽不相同，不过大家应该都或多或少能对体会其中存在的一些割裂感：</p><p>其一，笔记存在多端同步编辑的刚需。不过随着云笔记解决方案越来越成熟后，这问题现在已经有许多解决方案。其二，笔记草稿和写作正文之间的同步存在许多机械的地方：同一篇文章经常需要在草稿和正文（终稿）之间来回修订，而大部分情况下这两者的同步是通过复制粘贴和人工比对来完成的，这个过场是写作体验主要的割裂感之一。其三，写作正文完成之后的文章分享（Publish）也是一个麻烦的流程，尽管现在许多静态博客可以通过自动化技术完成部署，不过文章正文内容和部署用的 MarkDown 源文件之间的数据同步也是个非常头疼的事情：如果正文和 MD 文件分开处理，两者之间只能手动同步；如果直接用 MD 文件来写正文，又不得不面临现在多数云笔记糟糕的 MD 文件编辑体验（而且 MD 文件能否导出还是个未知数）；如果干脆使用 gitbook 之类的方案来编辑 MD 文件，那基于 git 的笔记云同步方案体验也不会好到哪。</p><p>自从改用静态博客代替 WordPress 来发表自己的文章、文档后，我不得已采用” 云笔记写草稿，MD 文件保存文章正文，手动在草稿和正文之间同步 “这样的 <code>原始</code> 的写作方案，以上说的几种割裂感也是一直以来我感到非常困扰的地方。</p><p>几番苦寻更好的云笔记体验方案，未果。直到 ta 的出现：<code>Notion</code> 。</p><a id="more"></a><h2 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h2><p><a href="http://notion.so" target="_blank" rel="noopener">Notion</a> 是一款时下比较流行的云笔记服务，虽然上线比较晚，不过 ta 却是众多云笔记里面” 最靓的仔 “。基于巧妙和独特的文本元素关系设计，Notion 可以将你的 Notes、Project Tasks / Plans、Doc / Wikis 等统统整合起来（还提供许多优秀的 Template 以满足不同的文档需要），在 ta 身上我看到了知识管理和项目管理的 “大一统” 的希望。</p><p>简单来说，Notion 抛弃了传统以段落（paragraph）为原子单位的做法，而是将所有的一切都当做 Block（是 Everything is Block）。一段文本是一个 TextBlock，一张图片也是一个 ImageBlock，Block 之间可以随意移动和嵌套。同时 Notion Block 被巧妙地设计成组合模式：一个 Block 可以是单一的 Block 也可以是 BlockGroup。这使得 Notion 可以满足几乎所有的文本关系，一片文章本身就是一个 PageBlock，PageBlock 即可以包含各种类型 Block 也可以包含 BlockGroup（用来存放 Table、Columns 等文本组），甚至文章本身就是一个 BlockGroup（类似于 Folder，用于存放一组子文章）。此外，Notion 的强大之处还在于 ta 提供了 CollectionBlock（可以认为是一个简化的 Excel），配合相关的 Notion APIs 我们甚至可以把其当做一个数据库来使用。</p><p>鉴于 Notion 优秀的多端同步服务和灵活的文本存储功能，我从开始接触到 ta 的时候就产生了 “基于 Notion 优化一下自己的知识管理方案” 的想法。不过眼下有两个问题还需进一步观察：其一， Notion 一开始是收费的（而且不便宜），我担心收益出现边际效应，成本不可控；其二，Notion 并没有 Official APIs，这会影响基于 Notion 的二次开发的稳定性，而稳定性又是自动化实践里非常重要的考量。</p><p>随着 Notion 开放免费的个人账号（Personal Plan）和官方 APIs 计划的展开，这些顾虑都再也不是问题。</p><h2 id="Solution-amp-Workflows"><a href="#Solution-amp-Workflows" class="headerlink" title="Solution &amp; Workflows"></a>Solution &amp; Workflows</h2><p>如何优化自己现有的知识管理方案呢，我的基本设想是这样的：</p><ol><li>基于 Notion 写作，所有的文本材料和源数据都统一放在 Notion 上面同步，避免 “冗余写作”。</li><li>使用自动化手段（DevOps）从 Notion 中导出指定笔记的 MD 文件，解决笔记和写作正文之间的割裂感：源文件依然可以保留各种草稿、标注和评论等内容，导出的 MD 文件则根据配置只生成指定的正文内容。</li><li>同样使用自动化手段导出需要分享的 Notion 文章，自动部署到 Hexo 等静态博客。</li></ol><p>如果有需要，作为兜底策略可以定期导出 Notion 全部笔记数据并做好保存和版本控制，从而弥补 Notion 付费才能使用的历史记录功能和为需要从 Notion 迁移数据这种状况做准备（尝试过云笔记数据迁移的朋友应该知道这是什么考量）。</p><p>工作流程示意图如下：</p><p><img src="/assets/notiondown_gong_zuo_liu_cheng_shi_yi_tu_notiondown.png" alt="NotionDown 工作流程示意图"></p><h2 id="NotionDown-Project"><a href="#NotionDown-Project" class="headerlink" title="NotionDown Project"></a>NotionDown Project</h2><p>基于 CAP 编程原则，能复制的代码绝不自己写，一开始我抱着侥幸的心态去 GitHub 上面搜索，还真让我找到了类似的工程 <a href="https://github.com/nategadzhi/notoma" target="_blank" rel="noopener">notoma</a>。不过项目还处于 WIP  状态，等了快一年作者还没有什么动作，Demo 也是处于无法运行的状态，所以我索性自己动手好了。</p><p>自己写一个 3rd-party 的 Notion APIs 不太现实，好在同样的 GitHub 上面已经有先驱做了类似的项目 <a href="https://github.com/jamalex/notion-py" target="_blank" rel="noopener">notion-py</a>，相比之下这个项目的完成度已经非常高了（目前唯一的遗憾就是尚未支持 Notion private 笔记的访问，且项目开发文档有限）。</p><p>基于 notion-py 我写了一个用来支撑自己知识管理的 Notion 笔记导出项目 <a href="https://github.com/kaedea/notion-down" target="_blank" rel="noopener">notion-down</a>，主要用来自动从云笔记导出 MD 文件和部署博客（配合 circleci + 静态博客）。</p><p>NotionDown 的主要功能如下：</p><ol><li>统一在 Notion 平台上编辑笔记（集大成）。</li><li>基于 Notion 笔记 + 相应的编译配置，解析所需的 MD 文件（必须支持图片配置）。</li><li>根据配置将需要 Publish 的文章自动部署指定的静态博客（Hexo）。</li><li>相关配套的集成功能：图床配置，自定义短代码（如生成的文章内容按渠道配置动态调整），中英混排优化（pangu），拼写检查（双拼用户刚需）。</li></ol><p>如此一来，以后岂不是可以专心写作了？🤣<del>（鬼咧，正经 Bloger 谁写文章啊，不都是在折腾博客主题吗。）</del></p><h2 id="Substitute"><a href="#Substitute" class="headerlink" title="Substitute"></a>Substitute</h2><p>如果只是需要自动把 Notion 上面的笔记部署到静态博客，我这发现一个更简单的解决方案：<a href="https://chenhuichao.com/c32f80ee1ca84d45aaf63ee170e3c267" target="_blank" rel="noopener">Notion + GatsbyJs + Netlify 极致的博客体验</a>。</p><p>其基本思路是通过 Netlify 作为 Trigger 触发 GatsbyJs 插件服务读取 Notion 笔记数据，并存放到 Gatsby 平台，最终通过 Gatsby 提供的博客服务展示博客内容。有兴趣可以了解一下 <a href="https://www.gatsbyjs.com/" target="_blank" rel="noopener">Gatsby</a>，这套方案可以节省 circleci 和静态博客 generating 等不少中间流程。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 基于 Notion 的笔记写作和博客分享自动化方案Date = 2021-05-20Published = trueCategory = DevOpsTag = ['Notion', '知识管理', 'NotionDown']FileLocate = devopsFileName = notion-to-markdown-file-automating-solutionhexo.comments = false-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.notion.so/image/https%3A%252F%252Fwww.notion.so%252Fimages%252Fpage-cover%252Fwoodcuts_16.jpg&quot; alt=&quot;Page Cover&quot;&gt;&lt;/p&gt;
&lt;!-- draft

1. 背景
1. Notion
1. Solution &amp; Workflows
1. 流程图
    1. refer：[https://github.com/soruly/trace.moe#overview](https://github.com/soruly/trace.moe#overview)
1. NotionDown

--&gt;

&lt;p&gt;个人认为，笔记（Note）、写作（Writing）和分享（Share）是 &lt;code&gt;个人知识管理&lt;/code&gt; 重要的组成部分。笔记是知识元素，写作是知识汇总，分享是知识升华。固然每个人具体实践的方式会尽不相同，不过大家应该都或多或少能对体会其中存在的一些割裂感：&lt;/p&gt;
&lt;p&gt;其一，笔记存在多端同步编辑的刚需。不过随着云笔记解决方案越来越成熟后，这问题现在已经有许多解决方案。其二，笔记草稿和写作正文之间的同步存在许多机械的地方：同一篇文章经常需要在草稿和正文（终稿）之间来回修订，而大部分情况下这两者的同步是通过复制粘贴和人工比对来完成的，这个过场是写作体验主要的割裂感之一。其三，写作正文完成之后的文章分享（Publish）也是一个麻烦的流程，尽管现在许多静态博客可以通过自动化技术完成部署，不过文章正文内容和部署用的 MarkDown 源文件之间的数据同步也是个非常头疼的事情：如果正文和 MD 文件分开处理，两者之间只能手动同步；如果直接用 MD 文件来写正文，又不得不面临现在多数云笔记糟糕的 MD 文件编辑体验（而且 MD 文件能否导出还是个未知数）；如果干脆使用 gitbook 之类的方案来编辑 MD 文件，那基于 git 的笔记云同步方案体验也不会好到哪。&lt;/p&gt;
&lt;p&gt;自从改用静态博客代替 WordPress 来发表自己的文章、文档后，我不得已采用” 云笔记写草稿，MD 文件保存文章正文，手动在草稿和正文之间同步 “这样的 &lt;code&gt;原始&lt;/code&gt; 的写作方案，以上说的几种割裂感也是一直以来我感到非常困扰的地方。&lt;/p&gt;
&lt;p&gt;几番苦寻更好的云笔记体验方案，未果。直到 ta 的出现：&lt;code&gt;Notion&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="Notion" scheme="http://kaedea.com/tags/Notion/"/>
    
      <category term="知识管理" scheme="http://kaedea.com/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
      <category term="NotionDown" scheme="http://kaedea.com/tags/NotionDown/"/>
    
  </entry>
  
  <entry>
    <title>动态下发 so 库在 Android APK 安装包瘦身方面的应用</title>
    <link href="http://kaedea.com/2018/06/04/android-so-loading-2/"/>
    <id>http://kaedea.com/2018/06/04/android-so-loading-2/</id>
    <published>2018-06-04T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知 Android 加载 so 文件本身就是一种运行时动态加载可执行代码的行为，所以把 so 做成动态下发的没有什么技术风险，不过要把这项技术稳定落地到实际生产项目中还是有不少麻烦的问题。本文根据实际项目经验，分享一些 so 动态化关键技术点和需要避免的坑。</p><a id="more"></a><h2 id="需求价值"><a href="#需求价值" class="headerlink" title="需求价值"></a>需求价值</h2><p>一般来说，越是成熟的 Android 项目，Native 代码的贡献量就越多，以往 APK 体积的主要占比大都是资源文件，不过现在 Native 代码带来的 so 体积占比也很可观了，所以 so 动态化的价值越来越凸显。另一方面，现在支持 arm64 的 Android 项目也越来越多，Google Play 更是强制要求支持 arm64，所以有的 Android 项目需要内置两种甚至以上 abi 支持（比如 B 站客户端项目就同时支持 arm32/arm64/x86 三种，以往还支持 arm5），结果就是 so 体积成倍地上涨。因此，能不能将非主要的 abi 相关的 so 文件动态化，也成为了国内 Android 项目瘦身优化不得不优先考虑的问题。</p><p>此外，一些第三方 SDK 库也自带了不少 so 库（比如腾讯视频 SDK，以前我在接入这个 SDK 的时候，项目本身才 15 MB 体积，而 SDK 自身 so 已经占了 17 MB），或许是为了精简第三方 SDK 带来的体积，或许是为了隔离第三方 SDK 的 API（项目只自身依赖自己定义的业务相关性 API，通过依赖注入的方式访问第三方 SDK 的实现，这样以后更换 SDK 的时候只需要切换依赖注入的形式即可），都需要具体的 so 动态化方案提供技术支撑。</p><h2 id="动态化需要解决的问题"><a href="#动态化需要解决的问题" class="headerlink" title="动态化需要解决的问题"></a>动态化需要解决的问题</h2><p>动态下发 so 库，看上只是把原本就算运行时动态加载的 so 文件，从 APK 安装包里面抽离出来，工作流程上变化不大，但实际上这也是一种完备的插件化技术，也就是说所有插件需要面临问题的问题我们统统需要考虑。我在以往的文章 <a href="http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems">使用 SO 库时要注意的一些问题</a> 中简单谈过 so 动态化的一些问题，不过那些问题也仅仅是在 DEMO 项目里进行挖掘，当具体投入到生产项目中时，面临的挑战要严峻许多。以下我针对实际投产时遇到的问题进行一一分析讲解。</p><h3 id="1-安全性问题"><a href="#1-安全性问题" class="headerlink" title="1. 安全性问题"></a>1. 安全性问题</h3><p>动态化本质上就是运行时加载可执行代码，而所有可执行代码在拷贝安装到安全路径（比如 Android 的 data/data 内部路径）之前，都有被劫持或者破坏的风险。so 动态化也不得不考虑这个安全性问题，最好的做法是每次加载 so 库之前都对其做一次安全性校验。考虑到检查带来的时间成本，可以假设内部路径是无条件可信的（对 Android 来说， data/data 路径在设备 root 情况下是不安全的；而且除了劫持风险外，内部路径文件有可能被应用自身一些不当文件操作给破坏导致插件不完整，因此如果要考虑绝对安全，内部路径插件被加载也必须做安全检查），在 so 文件拷贝到内部路径后单独做一次检查，检查失败就丢弃文件走 fail 逻辑，检查通过就生成一个 flag 文件作为标志，以后通过判断 flag 标志是否存在来决定是否需要执行安全检查。</p><p>怎么校验安全性呢？</p><p>最简单的方式是记录 so 文件的 MD5 或者 CRC 等 Hash 信息（粒度可以是每个单独的 so 文件，或者一批 so 文件的压缩包），将信息内置到 APK 内部或者服务器（如果保存在服务器，客户端需要通过类似 HTTPS 之类的可信通道获取这些数据），通过校验 so 文件 Hash 信息是否一致来确保安全性。不过 Hash 信息一般都会随之 so 文件的变动而改变，每次都需要调整这些数据比较麻烦，我想到的优化方案是 “通过类似 APK 安装包签名校验的方式来确保安全性”：将 so 文件打包成 APK 格式的插件包并使用 Android Keystore 进行签名，将 Keystore 的指纹信息保存在宿主包内部，安全检验环节只需要校验插件包的签名信息是否和内置的指纹信息一致即可。（一种优化的方案是，使用和宿主包一样的 Keystore 给插件包签名，检验环节只需要检查插件和宿主的签名信息是否一致。）</p><p>具体代码实现可以参考一下：<a href="https://github.com/kaedea/android-dynamical-loading/blob/develop/android-frontia/frontia/src/main/java/moe/studio/frontia/PluginInstallerImpl.java#L54" target="_blank" rel="noopener">Installer#checkSafety ()</a>。</p><h3 id="2-版本控制问题"><a href="#2-版本控制问题" class="headerlink" title="2. 版本控制问题"></a>2. 版本控制问题</h3><p>和一般的插件化方案一样，so 动态化也必须处理好版本控制问题：从 APK 里把 so 剥离出来后，我们除了要保证 so 文件的安全性，还要保证 so 文件和依赖它的宿主代码是 API 兼容的（严格上必须要求版本一直，至少做到向前兼容）。如果不需要一般插件那样考虑升降级问题，那也必须做到 so 文件和 APK 包版本是一致的：宿主下载相应版本的 so 文件后，安装到指定的版本路径；宿主版本升级后必须再次下载新版本的 so 文件而不能受到存量旧版本 so 文件的干扰（如果需要做到动态升降级，还需要保留最近一两个版本的存量 so 文件，用于 fallback 逻辑需要）。</p><p>版本控制除了解决插件的 API 兼容问题，还可以实现 “** 即时吊销 **” 策略。设想我们发布了某一个版本宿主 APK 和与之对应的 so 插件包，而这个版本的 so 是有 Bug 的可能导致 APP 崩溃。通过版本控制流程，我们可以在服务端禁用这个版本的 so 插件，从而使客户端进入 “so 插件不可用” 的逻辑，而不至于执行有问题的代码。（如果 so 插件支持动态升降级，还可以配置让客户端强制更新到 fix 插件版本，或者 fallback 回没有问题的存量旧版。）</p><p>从框架设计上，版本控制涉及动态化的 Update 和 Install 两个环节，具体实现代码可以参考 <a href="https://github.com/kaedea/android-dynamical-loading/blob/develop/android-frontia/frontia/src/main/java/moe/studio/frontia/PluginUpdaterImpl.java#L270" target="_blank" rel="noopener">Updater#doUpdatePolicy ()</a> 和 <a href="https://github.com/kaedea/android-dynamical-loading/blob/develop/android-frontia/frontia/src/main/java/moe/studio/frontia/PluginInstallerImpl.java#L201" target="_blank" rel="noopener">Installer#isInstalled ()</a>。</p><h3 id="3-abi-兼容性判断"><a href="#3-abi-兼容性判断" class="headerlink" title="3. abi 兼容性判断"></a>3. abi 兼容性判断</h3><p>abi 兼容性是 so 插件特有的动态化问题，除了考虑 so 插件是否安全之外，我们还需要检查 so 插件包里的 so 库 abi 信息是否与宿主目前运行时的 abi 一致。考虑这么一种情况：宿主 APK 里面内置了 ARM32 和 AMR64 两种 so 文件，同样插件包里也内置这两种 so 文件，当宿主 APK 安装在 ARM32 的设备上，动态加载 so 插件的时候，我们必须只解压并加载相应 AMR32 的 so 插件，对于 ARM64 的设备也是同样的道理。也就是说：同样的 APK 宿主，同样的 so 插件，安装在不同 abi 设备上时，动态化框架的插件处理行为是不一样的。</p><p>这个问题也可是说是版本控制问题上面的一个分支问题。考虑到框架的完备性，框架自身应该能自动设别和处理好 abi 兼容问题，而不是通过 so 插件的打包流程来规避这个问题（容错）。</p><h3 id="4-System-load-加载代码侵入问题"><a href="#4-System-load-加载代码侵入问题" class="headerlink" title="4. System#load 加载代码侵入问题"></a>4. System#load 加载代码侵入问题</h3><p>侵入性问题也是 so 插件特有的问题，这个问题跟 Android Framework 加载 so 库的具体方式有关。Framework 一般不让用户直接通过 dlopen 函数加载动态链接库，而是封装了以下两种加载 so 库的方式（实际上第二种最终也是需要通过  libName 找到具体的 so 文件路径，再通过文件路径加载 so 库，与第一种方式殊途同归）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：通过 so 文件路径加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">load</span> <span class="params">(String filename)</span> </span>&#123;Runtime.getRuntime ().load0 (VMStack.getStackClass1 (), filename);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方式二：通过 so 库名加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadLibrary</span> <span class="params">(String libname)</span> </span>&#123;Runtime.getRuntime ().loadLibrary0 (VMStack.getCallingClassLoader (), libname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下，我们是通过 <code>方式二</code> 以 <code>System.loadLibrary (&quot;xxx&quot;)</code> 的方式来加载 so 文件 <code>libxxx.so</code>，而将 so 文件动态化之后，我们需要将 so 文件安装到内部安全路径，在通过 <code>方式一</code> 以 <code>System.load (&quot;{安全路径}/libxxx.so&quot;)</code> 的方式来加载。这种方案是大部分 so 动态化项目采用的方案，一直以来也都能稳定工作，不过我们也在这个方案里发现了不少麻烦。</p><p>采用 <code>方式一</code> 作为 so 动态化的方案，意味着代码里要写死 <code>System.load (&quot;{安全路径}/libxxx.so&quot;)</code> 。这样一来，首先我们在代码调节阶段就蛋疼了，Native 代码在开发阶段完全可以用传统的内置方案进行调试，在集成阶段再按动态化的方案打包，这也就意味着我们必须频繁地在 <code>方式一</code> 和 <code>方式二</code> 直接来回修改，代码侵入性问题非常严重。然而这还不是最麻烦的问题，对于第三方的 SDK 项目的动态化问题，如果 SDK 项目本身的 so 库是以 <code>方式二</code> 的方式加载（正常的开发方式，对于一些自身就带有 so 文件下载逻辑的 SDK 项目，则很可能是以 <code>方式一</code> 加载的，这种情况下反而问题不大），则可能需要借助 ASM 这种 “曲线救国” 的方式来把 SDK 项目里 so 加载的相关代码修改成 <code>方式一</code>；或者选择在准备好 so 插件之后立即以 <code>方式一</code> 把插件里的所有 so 文件加载进宿主，这样可以兜住插件里 <code>方式二</code> 的加载代码（如果目标 so 库已经加载过一次，则 <code>方式二</code> 加载代码变成一个空实现）。</p><p>解决 so 动态化的 System#load 代码侵入问题，要借鉴 Android 热修复技术方案的思路：按 <code>方式二</code>，即通过 <code>System#loadLibrary (&quot;xxx&quot;)</code> 加载 so 库， Android Framework 会遍历当前上下文的 ClassLoader 实例里的 <a href="https://cs.android.com/android/platform/superproject/+/master:libcore/dalvik/src/main/java/dalvik/system/DexPathList.java;bpv=1;bpt=1;l=80" target="_blank" rel="noopener">nativeLibraryDirectories</a> 数组，在数组里所有的文件路径下查找文件名为 <code>libxxx.so</code> 的文件，所以我们的解决思路就是在安装好 so 插件之后，将其所在的内部安全路径注入到这个 nativeLibraryDirectories 数组里，即可实现通过 <code>方式二</code> 加载。（思路虽然简单清晰，不过 ** 在实际应用中还是有不少问题 **，以来在具体的解决方案中进行详细说明。）</p><p>具体注入代码实现可以参考一下 <a href="https://github.com/Tencent/tinker/blob/dev/tinker-android/tinker-android-lib/src/main/java/com/tencent/tinker/lib/library/TinkerLoadLibrary.java" target="_blank" rel="noopener">TinkerLoadLibrary#installNativeLibraryPath (ClassLoader, File)</a>。以下篇幅 ** 对 so 动态化的方案和具体技术细节给出我们的分析和答案 **。</p><h2 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h2><h3 id="1-系统加载-so-库的工作流程"><a href="#1-系统加载-so-库的工作流程" class="headerlink" title="1. 系统加载 so 库的工作流程"></a>1. 系统加载 so 库的工作流程</h3><p>当我们调用 <code>System#loadLibrary (&quot;xxx&quot;)</code> 后，Android Framework 都干了些了啥？</p><p>简单来说，Android 的 so 加载流程，大致可以分为以下四个环节：</p><ol><li>PMS install：安装 APK 包的时候，PackageManagerService 根据当前设备的 abi 信息，从 APK 包里拷贝相应的 so 文件。</li><li>Native classpath：启动 APP 的时候， Android Framework 创建应用的 ClassLoader 实例，并将当前应用相关的所有 so 文件所在目录注入到当前 ClassLoader 相关字段。</li><li>so loading：调用 System.loadLibrary (“xxx”)， Android Framework 从当前上下文 ClassLoader 实例（或者用户指定）的目录数组里查找并加载名为 libxxx.so 的文件。</li><li>jni calling：调用 so 相关 JNI 方法。</li></ol><p>大致流程示意图如下：</p><p><img src="/assets/so_loading_flow_ee66c324_0375_41c9_a9d4_3643769fc9e9_untitled.png" alt="so loading flow"></p><p>具体流程以及方法调用链这里不做深入讨论，有兴趣这里推荐老罗的 <a href="https://blog.csdn.net/luoshengyang/article/details/8923483" target="_blank" rel="noopener">Dalvik 虚拟机 JNI 方法的注册过程分析</a> 一文。根据这个流程以及上面提到的 “加载代码侵入问题”，按照 <code>System.loadLibrary (&quot;xxx&quot;)</code> 加载代码和 JNI 方法相关类（以下统称 JNI 代码）所在的 ClassLoader 实例不同，so 动态化技术可以分为 “JNI 代码隔离” 和 “JNI 代码内置” 两种解决方案。</p><h3 id="2-JNI-代码隔离方案"><a href="#2-JNI-代码隔离方案" class="headerlink" title="2. JNI 代码隔离方案"></a>2. JNI 代码隔离方案</h3><p><img src="/assets/jni_separated_diagram_a2bb6b5e_bddc_4b24_849b_a353b653fe90_untitled.png" alt="jni-separated diagram"></p><p>顾名思义，就是将涉及到的 JNI 代码拆解到一个独立的模块，一同打包进 so 插件包里。运行时动态加载 so 库的时候，先给 so 插件创建一个插件 ClassLoader，在插件 ClassLoader 内部执行 “so loading” 和 “jni calling”。代码隔离方案的优点是是能够做到插件模块编译隔离，其他模块的代码无法 Reference 插件里面的相关 JNI 方法，不容易干扰 JNI 调用的生命周期，后续维护成本低（这也是一般的插件化方案需要做到的目标）。同时缺点也是非常明显的：根据项目历史包袱的具体情况，** 模块拆解成本可能比动态化改造的收益还大 **。因此，代码隔离方案比较适合新增的 Native 模块，一开始就奔着动态化、延迟加载的方向去。</p><h3 id="3-JNI-代码内置方案"><a href="#3-JNI-代码内置方案" class="headerlink" title="3. JNI 代码内置方案"></a>3. JNI 代码内置方案</h3><p><img src="/assets/jni_builtin_diagram_737587da_0307_42d4_a466_7ba877043376_untitled.png" alt="jni-builtin diagram"></p><p>考虑到拆解 JNI 模块的技术成本，可以考虑先单独把 so 文件单独打包进插件包，JNI 代码保留在宿主代码内部，so 插件共用宿主的 ClassLoader 实例，“so loading” 和 “jni calling” 依旧保留在宿主内部执行。这种 “偷懒” 的 JNI 代码内置方案相对于隔离方案来说改造难度要小得多，相应地由于没有把代码拆解干净，非常容易造成代码污染问题，后续维护成本大。考虑到时间成本，我相信大部分项目只能选择 JNI 代码内置方案。毕竟代码污染问题，可以通过 Code Review、Lint 静态检查等方式来加强 “代码准入” 门槛，缓解问题。</p><p>这里需要特别强调的是，相比于代码隔离方案，JNI 代码内置方案有个特有的技术问题不得不解决：向 <code>nativeLibraryDirectories</code> 注入 so 插件路径带来的 <strong>集合并发修改</strong> 问题。由于 nativeLibraryDirectories 的具体实现是一个 ArrayList 实例，其元素读写操作自身是不保证线程安全的，而我们在 Worker 线程加载 so 插件的环节最后需要将新的 so 文件路径注入到 ArrayList 集合里，如果这时候刚好有另一个线程因为执行 “so loading” 操作而正在遍历集合元素，则会抛出 ConcurrentModificationException（ArrayList 内部实现）。</p><p>解决并发修改问题的思路有两种：</p><blockquote><p>给 “so loading” 和 “so 文件路径注入” 这两种操作同时上锁，锁的实例是 so 相关的 ClassLoader 实例。在所有 “so loading” 操作之前（比如冷启动初始化环节）就预先注入预留好的 so 文件路径。</p></blockquote><p>思路 1 比较简单合理，不过加锁的操作需要 “侵入” 其他所有相关的 <code>System.loadLibrary (&quot;xxx&quot;)</code> 调用，同样容易造成代码污染问题；而思路 2 总感觉有点违反程序设计的一般原则（有些 so 插件可能基本用不上，犯不着在一开始就把其路径注入进来），具体取舍要看项目实际情况。作为补充，思路 1 可以再优化一下：为了避免加锁操作带来的代码污染，可以绕个弯子在编译阶段通过 ASM 手段给自动给所有 “so loading” 上锁；或者在往 ClassLoader 注入路径的时候，不要在原有的 nativeLibraryDirectories 集合上做修改，而是重新 new 一个 List 实例把所有的路径都拷贝到新集合上，最后再整体塞回去 ClassLoader，避免并发修改异常，代价是允许出现并发读脏数据问题（不至于崩溃）。</p><p>我们这两个思路都有尝试，实际投产用的是思路 2，除了污染问题之外，主要是因为下面谈到的 “*<em>dlopen 问题 *</em>”。</p><h3 id="4-处理-dlopen-问题"><a href="#4-处理-dlopen-问题" class="headerlink" title="4. 处理 dlopen 问题"></a>4. 处理 dlopen 问题</h3><p><code>dlopen</code> 是 Native 开发比较熟悉的一个函数，其功能是以指定模式加载指定的动态链接库（使用 dlclose 来卸载打开的库）。实际上，Android Framework 加载 so 库的 <code>System.loadLibrary (&quot;xxx&quot;)</code> 调用，最后也是通过 <code>dlopen</code>  来实现 ，大致的调用路径如下：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sysytem#loadLibrary --&gt; Sysytem#load --&gt; Runtime#nativeLoad</span><br><span class="line">                                           Java  +</span><br><span class="line">                                                 |  Native</span><br><span class="line">                                          dvmLoadNativeCode --&gt; dlopen</span><br></pre></td></tr></table></figure><p>在 NDK 开发中，如果我们有两个 so 文件：<a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 和 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a>（后者是基础库，前者需要依赖后者的 API），xxx 需要动态链接 log，具体体现在 CMake 配置如下：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TARGET_LINK_LIBRARIES(xxx liblog.so)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>则当我们调用 <code>System.loadLibrary (&quot;xxx&quot;)</code> 的时候，Android Framework 会通过上面提到的调用链最终通过 dlopen 加载 <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 文件，并接着通过其依赖信息，自动使用 dlopen 加载 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a>（第二步没有返回 System#load，而是直接在 Native 层面执行）。对于熟悉 Native 开发的同学来说可能司空见惯，但对于只在第三方 SDK 里接触过 so 文件的同学来说，应该不太知道着这一点。然而恰恰正是这一点，给 so 动态化添加了非常大的困难，也让我们在具体的实践项目中吃了很大的亏。</p><p>根据项目经验，现在无论是插件化技术，或者是热修复技术，里面关于动态加载 so 文件的技术方案应该相当成熟，所有的坑都踩得七七八八，就算有没有解决的坑，那应该也不不会严重到影响项目方案可行性的地步。所以一开始，我们把动态化方案主要的风险评估放在模块代码拆解方面，而完全没有担心技术风险。实际上，在 Android N 以前，只要你将 <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 和 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 所在的文件目录路径都注入到当前 ClassLoader 的 nativeLibraryDirectories 里，则在加载 so 插件的时候，这两个文件都能正常被找到。而从 N 开始情况就不一样了： <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 能正常加载，而 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 会出现加载失败错误。具体异常如下：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E&#x2F;ExceptionHandler: Uncaught Exception java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;liblog.so&quot; not found</span><br><span class="line">at java.lang.Runtime.loadLibrary0(Runtime.java:xxx)</span><br><span class="line">at java.lang.System.loadLibrary(System.java:xxx)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其主要原因是，Android Native 用来链接 so 库的 <a href="https://cs.android.com/android/platform/superproject/+/master:bionic/linker/linker.h;bpv=1;bpt=1;l=96?gsn=do_dlopen" target="_blank" rel="noopener">Linker.cpp dlopen 函数</a> 的具体实现变化比较大（主要是引入了 *<em>Namespace 机制 *</em>）：以往的实现里，Linker 会在 ClassLoder 实例的 nativeLibraryDirectories 里的所有路径查找相应的 so 文件；更新之后，Linker 里检索的路径在创建 ClassLoader 实例后就被系统通过 Namespace 机制绑定了，当我们注入新的路径之后，虽然 ClassLoader 里的路径增加了，但是 Linker 里 Namespace 已经绑定的路径集合并没有同步更新，所以出现了 <a href="http://libxxx.so/" target="_blank" rel="noopener">libxxx.so</a> 文件能找到，而 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 找不到的情况。</p><p>至于 Namespace 机制的工作原理了，可以简单认为是一个以 ClassLoader 实例 HashCode 为 Key 的 Map，Native 层通过 ClassLoader 实例获取 Map 里存放的 Value（也就是 so 文件路径集合），具体代码可以参考 <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/com/android/internal/os/ClassLoaderFactory.java;bpv=1;bpt=1;l=111?gsn=createClassLoader" target="_blank" rel="noopener">ClassLoaderFactory#createClassLoader ()</a>。</p><p>我之前琢磨着，Tinker 之所以一直没有把 dlopen 问题暴露出来，主要是因为 Tinker 是热修复框架，补丁插件里需要的  <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 文件，往往在宿主里本来就有内置一份，所以只会导致热修复部分失效，而不会出现 <a href="http://liblog.so/" target="_blank" rel="noopener">liblog.so</a> 找不到问题。而实际上好巧不巧，Tinker 在解决 Android N 的混合编译带来的热修复失败问题时，在往 ClassLoader 注入插件 so 文件路径的时候，会创建一个新的 AndroidNClassLoader 实例用来替换 APP 自身的 ClassLoader，这个替换的操作刚好一并兜住了 dlopen 问题。至于其他插件化框架里为何没有提到这个问题，大概是因为一般适合动态化改造的插件都比较轻量，一般不会有 Native 代码（就算有也往往没有 so 依赖）。</p><p>解决 dlopen 问题主要有以下几个思路：</p><blockquote><p>自定义 System#load，加载 libxxx.so 前，先解析 libxxx.so 的依赖信息，再递归加载其依赖的 so 文件（推荐参考开源方案 SoLoader）。自定义 Linker，完全自己控制 so 文件的检索逻辑（推荐参考开源方案 ReLinker）。类似 Tinker，在合适的时机替换 ClassLoader 实例（这是我们现在投产的方案）。</p></blockquote><h3 id="5-so-依赖分析工具"><a href="#5-so-依赖分析工具" class="headerlink" title="5. so 依赖分析工具"></a>5. so 依赖分析工具</h3><p>上面提到的都是 so 动态化方案中的具体技术难题，剩下的都是一些繁琐的项目问题了（技术债务），比如上面提到的 so 依赖分析。想要把 so 动态化技术应用到 APK 的瘦身项目中来，除了分析哪些 so 文件体积占比比较大之外，最好的做法是将其依赖的所有 so 文件一定挪到插件包里。怎么了解 APK 里所有 so 文件具体的依赖信息呢？根据 so 文件模型手撸代码解析依赖信息固然可行，不过那都是大神干的活，吾等平凡之辈还是选择站在巨人的肩膀上。</p><p>这里推荐一款 Google 开源的 APK 解析工具 <a href="https://github.com/google/android-classyshark" target="_blank" rel="noopener">android-classyshark</a>，除了提供分析 APK dex/so 依赖信息之外，它还提供了 GUI 可视化界面，非常适合快速上手。</p><p><img src="/assets/so_deps_screenshot_a3f75364_3ae6_42e5_9f9f_8e9c375f4ed6_untitled.png" alt="so deps screenshot"></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="相关-JNI-类污染问题"><a href="#相关-JNI-类污染问题" class="headerlink" title="相关 JNI 类污染问题"></a>相关 JNI 类污染问题</h3><p>JNI 方法需要在加载完成相应的 so 库才能正常调用，所以有不少开发选择将 <code>System#loadLibrary (&quot;xxx&quot;)</code> 之类的代码写在 JNI 类的静态代码块，以保证在访问 JNI 之前一定会先完成 so 库加载。不过这实际上非常不 “Best Practice”：一方面，加载 so 原本就属于一种动态化技术，其自身就存在失败的可能性，而且 Native 开发在 Android 上一直存在诸多 “疑难杂症”（推荐参考一下这篇文章 <a href="https://medium.com/keepsafe-engineering/the-perils-of-loading-native-libraries-on-android-befa49dce2db" target="_blank" rel="noopener">The Perils of Loading Native Libraries on Android</a>），最好的办法是考虑所有 so 加载和 JNI 方法调用失败的可能性；另一方面，加载 so 文件本身就有些许性能损耗，在静态代码块中加载会加剧性能问题。最麻烦的是，so 动态化改造之后，如果项目后续开发中有人不小心在 so 插件尚未安装完成之前引用了相关的 JNI 类（比如访问静态方法），哪怕没有发生实际的方法调用，也会导致 JNI 类提前被 ClassLoader 加载，进而提前触发 <code>System#loadLibrary (&quot;xxx&quot;)</code> 逻辑，触发 Crash。</p><p>对于项目已有的 JNI 代码，如果存在 “静态代码块加载 so 问题”，则在改造成动态化的时候，最好将相关加载代码挪出静态代码块，并且增加 so 加载失败时候的 onFail 逻辑，确保所有 so 加载和 JNI 方法调用都不会出现崩溃问题。</p><h3 id="代码后续维护成本"><a href="#代码后续维护成本" class="headerlink" title="代码后续维护成本"></a>代码后续维护成本</h3><p>这也是我目前比较头疼的问题，由于采用了 “JNI 代码内置方案”，没有对 JNI 代码进行编译隔离，非常容易导致后续代码维护过程中，在不正确的生命周期里访问了动态化 so 相关的 JNI 方法，增加 Crash 的风险。</p><p>按照以往的动态化项目经验，“比较稳定，代码变化不大，模块边界比较内聚” 的业务比较适合动态化改造，所以 so 动态化应该优选则这种类型的模块，无论是改造成 “JNI 代码隔离方案”，还是后续的维护成本，都相对要小许多。对于那些代码耦合比较严重，版本迭代非常活跃的业务模块，这是一个典型的 “在高速行驶的火车上更换引擎” 的问题：在动态化改造的同时，FT 代码还在并行迭代，势必会产生许多冲突；对于耦合比较严重的代码，考虑投入产出比的话一般都会选择 “JNI 代码内置” 方案，没有对 JNI 代码进行编译隔离，所以非常容易导致 Crash；改造完成后，后续 FT 代码变动频繁，后续代码维护压力大，而且可能是。</p><p>目前我觉得比较靠谱的处理方案是从项目管理流程上找突破点，主要方向最好还是让 FT 开发自己负责自己模块的动态化改造工作，降低维护成本（考虑到业务团队跟质量团队之间绩效目标的冲突，可能难以推动）。同时需要尽量根据项目的实际需要完善动态化框架以及相关配到的知道文档，降低 FT 的接入成本。作为辅助，还需要给容易产生代码冲突的地方加上相应的静态检查 Case，以便及时发现问题。</p><h3 id="持续集成、部署问题（CI-CD）"><a href="#持续集成、部署问题（CI-CD）" class="headerlink" title="持续集成、部署问题（CI/CD）"></a>持续集成、部署问题（CI/CD）</h3><p>踩了上面一系列的坑，眼看着动态化技术方案完善得七七八八了，实际上 ** 我们才刚刚开始而已 **！</p><p>首先，怎么编译出 so 插件包也是个技术活，这一点要根据具体的项目情况选择合适的方案（我们选用的是 Gradle 插件在 PackageApplication 阶段抽取目标资源文件）。这个是一个 CI 问题，换句话说就是我们需要一个稳定灵活的流水线，用于稳定编译我们指定版本的 so 插件包，而不是每次都通过非常手工、笨拙的方式编包。其次，插件包编译之后，不应该通过手工的方式把文件上传到后端，在填写相关的版本、依赖等配置信息。这是一个 CD 问题（Continuous Deployment），我们应该采用自动化的手段（哪怕只是脚本），在集成阶段之后收集需要的配置信息，自动上传到一个内部环境的管理平台（平台上我们可以查看每个版本的数据），在 Test/Release 阶段根据需要将指定版本的配置信息 “一键导入” 到测试、预发布环境，每个环节上都要尽量避免人工操作。</p><p>因此，从工程管理的角度来看，一个完备的动态化方案，必须涵盖集成、部署、加载框架三个流程的内容，而前面的两点是大多数动态化项目或者技术文章没有提及到的，往往容易被忽视。</p><h3 id="Play-Store-动态代码禁用问题"><a href="#Play-Store-动态代码禁用问题" class="headerlink" title="Play Store 动态代码禁用问题"></a>Play Store 动态代码禁用问题</h3><p>由于一些总所周知的原因，包含有动态代码的 APK 包是无法上传到 Play Store 的。不过实际上 Google 不是禁止动态代码，而是禁止绕过 Play 渠道下发未进过审核的动态代码。经过咨询，通过 Play 提供的 <a href="https://developer.android.com/google/play/expansion-files" target="_blank" rel="noopener">APK 拓展资源包 Expansion Files</a> 服务，可以向客户端下发相关插件资源包，没有政策风险（该服务主要是面向游戏客户端，可以想 APK 客户端下发绑定版本的 “一个主资源包 + 一个 patch 包”，体积上限个 1G。需要说明的是，用户发布特定版本的 APK 之前必须先绑定资源包，一旦发布就无法修改）。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>本文主要是根据我自身实际投产的 Android 动态化项目经验（SDK 插件、动态组件化）以及最近相关的 so 动态化实践，分享一些动态加载 so 库时需要考虑的问题。内容主要包括插件化方案的共同问题、abi 兼容性问题、代码侵入性问题、并发修改问题，以及最重要也最容易忽视的 dlopen 问题。千言万语汇成一句话：</p><blockquote><p>插件有风险，投资须谨慎！</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol><li><a href="http://kaedea.com/2016/06/04/android-dynamical-loading-04-so-problems/">使用 SO 库时要注意的一些问题</a></li><li><a href="http://kaedea.com/2016/07/10/android-dynamical-loading-08-satrt-frontia/">设计一个框架化框架</a></li><li><a href="https://github.com/kaedea/android-dynamical-loading/tree/develop/android-frontia" target="_blank" rel="noopener">Android Frontia</a></li><li><a href="https://blog.csdn.net/luoshengyang/article/details/8923483" target="_blank" rel="noopener">Dalvik 虚拟机 JNI 方法的注册过程分析</a></li><li><a href="https://blog.hike.in/reduce-the-size-of-your-app-by-moving-so-files-to-over-the-air-b51ca9dfdaf2" target="_blank" rel="noopener">Reduce the size of your app by moving .SO files to over-the-air</a></li></ol><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 动态下发 so 库在 Android APK 安装包瘦身方面的应用Date = 2018-06-04Published = trueCategory = AndroidTag = ['动态加载', '插件化', 'so 库']FileLocate = FileName = android-so-loading-2hexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知 Android 加载 so 文件本身就是一种运行时动态加载可执行代码的行为，所以把 so 做成动态下发的没有什么技术风险，不过要把这项技术稳定落地到实际生产项目中还是有不少麻烦的问题。本文根据实际项目经验，分享一些 so 动态化关键技术点和需要避免的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="so 库" scheme="http://kaedea.com/tags/so-%E5%BA%93/"/>
    
      <category term="动态加载" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="插件化" scheme="http://kaedea.com/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>增量静态检查（SPA）在代码合入检查里的应用</title>
    <link href="http://kaedea.com/2018/04/01/devops/incremental-spa/"/>
    <id>http://kaedea.com/2018/04/01/devops/incremental-spa/</id>
    <published>2018-04-01T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<!-- draftAndroid 静态代码扫描效率优化与实践 - 美团[https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA](https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA)1. 背景2. 思考3. 实践4. 结果5. 沉淀6. 总结文章源代码计划：1. 高亮2. 多渠道3. 注释--><p>静态程序分析，是指在不运行程序的情况下分析检查代码里存在的问题。这项技术在代码质量、漏洞扫描等领域有广泛的使用。常见分析工具包括 CheckStyle、Lint、FindBugs 等，也有商用的 Coverity。本文主要讲述为我们在 Android 项目 Merge Request 合入检查里对静态程序分析技术的应用，核心内容是增量代码的静态分析方案，至于各种检查工具的对比筛选，请参考文末提供的 References。</p><a id="more"></a><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol><li>静态程序分析：SPA (Static Program Analysis)，也称静态代码检查、静态扫描、静态检查等（下文统称 “静态检查”）</li><li>代码合入检查：泛指代码提交进主干分支前的一些列检查流程，比较有代表性的是 GitHub PR (Pull Request) 或者 GitLab MR (Merge Request) 合并前进行自动化检查流水线、或者 Code Review 工作（下文统称 “静态检查”，指 MR 合并前的代码检查）</li></ol><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><!-- draft- 提高代码质量- 为 CodeReview 提供支撑- 效率- 历史包袱--><p>微信相关 Android 项目的 DevOps 实践中，我们在合入检查方向已经先后完成了 “需求合法性检查”、“代码冲突检查”、“编译检查”、“编译后 WeTest 自动化 UI 测试” 等检查项目，代码合入检查流程已经比较完善。接下来，我们想尝试在检查流程里加入静态检查环节，看看能不能在 “统一代码风格、提高代码质量” 方面实现一些突破。</p><p>传统上，代码风格检查普遍比较依赖于人工的 Code Review，而 DevOps 实践给我们的经验是，代码格式、一般向代码错误等问题交给工具自动化处理比较合适，人工 Review 的主要目的应该是项目方案评审，以及优秀代码学习，不然的话 Code Review 很可能会变成政治任务，流于形式。因此，我们希望借助静态检查工具，先过滤大部分的一般代码问题，再交由人工进行代码设计方面的 Review 或者学习（注意，本文侧重于静态检查工具的使用，至于具体 Code Review 标准、流程请参考其他文献）。</p><p>静态检查对 Code Review 起到一个支撑作用：</p><blockquote><p>先由静态检查工具过滤常见的错误，工具无法判断的问题可以给出先 warning log，人工 Review 再根据静态检查的 log，重点排查可疑代码。</p></blockquote><p>不过实际应用上，静态检查工具的接入还是存在许多麻烦的问题，特别是对于一些比较成熟、历史包袱严重的项目。一方面，我们相信有不少人已经尝试过使用一些静态检查工具，这些工具在一些小项目上，经常一下子就能跑出一大堆问题，而对于比较庞大的项目，扫描出太多问题基本相当于扫描不出问题，所以我们不得不想办法让检查工具专注于我们关心的问题。另一方面，一般的静态检查工具的分析过程都比较耗时，少则几分钟，一些需要依赖编译产物的工具耗时可能达到十几分钟（类似 Coverity 这种商业功能需要依赖多维度的数据作为数据流分析的依据，耗时更是可能达到小时的级别），这种量级的时间要求对合入检查流程来说是不可接受的，特别是封版前这种时间十分紧迫的版本阶段，更不用说我们的最终目标是希望在用户本地开发代码阶段就把检查流程添加进来，因此在这个流程上我们需要对静态检查工具的性能提一个非常高的要求。</p><p>总结一下问题，现在摆在我们面的主要有 “两个矛盾”：</p><ol><li>静态检查通常会检查出大量的 “陈年老代码” 带来的历史遗留问题，而这些问题大部分没人维护，也不能随意修改；而合入检查则要求只检查出新增代码带来的新问题。</li><li>静态检查耗时普遍比较 “可观”，越是要求检查精准，越是需要更多耗时；而静态检查则要求越快越好。</li></ol><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><!-- draft- 代码差分算法- CheckStyle/Lint 增量方案- 增量报告方案--><h3 id="1-如何让静态检查工具只检查出新增部分代码带来的问题"><a href="#1-如何让静态检查工具只检查出新增部分代码带来的问题" class="headerlink" title="1. 如何让静态检查工具只检查出新增部分代码带来的问题"></a>1. 如何让静态检查工具只检查出新增部分代码带来的问题</h3><p>介绍我们的方案之前，先说一说两个使用得比较普遍的方案：其一，根据代码提交的时间（例如 git 工具就可以检查每一行代码最近的时间），约定一个起始点时间（比如上一个稳定版本）作为 baseline，静态检查工具检查出来的问题，其对应的代码提交记录如果早于这个 baseline 则自动忽略该问题，这样就能从一大堆问题里面筛选出比较 “新鲜” 的问题。其二，选一个稳定版本作为 baseversion，扫描出这个版本所有的问题并把结果记录下来，以后每次静态扫描都和前面 baseversion 保留的记录做比对，屏蔽存量问题（或者直接编写脚本，根据 baseversion 扫描出来的结果，给全部存量问题自动加上 suppression 注释以便后续静态检查在扫描阶段就屏蔽问题）。</p><p>公司内部部分静态扫描服务使用的就是以上两个方案之一（比如 CodeCC 使用的是 baseversion 方案），这样做的好是思路清晰接入点也简单，几乎对于所有的静态检查工具都可以使用这些方案，也不用担心静态检查工具版本升级带来的兼容性问题。不过缺点也是显而易见的，首先是依然要重复检查老问题，白白浪费资源，而且有些新问题结果表现可能和老问题一样，导致这些问题会被当成老问题忽视。</p><p>再来说说我们现在使用的方案：DevOps 实践中，我们需要计算出用户改了哪些代码或文件（也就是用户提交的 “增量代码”），用来检查用户的行为是否合法（比如改了不允许修改的问题，或者动了别人的代码需要 @owner 过来 Review），因此我们首先想到的是可以直接利用这些增量代码，在静态检查结果中匹配出增量代码带来的问题，这样虽然无法一下解决检查效率的问题，但是也能保证匹配出来的问题大概率是和用户改动的代码相关的。再做进一步思考，既然我们已经得到代码的增量数据，我们是不是可以直接对这部分增量的代码做静态检查？这样既不用重复检查那一大堆成年老问题，也可以直接暴露出增量代码带来的问题。答案是肯定的，我们最终采取了这两种方式结合的思路：</p><blockquote><p>直接对增量代码做检查得到一批问题报告，再从中匹配出增量代码带来的问题。</p></blockquote><h3 id="2-如何提高静态检查的效率"><a href="#2-如何提高静态检查的效率" class="headerlink" title="2. 如何提高静态检查的效率"></a>2. 如何提高静态检查的效率</h3><p>静态检查的效率，一方面跟扫描的文件数量相关，另一方面也受工具自身扫描算法、扫描内容、检测规则的粒度、规则的数量等影响。想要提高效率，一方面我们需要尽量减少输入的文件数，而我们上面提到的增量检查思路刚好把这个方面的问题做到最优解。另一方面，至于扫描算法，自己开发更加高效的检查工具显然不太现实，所以我们把目光放到扫描内容和检测规则，好在现在主流的静态检查工具，其检查规则甚至检查粒度，大都支持用户自定义。简单地说，针对源码类型做扫描的工具比如 CheckStyle 和 Lint，需要经过词法分析、语法分析生成抽象语法树，再遍历抽象语法树跟定义的检测规则去匹配，其工作效率会比较高；而像针对 .class 字节码文件做扫描的工具 FindBugs，需要先编译源码成 .class 文件，再通过 BCEL 分析字节码指令并与探测器规则匹配，效率就会大打折扣（Lint 也支持这种检查方式，这里不做展开）。除了以上谈到的两点外，像 Android 这种 Gradle 项目，如果项目 Module 比较多，Gradle Configure 阶段也会需要比较多的耗时。</p><p>实际上，第一个问题的解决思路，已经给现在这个问题指明了一个方向：针对增量代码做检查，既减少输入文件，又降低需要执行检查任务的 Module 数。万事俱备，接下来的事就是选用合适的静态检查工具了。</p><p>对于我们的项目，目标是 “统一代码风格、提高代码质量”。统一风格方面，CheckStyle 当仁不让， 它支持直接对代码源文件进行扫描，并且内置许多成熟的 Style Guides/Conventions 方案（比如 Google/Sun/Oracle），而且自定义规则也非常简单，完全可以自定义自己的代码格式和变量命名规则。剩下的就是如何提高代码质量，我们选用的是 Lint，理由非常简单，Lint 是 Android 官方深度定制工具，和 Android 项目相性最好，功能极其强大，且可定制性和扩展性以及全面性都表现均超乎我们期待。平时编写代码过程中，Android Stuido 智能标注的各种红色（Error）、黄色（Warning）警告，大部分都是 Lint 检查的结果（所以有事没事推荐大家多按 F2 试试，自动跳到下一处 Lint 检查出问题的地方）。除了跟 IDE/Gradle 插件相结合得很好之外，Lint 也像 CheckStyle 一样，支持直接对代码源文件、甚至 XML 资源文件进行检查，不需要计算依赖或者 API References，效率比较理想。而且 Lint 自定义检查规则的功能也非常强大，几乎覆盖对大部分 Java 代码、XML 资源格式的检查。</p><p>我们的整体方案是：</p><ol><li>计算增量代码。</li><li>以增量代码涉及的源文件作为输入（粒度是文件），给项目相关 Module 配置相应的 CheckStyle 和 Lint 任务。</li><li>运行检查任务，根据预置的检查规则进行扫描，得到检查结果。</li><li>从检查结果中筛选出和增量代码相关的问题（粒度是文件修改行数）</li></ol><h2 id="具体-方案-实现"><a href="#具体-方案-实现" class="headerlink" title="** 具体 ** 方案 ** 实现 **"></a>** 具体 ** 方案 ** 实现 **</h2><!-- draft- 本地增量代码计算- Lint 增量--><h3 id="1-通过-git-计算-增量-代码的信息"><a href="#1-通过-git-计算-增量-代码的信息" class="headerlink" title="*1. 通过 git 计算 * 增量 ** 代码的信息 **"></a>*<em>1. 通过 git 计算 *</em> 增量 ** 代码的信息 **</h3><p>在计算代码增量信息方面，我们需要解决以下几个问题：</p><ol><li>需要计算本地修改代码的增量信息，在体检代码前检查一下有没有新增问题。</li><li>需要计算提交 MR 时，开发分支与主干分支之间代码的增量信息，用于检查 MR 带来的新增问题。</li><li>当用户 MR 检查出问题后在本地修改代码，我们需要计算出 “开发分支与主干分支之间代码的增量信息” 叠加 “用户新修改问题带来的增量信息” 后的最终结果，以便用户检查自己是否已把问题修复。</li></ol><p>我们计算代码增量信息的方案，全靠 <code>git diff</code> 命令：</p><p><img src="/assets/man_git_diff_img_git_diff.png" alt="man: git diff"></p><p>这里先简单介绍一下我们方案需要用到的这几个参数的作用：</p><ol><li><code>name-only</code>：只显示修改文件的名字，不显示内容，这个参数分别刚好满足上面提到的方案的 “文件粒度” 和 “文件修改行数粒度”。</li><li><code>-cached</code>：只显示被 staged 过的文件（也就是已经被 add 到 git index 里），计算本地修改代码的时候，需要通过这个参数计算 “已 staged” 和 “未 staged” 两种文件的综合数据。</li><li><code>-diff-filter=ACMR</code>： 显示哪类文件：Added (A)、Copied (C)、 Modified (M)、Renamed (R)，具体配置请参看官方文档。</li><li><code>-ignore-space-at-eol</code>: 忽略行尾空格或者换行符等修改信息，这里额外说明一下，MR 计算代码修改信息用的也是 git diff 工具而且默认不带这个参数，而 IDEA 的 Annotate 默认是带这个参数的，所以有时候会看到有人提交 MR 显示修改了大量代码（比如批量代码格式化导致修改文件换行符），而当事人本地 IDEA 又看不出自己改了代码。</li><li><code>M100%</code>：这是一个阈值，用来计算前后两个不同名字的文件，内容相似度达到哪个百分比就认为这是一个被 Renamed (R) 的文件。</li></ol><p>关于参数解释，这里推荐一个工具 <a href="https://explainshell.com/explain?cmd=git+diff+--name-only+--cached+--diff-filter%3DACMR+--ignore-space-at-eol+-M100%25" target="_blank" rel="noopener">explainshell.com</a>，不在赘述。现在回答上面提到的几个问题。</p><p>对第一个问题，通过 <code>git diff --diff-filter=ACMR --ignore-space-at-eol -M100%</code> 和 <code>git diff --cached --diff-filter=ACMR --ignore-space-at-eol -M100%</code> 两个命令组合起来，可以综合计算出本地变动代码的增量信息。至于第二个问题，可以先通过 <code>git merge-base &lt;main_branch_revision&gt; HEAD</code> 计算出当前分支跟主干分支之间的共同节点 merge_base_revision，再通过 <code>git diff &lt;merge_base_revision&gt; HEAD</code>，就可以计算出当前开发分支从主干分支拉出来之后的代码变动情况。</p><p>这个方案里最难也最容易被忽略的是第三个问题，不像第一个问题里只要分别计算 staged 和 unstaged 两种文件再加起来就完事了，这里的本地的修改数据不是简单的叠加问题：用户修改了个文件 X，代码提交后，开发分支和主干之间就有一份确定的文件 X 的修改信息 A，这时候用户在本地继续修改文件 X，那本地修改记录里文件 X 也有另一份修改信息 B，这时候 B 跟 A 的修改信息是完全冲突的，我们要的是用户修改文件后本地文件最终状态跟主干之间的代码差异 C，而 A 跟 B 都是错误的信息，而且很明显 C ≠ A + B。</p><p>为了解决第三个问题，我们前后设计了两套方案：</p><ol><li>计算增量信息的时候，先 <code>git add -A &amp;&amp; git commit</code> 自动提交本地修改代码，然后计算 <code>git merge-base &lt;main_branch_revision&gt; HEAD</code>，最后 <code>git reset --soft HEAD~1</code> 把自动提交撤销掉。更详细的操作，还可以先计算修改文件哪些是 staged 的，reset 之后需要把 staged 状态恢复，全面还原文件状态。</li><li>依次计算修改信息 A 和修改信息 B，遍历修改信息 B 的每一行文件修改内容，然后一次拓扑更新 A 的内容，直到遍历完全 B，这时候拓扑后的 A 就是目标的信息 C 了。</li></ol><p>方案 1 的好处就是逻辑清晰，但是提交和撤销动作涉及本地文件修改，容易出现文件修改冲突破坏现场。方案 2 逻辑和算法都比 1 要复杂得多，好在经过几次迭代后我们证明这个路子是可行，现在稳定投产中。</p><p>作为补充说明，<code>git diff</code> 命令输出的格式不太适合直接参与后面的计算工作，需要先转换成程序友好的格式（比如 JSON），这里推荐一款基于 Python 的 git diff 解析工具：<a href="https://github.com/nathforge/gitdiffparser" target="_blank" rel="noopener">git-diff-parser</a>。项目中我们采用的是 Gradle 插件，所以也用 Groovy 实现了类似的解析工作。假设我们修改了 <code>MainActivity.java</code> 文件，新增了 <code>basepacks.txt</code> 文件，<code>git diff</code> 解析前格式是：</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">diff --git a&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;app&#x2F;MainActivity.java b&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;app&#x2F;MainActivity.java</span><br><span class="line">index d3151dd..80ba56b 100644</span><br><span class="line">--- a&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;app&#x2F;MainActivity.java</span><br><span class="line">+++ b&#x2F;app&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;app&#x2F;MainActivity.java</span><br><span class="line">@@ -7,6 +7,8 @@ import android.widget.Toast;</span><br><span class="line"></span><br><span class="line"> import com.jianghongkui.customelint.R;</span><br><span class="line"></span><br><span class="line">+import java.io.IOException;</span><br><span class="line">+</span><br><span class="line"> public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">@@ -15,11 +17,26 @@ public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">         setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-         Toast.makeText(this, &quot;&quot;, 20);</span><br><span class="line">-         assert true;</span><br><span class="line">+        Toast.makeText(this, &quot;&quot;, 20);</span><br><span class="line">+        assert true;</span><br><span class="line">+        String hello &#x3D; &quot;hello&quot;;</span><br><span class="line">+        System.out.println(hello);</span><br><span class="line">+        Integer.parseInt(&quot;2&quot;);</span><br><span class="line">+        Float.parseFloat(&quot;2&quot;);</span><br><span class="line">+        System.loadLibrary(&quot;hello&quot;);</span><br><span class="line">+        try &#123;</span><br><span class="line">+            getAssets().open(&quot;hello&quot;);</span><br><span class="line">+        &#125; catch (IOException e) &#123;</span><br><span class="line">+            e.printStackTrace();</span><br><span class="line">+        &#125;</span><br><span class="line">+</span><br><span class="line">+        foo(&quot;hello2&quot;);</span><br><span class="line">+        foo(&quot;libandromeda&quot;);</span><br><span class="line">+        System.out.println(&quot;libflutter&quot;);</span><br><span class="line">+        System.out.println(&quot;libflutter_v7.so&quot;);</span><br><span class="line">+    &#125;</span><br><span class="line"></span><br><span class="line">-         System.out.println(&quot;hello&quot;);</span><br><span class="line">-         Integer.parseInt(&quot;2&quot;);</span><br><span class="line">-         Float.parseFloat(&quot;2&quot;);</span><br><span class="line">+    private void foo(String str) &#123;</span><br><span class="line">+        System.loadLibrary(str);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">diff --git a&#x2F;add.txt b&#x2F;add.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..9b07058</span><br><span class="line">--- &#x2F;dev&#x2F;null</span><br><span class="line">+++ b&#x2F;add.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+asad</span><br><span class="line">+asdasd</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure><p>经过解析之后变成：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"app/src/main/java/com/example/app/MainActivity.java"</span>,</span><br><span class="line">        <span class="attr">"changed_lines"</span>: [</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">11</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">21</span>,</span><br><span class="line">            <span class="number">22</span>,</span><br><span class="line">            <span class="number">23</span>,</span><br><span class="line">            <span class="number">24</span>,</span><br><span class="line">            <span class="number">25</span>,</span><br><span class="line">            <span class="number">26</span>,</span><br><span class="line">            <span class="number">27</span>,</span><br><span class="line">            <span class="number">28</span>,</span><br><span class="line">            <span class="number">29</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            <span class="number">31</span>,</span><br><span class="line">            <span class="number">32</span>,</span><br><span class="line">            <span class="number">33</span>,</span><br><span class="line">            <span class="number">34</span>,</span><br><span class="line">            <span class="number">35</span>,</span><br><span class="line">            <span class="number">36</span>,</span><br><span class="line">            <span class="number">37</span>,</span><br><span class="line">            <span class="number">39</span>,</span><br><span class="line">            <span class="number">40</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"deleted_lines"</span>: [</span><br><span class="line">            <span class="number">18</span>,</span><br><span class="line">            <span class="number">19</span>,</span><br><span class="line">            <span class="number">21</span>,</span><br><span class="line">            <span class="number">22</span>,</span><br><span class="line">            <span class="number">23</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"is_new_file"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"add.txt"</span>,</span><br><span class="line">        <span class="attr">"changed_lines"</span>: [</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"deleted_lines"</span>: [],</span><br><span class="line">        <span class="attr">"is_new_file"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>具体代码请参考文末提供的代码仓库。</p><h3 id="2-基于-AGP-插件的-Lint-增量检查方案"><a href="#2-基于-AGP-插件的-Lint-增量检查方案" class="headerlink" title="2. 基于 AGP 插件的 Lint 增量检查方案"></a>2. 基于 AGP 插件的 Lint 增量检查方案</h3><!-- draft1. Android Studio 自带的 lint 检查流程2. 如何实现增量检查3. 如何实现自定义检查规则4. 一些需要注意的点--><p>在增量检查的具体实现上，我们采用的是自定义 Gradle 插件，增加了 <code>:checkIncremental</code> 任务来执行增量的检查任务。其中 CheckStyle 检查的实现是基于 Gradle Api 提供相关 Checkstyle Task，这个本身就支持增量检查，直接配置输入文件就好。Lint 的增量检查就要复杂得多，主要是基于 Android 官方的 AGP (Android Gradle Plugin) 插件提供的 <code>com.android.tools.lint:lint-gradle</code> 库进行实现，以下介绍几个关键的技术点。</p><h4 id="Lint-检查的工作流程"><a href="#Lint-检查的工作流程" class="headerlink" title="Lint 检查的工作流程"></a>Lint 检查的工作流程</h4><p>Android Lint 的工作过程比较简单，由一个基础的 Lint 过程由 Lint Tool（检测工具），Source Files（项目源文件） 和 lint.xml（配置文件） 三个部分组成：Lint Tool 读取 Source Files，根据 lint.xml 配置的规则（issue）输出结果，如下图：</p><p><img src="/assets/lint_gong_zuo_liu_cheng_shi_yi_tu_image_lint_workflow.png" alt="Lint 工作流程示意图"></p><p>Android 项目中，一般我们有三种方式运行 Lint 检查：命令行、IDEA 的 Inspections 检查功能、Gradle Lint 任务，他们都由 <a href="http://tools.android.com/tips/lint" target="_blank" rel="noopener">AGP Android Lint</a> 提供，并由 Android 官方进行维护，虽然检查入口各不相同，但是底层都是同一套 Lint API 实现（提供 Lint 检查实现的 lint-api.jar 和封装好一些常用检查规则的 lint-check.jar，三种工作方式都是基于这两个类库实现）。</p><p>届于 Lint API 涉及的类库比较复杂，这里不做深入讨论，主要介绍一下几个比较关键的 API：</p><ol><li><code>LintDriver</code>: 三种工作方式最后都通过 LintDriver#analyse () 执行实际上的检查工作。</li><li><code>IssueRegistry</code>：管理 Lint 检查规则，配合 lint.xml 使用。Android 有内置的 BuiltinIssueRegistry，用户自定义检查的话，需要重写该类。</li><li><code>LintRequest</code>：执行 Lint 检查时的一个请求类，封装好了需要检查的文件内容，我们需要实现的增量检查，也是要从这里下手。</li><li><code>LintClient</code>：Lint 客户端，集成 Lint 检查的操作、配置，对应某一种具体的工作方式，比如 LintCliClient 对应命令行方式，LintIdeClient 对应 IDEA 的 Inspections，LintGradleClient 对应 Gradle Lint Task。</li></ol><p>用伪代码表示的话大概是：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> registry = <span class="keyword">new</span> IssueRegistry()</span><br><span class="line"><span class="keyword">def</span> client = <span class="keyword">new</span> LintClient(registry) &#123;</span><br><span class="line">    override createLintRequest(file) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LintRequest(file)</span><br><span class="line">    &#125;</span><br><span class="line">    override run() &#123;</span><br><span class="line">        LintDriver.analyze()  <span class="comment">// super impl</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">client.run()</span><br></pre></td></tr></table></figure><h4 id="Lint-自-定义-检查规则"><a href="#Lint-自-定义-检查规则" class="headerlink" title="*Lint 自 * 定义 ** 检查规则 **"></a>*<em>Lint 自 *</em> 定义 ** 检查规则 **</h4><p>自定义检查规则，就是要自定义各种检查 Detector 类，具体可以参考官方的指导文档 <a href="http://tools.android.com/tips/lint/writing-a-lint-check" target="_blank" rel="noopener">Writing a Lint Check</a> 或者美团的几篇 Lint 实践文章 <a href="https://tech.meituan.com/tags/lint.html" target="_blank" rel="noopener">美团 Lint</a>。老实说，这方面官方给出的 Example 并不是很详细，具体怎么写还是要靠自己去看官方 Lint API 的源码，以及参考别人的开源代码（如果你比较熟悉 Visitor 访问者模式，或者写过 ASM 插件，应该比较容易上手）。</p><p>这里给出一个我们自己自定义的检查规则作参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查 Log 的使用规范</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogIssue</span> <span class="keyword">extends</span> <span class="title">Detector</span> <span class="keyword">implements</span> <span class="title">Detector</span>.<span class="title">UastScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Issue ISSUE = Issue.create (</span><br><span class="line">            <span class="string">"WxLog"</span>,</span><br><span class="line">            <span class="string">"Log 使用不规范，请使用 platformtools.Log"</span>,</span><br><span class="line">            <span class="string">"请使用项目共用的 Log 函数，输出 console 及 xlog 文件请使用 platformtools.Log, 不希望输出 xlog 文件请使用 android.util.Log"</span>,</span><br><span class="line">            Category.CORRECTNESS,</span><br><span class="line">            <span class="number">9</span>,</span><br><span class="line">            Severity.ERROR,</span><br><span class="line">            <span class="keyword">new</span> Implementation (LogIssue<span class="class">.<span class="keyword">class</span>, <span class="title">Scope</span>.<span class="title">JAVA_FILE_SCOPE</span>))</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethod</span> <span class="params">(@NotNull JavaContext context, @NotNull UCallExpression node, @NotNull PsiMethod method)</span> </span>&#123;<span class="keyword">if</span> (context.getEvaluator ().isMemberInClass (method, <span class="string">"java.io.PrintStream"</span>)) &#123;context.report (ISSUE, context.getLocation (node), ISSUE.getBriefDescription (TextFormat.TEXT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getApplicableMethodNames</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> Arrays.asList (<span class="string">"print"</span>, <span class="string">"println"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lint-增量检查的实现方案"><a href="#Lint-增量检查的实现方案" class="headerlink" title="Lint 增量检查的实现方案"></a>Lint 增量检查的实现方案</h4><p>上面提到，“我们需要实现的增量检查，需要从 LintRequest 下手”，通过重写 LintClient 中的 createLintRequest 方法，传入我们需要增量检查的文件，以下给出关键的代码，具体的实现细节，请参考我们的代码库。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LintToolClient</span> <span class="keyword">extends</span> <span class="title">LintCliClient</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> LintRequest createLintRequest (List&lt;File&gt; files) &#123;LintRequest request = <span class="keyword">super</span>.createLintRequest (files)</span><br><span class="line">        <span class="keyword">for</span> (Project <span class="string">project :</span> request.getProjects ()) &#123;<span class="keyword">for</span> (File <span class="string">file :</span> files) &#123;project.addFile (file) <span class="comment">// 具体需要检查的文件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LintRequest (<span class="keyword">this</span>, files)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到有三种 Lint 的工作方式，我们采用的是扩展第三种 Lint Gradle 方式（因为这种方式能直接复用现成的 lint.xml 配置文件和 Lint Output 报告格式），最终整体的工作流程是：</p><ol><li>通过 git diff 获得需要检查文件作为 Source Files。</li><li>根据自己的检查需要自定义 LintIssueRegistry（增加了一批自定义的 Detector，考虑的性能需要，移除了那些需要依赖编译产物的内置 Detectors）。</li><li>自定义继承 LintGradleClient 的 LintIncrementalClient（也就是采用 Lint Gradle 工作方式）。</li><li>根据 Source Files，为每一个有文件变动的 Module 创建增量检查用的 Gradle Task；运行检查任务的时候，执行 LintIncrementalClient#run () 实现增量检查</li></ol><p>除了我们采用的第三种 Lint Gradle 方式，这里补充说明一下第二种 IDEA 的 Inspections 功能：通过 “IDEA - Analyse - Inspect Code” 可以迅速针对一个指定的文件做 Lint 检查。如下：</p><p><img src="/assets/idea_inspect_code_image_idea_inspect_code.png" alt="IDEA Inspect Code"></p><p>经过挖掘，我们发现其实现的关键代码在 <a href="https://github.com/JetBrains/android/blob/master/android/src/com/android/tools/idea/lint/LintIdeClient.java" target="_blank" rel="noopener">LintIdeClient.java</a>。通过 Inspections 方案，我们能直接对指定文件进行 Lint 检查，而不需要依赖于 Gradle 环境，这是 Lint 增量检查的最佳方案。不过考虑到 IDEA 版本之间的兼容性问题，而且我们还需要将检查工作合入到 DevOps 自动化流程里，所以最终还是选择了 Gradle Lint 方案。</p><p>最后，关于具体的 Lint 实现有一点需要补充说明：Lint API 25 到 26 之间，无论是 API 接口还是具体的实现，变化都非常大，所以各位参考别人的具体实现代码的时候，一定要先分清当前的 API 版本是多少。</p><h3 id="3-整体-工作-流程图"><a href="#3-整体-工作-流程图" class="headerlink" title="3*. 整体 * 工作 ** 流程图 **"></a>3*<em>. 整体 *</em> 工作 ** 流程图 **</h3><p>没有流程图的方案是没有灵魂的，如下：</p><p><img src="/assets/workflow_image_workflows.png" alt="workflow"></p><h2 id="结果沉淀"><a href="#结果沉淀" class="headerlink" title="结果沉淀"></a>结果沉淀</h2><!-- draft- 检查结果展示 - Incrementals- 专利- 检查时间--><p>以代码仓库的 Demo 项目为例，如果执行一遍默认的 <code>:app:clean :app:lint</code> 检查任务，耗时 Configure + 检查任务整体耗时大概在 10s 左右，如下：</p><p><img src="/assets/app_clean_app_lint_time_consumed_image_demo_1.png" alt=":app:clean :app:lint time consumed"></p><p>接入增量 Lint 方案后，耗时已经能压缩到 1s 左右：</p><p>![<a href="/assets/app_clean_app_checklint_time_consumed_image_demo_1.png">:app:clean :app:checkLint time consumed</a></p><p>即使加上增量的 CheckStyle 检查任务，再最终补上一个用来做检查结果报告的 <code>checkReport</code> 任务，整体增量检查耗时也能稳定在 1s：</p><p><img src="/assets/checkincremental_time_consumde_image_demo_1.png" alt=":checkIncremental time consumde"></p><p>在实际项目 MR 合入检查流水线里的应用效果如下：</p><p><img src="/assets/mr_he_ru_jian_cha_pipelines_1579101129_18.png" alt="MR 合入检查 Pipelines"></p><p><img src="/assets/mr_dai_ma_zeng_liang_jian_cha_jie_guo_1579101164_53.png" alt="MR 代码增量检查结果"></p><p>在 MR 代码合入检查的静态检查环节上，我们目前一共实现了 CheckStyle、Lint、文件格式（LF/CRLF 换行符问题）、非法文件修改（文件权限）四种检查内容，其中 Lint 增量带来的收益最明显，时间成本从原本的几分钟、十几分钟级别下降到几秒到几十秒的级别（通常只要在封版前涉及大量代码修改的 MR 才需要几十秒的耗时），已经基本满足了我们 DevOps 合入检查的要求（考虑到静态检查环节是我们合入检查几个并行的 Stages 之间耗时最小的一个，可以说相当于没有时间成本）。而且除了时间成本之外，Lint 自定义检查的功能相当于给我们的平台提供了一种定制性比较强的检查工具，比如 Dark Mode 对 XML 的颜色值有使用规范，通过自定义 Detector 可以很轻松得检查每一个新增 XML 文件的 color 属性。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>本文主要以介绍静态检查整体的应用方案为主，以及分享方案落地流程里一些问题，主要是一己的经验之谈。如果你希望了解现有静态检查工具的对比和应用，这方面市场上已经有大量的科普和评测文章请自行检索，如果你希望试用各种检查工具，这里推荐一下公司内部的静态检查服务 CodeCC 和 CodeDog，他们都有详细的使用文档。又或者你想研究 Lint API 具体的工作细节，这里推荐一下美团技术团队编写的几篇 Lint 相关技术文章 <a href="https://tech.meituan.com/tags/lint.html" target="_blank" rel="noopener">美团 Lint</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://tools.android.com/tips/lint" target="_blank" rel="noopener">http://tools.android.com/tips/lint</a> （官方文档）</li><li><a href="https://tech.meituan.com/tags/lint.html" target="_blank" rel="noopener">https://tech.meituan.com/tags/lint.html</a> （美团 Lint 实践）</li><li><a href="https://www.jianshu.com/p/a0f28fbef73f" target="_blank" rel="noopener">https://www.jianshu.com/p/a0f28fbef73f</a> （自定义 Lint 规则）</li><li><a href="https://blog.csdn.net/ouyang_peng/article/details/80374867" target="_blank" rel="noopener">https://blog.csdn.net/ouyang_peng/article/details/80374867</a> （自定义 Lint 规则）</li><li><a href="https://www.jianshu.com/p/4833a79e9396" target="_blank" rel="noopener">https://www.jianshu.com/p/4833a79e9396</a> （增量 Lint 实现）</li><li><a href="https://github.com/lingochamp/okcheck" target="_blank" rel="noopener">https://github.com/lingochamp/okcheck</a> （增量检查，粒度是有代码改动的 Module，一个折中的方案，优点是侵入性小)</li></ol><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 增量静态检查（SPA）在代码合入检查里的应用Date = 2018-04-01Published = trueCategory = DevOpsTag = ['DevOps', 'SPA', '自动化，静态检查']FileLocate = devopsFileName = incremental-spahexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;!-- draft
Android 静态代码扫描效率优化与实践 - 美团
[https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA](https://mp.weixin.qq.com/s/cY6rUrrjYRaIV--UzjiUgA)
1. 背景
2. 思考
3. 实践
4. 结果
5. 沉淀
6. 总结
文章源代码计划：
1. 高亮
2. 多渠道
3. 注释
--&gt;



&lt;p&gt;静态程序分析，是指在不运行程序的情况下分析检查代码里存在的问题。这项技术在代码质量、漏洞扫描等领域有广泛的使用。常见分析工具包括 CheckStyle、Lint、FindBugs 等，也有商用的 Coverity。本文主要讲述为我们在 Android 项目 Merge Request 合入检查里对静态程序分析技术的应用，核心内容是增量代码的静态分析方案，至于各种检查工具的对比筛选，请参考文末提供的 References。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DevOps" scheme="http://kaedea.com/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="http://kaedea.com/tags/DevOps/"/>
    
      <category term="SPA" scheme="http://kaedea.com/tags/SPA/"/>
    
      <category term="自动化，静态检查" scheme="http://kaedea.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%EF%BC%8C%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>一种Android应用内全局获取Context实例的装置</title>
    <link href="http://kaedea.com/2017/04/09/android/global-accessing-context/"/>
    <id>http://kaedea.com/2017/04/09/android/global-accessing-context/</id>
    <published>2017-04-09T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>哥白尼・罗斯福・马丁路德・李开复・嫁衣曾经说过</p><blockquote><p>Where there is an Android App, there is an Application context.</p></blockquote><p>没毛病，扎心了。App 运行的时候，肯定是存在至少一个 Application 实例的。同时，Context 我们再熟悉不过了，写代码的时候经常需要使用到 Context 实例，它一般是通过构造方法传递进来，通过方法的形式参数传递进来，或者是通过 attach 方法传递进我们需要用到的类。Context 实在是太重要了，以至于我经常恨不得着藏着掖着，随身带着，这样需要用到的时候就能立刻掏出来用用。但是换个角度想想，既然 App 运行的时候，Application 实例总是存在的，那么为何不设置一个全局可以访问的静态方法用于获取 Context 实例，这样以来就不需要上面那些繁琐的传递方式。</p><p>说到这里，有的人可能说想这不是我们经常干的好事吗，有必要说的这么玄乎？少侠莫急，请听吾辈徐徐道来。</p><a id="more"></a><h2 id="获取-Context-实例的一般方式"><a href="#获取-Context-实例的一般方式" class="headerlink" title="获取 Context 实例的一般方式"></a>获取 Context 实例的一般方式</h2><p>这再简单不过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo1</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="title">Foo1</span> <span class="params">(Context context)</span> </span>&#123;<span class="comment">// 1. 在构造方法带入&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;<span class="function"><span class="keyword">public</span> Foo2 <span class="title">attach</span> <span class="params">(Context context)</span> </span>&#123;<span class="comment">// 2. 通过 attach 方法带入 return this;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(Context context)</span> </span>&#123;<span class="comment">// 3. 调用方法的时候，通过形参带入&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式应该是最常见的获取 Context 实例的方式了，优点就是严格按照代码规范来，不用担心兼容性问题；缺点就是 API 设计严重依赖于 Context 这个 API，如果早期接口设计不严谨，后期代码重构的时候可能很要命。此外还有一个比较有趣的问题，我们经常使用 Activity 或者 Application 类的实例作为 Context 的实例使用，而前者本身又实现了别的接口，比如以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FooActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">FooA</span>, <span class="title">FooB</span>, <span class="title">FooC</span> </span>&#123;</span><br><span class="line">    Foo mFoo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span> <span class="params">(Bundle bundle)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 禁忌・四重存在！</span></span><br><span class="line">        mFoo.foo (<span class="keyword">this</span>, <span class="keyword">this</span>, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span> <span class="params">(Context context, FooA a, FooB b, FooC c)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是我许久前看过的代码，本身不是什么厉害的东西，不过这段代码段我至今印象深刻。设想，如果 Foo 的接口设计可以不用依赖 Context，那么这里至少可以少一个 <code>this</code> 不是吗。</p><h2 id="获取-Context-实例的二般方式"><a href="#获取-Context-实例的二般方式" class="headerlink" title="获取 Context 实例的二般方式"></a>获取 Context 实例的二般方式</h2><p>现在许多开发者喜欢设计一个全局可以访问的静态方法，这样以来在设计 API 的时候，就不需要依赖 Context 了，代码看起来像是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局获取 Context 实例的静态方法。</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> sContext;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span> <span class="params">(Context context)</span> </span>&#123;sContext = context;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在整个项目中，都可以通过 <code>Foo#getContext ()</code> 获取 Context 实例了。不过目前看起来好像还有点小缺陷，就是使用前需要调用 <code>Foo#setContext (Context)</code> 方法进行注册（这里暂不讨论静态 Context 实例带来的问题，这不是本篇幅的关注点）。好吧，以我的聪明才智，很快就想到了优化方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局获取 Context 实例的静态方法（改进版）。</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FooApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">FooApplication</span> <span class="params">()</span> </span>&#123;sContext = <span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> sContext;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样又有带来了另一个问题，一般情况下，我们是把应用的入口程序类 <code>FooApplication</code> 放在 App 模块下的，这样一来，Library 模块里面代码就访问不到 <code>FooApplication#getContext ()</code> 了。当然把 <code>FooApplication</code> 下移到基础库里面也是一种办法，不过以我的聪明才智又立刻想到了个好点子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 全局获取 Context 实例的静态方法（改进版之再改进）。</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FooApplication</span> <span class="keyword">extends</span> <span class="title">BaseApplication</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基础库里面</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> sContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">BaseApplication</span> <span class="params">()</span> </span>&#123;sContext = <span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> sContext;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以来，就不用把 <code>FooApplication</code> 下移到基础库里面，Library 模块里面的代码也可以通过 <code>BaseApplication#getContext ()</code> 访问到 Context 实例了。嗯，这看起来似乎是一种神奇的膜法，因吹斯听。然而，代码写完还没来得及提交，包工头打了个电话来和我说，由于项目接入了第三发 SDK，需要把 <code>FooApplication</code> 继承 <code>SdkApplication</code>。<br>…… 有没有什么办法能让 <code>FooApplication</code> 同时继承 <code>BaseApplication</code> 和 <code>SdkApplication</code> 啊？（场面一度很尴尬，这里省略一万字。）<br>以上谈到的，都是以前我们在获取 Context 实例的时候遇到的一些麻烦：</p><ol><li>类 API 设计需要依赖 Context（这是一种好习惯，我可没说这不好）；</li><li>持有静态的 Context 实例容易引发的内存泄露问题；</li><li>需要提注册 Context 实例（或者释放）；</li><li>污染程序的 Application 类；</li></ol><p>那么，有没有一种方式，能够让我们在整个项目中可以全局访问到 Context 实例，不要提前注册，不会污染 Application 类，更加不会引发静态 Context 实例带来的内存泄露呢？</p><h2 id="一种全局获取-Context-实例的方式"><a href="#一种全局获取-Context-实例的方式" class="headerlink" title="一种全局获取 Context 实例的方式"></a>一种全局获取 Context 实例的方式</h2><p>回到最开始的话，App 运行的时候，肯定存在至少一个 Application 实例。如果我们能够在系统创建这个实例的时候，获取这个实例的应用，是不是就可以全局获取 Context 实例了（因为这个实例是运行时一直存在的，所以也就不用担心静态 Context 实例带来的问题）。那么问题来了，Application 实例是什么时候创建的呢？首先先来看看我们经常用来获取 Base Context 实例的 <code>Application#attachBaseContext (Context)</code> 方法，它是继承自 <code>ContextWrapper#attachBaseContext (Context)</code> 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base context already set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是谁调用了这个方法呢？可以很快定位到 <code>Application#attach (Context)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又是谁调用了 <code>Application#attach (Context)</code> 方法呢？一路下来可以直接定位到 <code>Instrumentation#newApplication (Class&lt;?&gt;, Context)</code> 方法里（这个方法名很好懂啊，一看就知道是干啥的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for implementing application instrumentation code.  When running</span></span><br><span class="line"><span class="comment"> * with instrumentation turned on, this class will be instantiated for you</span></span><br><span class="line"><span class="comment"> * before any of the application code, allowing you to monitor all of the</span></span><br><span class="line"><span class="comment"> * interaction the system has with the application.  An Instrumentation</span></span><br><span class="line"><span class="comment"> * implementation is described to the system through an AndroidManifest.xml's</span></span><br><span class="line"><span class="comment"> * &lt;instrumentation&gt;.</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            ClassNotFoundException </span>&#123;</span><br><span class="line">        Application app = (Application)clazz.newInstance();</span><br><span class="line">        app.attach(context);</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来是在这里创建了 App 的入口 Application 类实例的，是不是想办法获取到这个实例的应用就可以了？不，还别高兴太早。我们可以把 Application 实例当做 Context 实例使用，是因为它持有了一个 Context 实例（base），实际上 Application 实例都是通过代理调用这个 base 实例的接口完成相应的 Context 工作的。在上面的代码中，可以看到系统创建了 Application 实例 app 后，通过 <code>app.attach (context)</code> 把 context 实例设置给了 app。直觉告诉我们，应该进一步关注这个 context 实例是怎么创建的，可以定位到 <code>LoadedApk#makeApplication (boolean, Instrumentation)</code> 代码段里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Local state maintained about a currently loaded .apk.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadedApk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span> <span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instrumentation)</span> </span>&#123;<span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;<span class="keyword">return</span> mApplication;&#125;</span><br><span class="line"></span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String appClass = mApplicationInfo.className;</span><br><span class="line">        <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;appClass = <span class="string">"android.app.Application"</span>;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;java.lang.ClassLoader cl = getClassLoader ();</span><br><span class="line">            <span class="keyword">if</span> (!mPackageName.equals (<span class="string">"android"</span>)) &#123;</span><br><span class="line">                Trace.traceBegin (Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                        <span class="string">"initializeJavaContextClassLoader"</span>);</span><br><span class="line">                initializeJavaContextClassLoader ();</span><br><span class="line">                Trace.traceEnd (Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// Context 实例创建的地方，可以看出 Context 实例是一个 ContextImpl。</span></span><br><span class="line">            ContextImpl appContext = ContextImpl.createAppContext (mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">            app = mActivityThread.mInstrumentation.newApplication (cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext (app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123; &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，到这里我们定位到了 Application 实例和 Context 实例创建的位置，不过距离我们的目标只成功了一半。因为如果我们要想办法获取这些实例，就得先知道这些实例被保存在什么地方。上面的代码一路逆向追踪过来，好像也没看见实例被保存给成员变量或者静态变量，所以暂时还得继续往上捋。很快就能捋到 <code>ActivityThread#performLaunchActivity (ActivityClientRecord, Intent)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This manages the execution of the main thread in an</span></span><br><span class="line"><span class="comment"> * application process, scheduling and executing activities,</span></span><br><span class="line"><span class="comment"> * broadcasts, and other operations on it as the activity</span></span><br><span class="line"><span class="comment"> * manager requests.</span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;<span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span> <span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">        ComponentName component = r.intent.getComponent ();</span><br><span class="line">        Activity activity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;java.lang.ClassLoader cl = r.packageInfo.getClassLoader ();</span><br><span class="line">            activity = mInstrumentation.newActivity (cl, component.getClassName (), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount (activity.getClass ());</span><br><span class="line">            r.intent.setExtrasClassLoader (cl);</span><br><span class="line">            r.intent.prepareToEnterProcess ();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;r.state.setClassLoader (cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="keyword">if</span> (!mInstrumentation.onException (activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (</span><br><span class="line">                    <span class="string">"Unable to instantiate activity"</span> + component</span><br><span class="line">                    + <span class="string">":"</span> + e.toString (), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建 Application 实例。</span></span><br><span class="line">            Application app = r.packageInfo.makeApplication (<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;...&#125;</span><br><span class="line">            r.paused = <span class="keyword">true</span>;</span><br><span class="line">            mActivities.put (r.token, r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="keyword">if</span> (!mInstrumentation.onException (activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (</span><br><span class="line">                    <span class="string">"Unable to start activity"</span> + component</span><br><span class="line">                    + <span class="string">":"</span> + e.toString (), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是我们启动 Activity 的时候，Activity 实例创建的具体位置，以上代码段还可以看到喜闻乐见的 “Unable to start activity” 异常，你们猜猜这个异常是谁抛出来的？这里就不发散了，回到我们的问题来，以上代码段获取了一个 Application 实例，但是并没有保持住，看起来这里的 Application 实例就像是一个临时变量。没办法，再看看其他地方吧。接着找到 <code>ActivityThread#handleCreateService (CreateServiceData)</code>，不过这里也一样，并没有把获取的 Application 实例保存起来，这样我们就没有办法获取到这个实例了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">        mSystemThread = system;</span><br><span class="line">        <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Don't set application object here -- if the system crashes,// we can't display an alert, we just want to die die die.</span></span><br><span class="line">            android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</span><br><span class="line">                    UserHandle.myUserId());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">                ContextImpl context = ContextImpl.createAppContext(</span><br><span class="line">                        <span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line">                mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                mInitialApplication.onCreate();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">systemMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里创建 Application 实例后，把实例保存在 ActivityThread 的成员变量 <code>mInitialApplication</code> 中。不过仔细一看，只有当 <code>system == true</code> 的时候（也就是系统应用）才会走这个逻辑，所以这里的代码也不是我们要找的。不过，这里给我们一个提示，如果能想办法获取到 ActivityThread 实例，或许就能直接拿到我们要的 Application 实例。此外，这里还把 ActivityThread 的实例赋值给一个静态变量 <code>sCurrentActivityThread</code>，静态变量正是我们获取系统隐藏 API 实例的切入点，所以如果我们能确定 ActivityThread 的 <code>mInitialApplication</code> 正是我们要找的 Application 实例的话，那就大功告成了。继续查找到 <code>ActivityThread#handleBindApplication (AppBindData)</code>，光从名字我们就能猜出这个方法是干什么的，直觉告诉我们离目标不远了～</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">            mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                    + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这里同样把 Application 实例保存在 ActivityThread 的成员变量 <code>mInitialApplication</code> 中，紧接着我们看看谁是调用了 <code>handleBindApplication</code> 方法，很快就能定位到 <code>ActivityThread.H#handleMessage (Message)</code> 里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">                ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">                IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                    AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                    handleBindApplication(data);</span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                    <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mInitialApplication.onTerminate();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Looper.myLooper().quit();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bingo！至此一切都清晰了，<code>ActivityThread#mInitialApplication</code> 确实就是我们需要找的 Application 实例。整个流程捋顺下来，系统创建 Base Context 实例、Application 实例，以及把 Base Context 实例 attach 到 Application 内部的流程大致可以归纳为以下调用顺序。</p><blockquote><p>ActivityThread#bindApplication (异步) –&gt; ActivityThread#handleBindApplication –&gt; LoadedApk#makeApplication –&gt; Instrumentation#newApplication –&gt; Application#attach –&gt; ContextWrapper#attachBaseContext</p></blockquote><p>源码撸完了，再回到我们一开始的需求来。现在我们要获取 ActivityThread 的静态成员变量 sCurrentActivityThread。阅读源码后我们发现可以通过 <code>ActivityThread#currentActivityThread ()</code> 这个静态方法来获取这个静态对象，然后通过 <code>ActivityThread#getApplication ()</code> 方法就可能直接获取我们需要的 Application 实例了。啊，这用反射搞起来简直再简单不过了！说搞就搞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Applications</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Application <span class="title">context</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> CURRENT;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint</span> (<span class="string">"StaticFieldLeak"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Application CURRENT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;Object activityThread = getActivityThread ();</span><br><span class="line">            Object app = activityThread.getClass ().getMethod (<span class="string">"getApplication"</span>).invoke (activityThread);</span><br><span class="line">            CURRENT = (Application) app;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException (<span class="string">"Can not access Application context by magic code, boom!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getActivityThread</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Object activityThread = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;Method method = Class.forName (<span class="string">"android.app.ActivityThread"</span>).getMethod (<span class="string">"currentActivityThread"</span>);</span><br><span class="line">            method.setAccessible (<span class="keyword">true</span>);</span><br><span class="line">            activityThread = method.invoke (<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;Log.w (TAG, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activityThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码 @RunWith (AndroidJUnit4.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ApplicationTest"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetGlobalContext</span> <span class="params">()</span> </span>&#123;Application context = Applications.context ();</span><br><span class="line">        Assert.assertNotNull (context);</span><br><span class="line">        Log.i (TAG, String.valueOf (context));</span><br><span class="line"><span class="comment">// MyApplication 是项目的自定义 Application 类</span></span><br><span class="line">        Assert.assertTrue (context <span class="keyword">instanceof</span> MyApplication);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以来， 无论在项目的什么地方，无论是在 App 模块还是 Library 模块，都可以通过 <code>Applications#context ()</code> 获取 Context 实例，而且不需要做任何初始化工作，也不用担心静态 Context 实例带来的问题，测试代码跑起来没问题，接入项目后也没有发现什么异常，我们简直要上天了。不对，哪里不对。不科学，一般来说不可能这么顺利的，这一定是错觉。果然项目上线没多久后立刻原地爆炸了，在一些机型上，通过 <code>Applications#context ()</code> 获取到的 Context 恒为 null。<br>(╯&gt;д&lt;)╯⁽˙³˙⁾ 对嘛，这才科学嘛。<br>通过测试发现，在 4.1.1 系统的机型上，会稳定出现获取结果为 null 的现象，看来是系统源码的实现上有一些出入导致，总之先看看源码吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来是这么一个幺蛾子，在 4.1.1 系统上，ActivityThread 是使用一个 ThreadLocal 实例来存放静态 ActivityThread 实例的。至于 ThreadLocal 是干什么用的这里暂不展开，简单说来，就是系统只有在 UI 线程使用 sThreadLocal 来保存静态 ActivityThread 实例，所以我们只能在 UI 线程通过 sThreadLocal 获取到这个保存的实例，在 Worker 线程 sThreadLocal 会直接返回空。<br>这样以来解决方案也很明朗，只需要在事先现在 UI 线程触发一次 <code>Applications#context ()</code> 调用保存 Application 实例即可。不过项目的代码一直在变化，我们很难保证不会有谁不小心触发了一次优先的 Worker 线程的调用，那就 GG 了，所以最好在 <code>Applications#context ()</code> 方法里处理，我们只需要确保能在 Worker 线程获得 ActivityThread 实例就 Okay 了。不过一时半会我想不出切确的办法，也找不到适合的切入点，只做了下简单的处理：如果是优先在 Worker 线程调用，就先使用 UI 线程的 Handler 提交一个任务去获取 Context 实例，Worker 线程等待 UI 线程获取完 Context 实例，再接着返回这个实例。<br>最终完成的代码可以参考 <a href="https://github.com/kaedea/Feya/blob/master/Application/Feya/src/main/java/me/kaede/feya/context/Applications.java" target="_blank" rel="noopener">Applications</a>。<br>（补充 2017-04-13）<br>在这里需要特别强调的时候，通过这样的方法获取 Context 实例，只要在 <code>Application#attachBaseContext (Context)</code> 执行之后才能获取到对象，在之前或者之内获取到的对象都是 null，具体原因可以参考上面调用流程中的 <code>ActivityThread#handleBindApplication</code>。所以，膜法什么的，还是少用为妙吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://grepcode.com/file_/repository.grepcode.com/java/ext/com.google.android/android/4.1.1_r1/android/app/ActivityThread.java" target="_blank" rel="noopener">ActivityThread.java</a></p><!-- draft著作信息： 本文章出自 [Kaede](http://www.kaedea.com/about) 的博客，原创文章若无特别说明，均遵循 [CC BY-NC 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh) 知识共享许可协议 4.0（署名 - 非商用 - 相同方式共享），可以随意摘抄转载，但必须标明署名及原地址。--><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 一种Android应用内全局获取Context实例的装置Date = 2017-04-9 00:00:00Published = trueCategory = AndroidTag = ['Android', 'Context', 'Hook']FileLocate = androidFileName = global-accessing-contexthexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哥白尼・罗斯福・马丁路德・李开复・嫁衣曾经说过&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Where there is an Android App, there is an Application context.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没毛病，扎心了。App 运行的时候，肯定是存在至少一个 Application 实例的。同时，Context 我们再熟悉不过了，写代码的时候经常需要使用到 Context 实例，它一般是通过构造方法传递进来，通过方法的形式参数传递进来，或者是通过 attach 方法传递进我们需要用到的类。Context 实在是太重要了，以至于我经常恨不得着藏着掖着，随身带着，这样需要用到的时候就能立刻掏出来用用。但是换个角度想想，既然 App 运行的时候，Application 实例总是存在的，那么为何不设置一个全局可以访问的静态方法用于获取 Context 实例，这样以来就不需要上面那些繁琐的传递方式。&lt;/p&gt;
&lt;p&gt;说到这里，有的人可能说想这不是我们经常干的好事吗，有必要说的这么玄乎？少侠莫急，请听吾辈徐徐道来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="Context" scheme="http://kaedea.com/tags/Context/"/>
    
      <category term="Hook" scheme="http://kaedea.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>西方程序员跑得比谁都快</title>
    <link href="http://kaedea.com/2017/03/21/android/naughty-proguard-tuduki/"/>
    <id>http://kaedea.com/2017/03/21/android/naughty-proguard-tuduki/</id>
    <published>2017-03-21T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>昨天刚刚发表了一篇文章（<a href="http://kaedea.com/2017/03/20/android/naughty-proguard/">ProGuard 又搞了个大新闻</a>），主要吐槽的是项目里面使用 ProGuard 工具导致的一个诡异的坑。其中根本的原因就是，ProGuard 混淆 Java 注解类的时候，把两个方法混淆成同样的名字，导致 dx 工具在打包 <code>.dex</code> 文件的时候报错。</p><p>本来以为这件事情算是告一段落了，没想到自己还是太 Naive 了。今天早上突然收到了 ProGuard 开发者发来的一份邮件，Exciting！邮件里谈到了这次的坑出现的真正原因 —— Java 源码和字节码（bytecode）里方法的重载（OverLoading）。</p><a id="more"></a><h2 id="被雪藏的问题真正原因"><a href="#被雪藏的问题真正原因" class="headerlink" title="被雪藏的问题真正原因"></a>被雪藏的问题真正原因</h2><p>在上一篇文章里，我分析到这次问题的原因是</p><blockquote><p>ProGuard 工具在混淆注解类类 Route.java 的时候，把它的两个字段都混淆成 a 了，按道理应该是一个 a 和一个 b，不知道是不是 ProGuard 的 BUG，还是 Route 与其他库冲突了。</p></blockquote><p>本来我以为是 ProGuard 的 BUG，把注解类的两个字段都混淆成一样的名字，或者是 ProGuard 受到别的库的影响才出现了这个 BUG。显然，在 Java 代码里面，是不允许有两个名字相同且形参一样的方法的，哪怕是它们的返回值不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] foo() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"wor"</span>, <span class="string">"ld"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是无法重载的，IDE 会提示错误并且无法编译。虽然现在不少的新编程语言支持这样返回值类型不同的方法重载，但是在 Java 里行不通，原因也很简单，类似下面的方法立刻就会产生歧义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 无法确定调用的是哪个方法。</span></span><br><span class="line">    foo ();&#125;</span><br></pre></td></tr></table></figure><p>问题的原因虽然只是这么简单，但是其实在 <code>.class</code> 文件的字节码（bytecode）里，这样的重载方法是被允许的。为什么呢？简单点说，在字节码里面，对类的文件结构的描述十分严谨，方法调用必须有指定的返回类型，所以像上面那样的调用是不存在的，自然也就不存在产生歧义的问题。</p><p>假设现在有这样一个正常的类（上面的示例代码的正常版）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] foo1() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"wor"</span>, <span class="string">"ld"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        foo1();</span><br><span class="line">        String s = foo2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类编译成 <code>.class</code> 字节码文件后，它的文件结构大概是这样的。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">+ Program class: com&#x2F;bilibili&#x2F;routertest&#x2F;Hello</span><br><span class="line"> ...</span><br><span class="line">Interfaces (count &#x3D; 0):</span><br><span class="line">Constant Pool (count &#x3D; 30):</span><br><span class="line"> ...</span><br><span class="line">Fields (count &#x3D; 0):</span><br><span class="line"></span><br><span class="line">Methods (count &#x3D; 4):</span><br><span class="line">  - Method:       &lt;init&gt;()V</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      &#x3D; public Hello()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  + Method:       foo1()[Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      &#x3D; public java.lang.String[] foo1()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  + Method:       foo2()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      &#x3D; public java.lang.String foo2()</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">  + Method:       main()V</span><br><span class="line">    Access flags: 0x1</span><br><span class="line">      &#x3D; public void main()</span><br><span class="line">    Class member attributes (count &#x3D; 1):</span><br><span class="line">    + Code attribute instructions (code length &#x3D; 11, locals &#x3D; 2, stack &#x3D; 1):</span><br><span class="line">      [0] aload_0 v0</span><br><span class="line">      [1] invokevirtual#7</span><br><span class="line">        + Methodref [com&#x2F;bilibili&#x2F;routertest&#x2F;Hello.foo1 ()[Ljava&#x2F;lang&#x2F;String;]</span><br><span class="line">      [4] pop</span><br><span class="line">      [5] aload_0 v0</span><br><span class="line">      [6] invokevirtual#8</span><br><span class="line">        + Methodref [com&#x2F;bilibili&#x2F;routertest&#x2F;Hello.foo2 ()Ljava&#x2F;lang&#x2F;String;]</span><br><span class="line">      [9] astore_1 v1</span><br><span class="line">      [10] return</span><br><span class="line">      Code attribute exceptions (count &#x3D; 0):</span><br><span class="line">      Code attribute attributes (attribute count &#x3D; 1):</span><br><span class="line">      + Line number table attribute (count &#x3D; 3)</span><br><span class="line">        [0] -&gt; line 12</span><br><span class="line">        [5] -&gt; line 13</span><br><span class="line">        [10] -&gt; line 14</span><br><span class="line"></span><br><span class="line">Class file attributes (count &#x3D; 1):</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>我们重点关心其中的 <code>main () V</code> 方法，可以清楚的看到，上面的 Java 源码中，main 方法调用了 foo1 方法，虽然没有处理返回值，但是在字节码文件结构对应的方法里明确地指明了改该方法的的返回值类型是 <code>[Ljava/lang/String</code>，区别于 foo2 方法的 <code>Ljava/lang/String</code>。也就是说，字节码里面并不会存在我们上面提到的方法调用的歧义问题，因此可以支持相同形参不同返回值的方法的重载。</p><p>对于这个课题感兴趣的同学可以参考这篇出自 Oracle 的调研文章：<a href="https://community.oracle.com/docs/DOC-983207" target="_blank" rel="noopener">Return-Type-Based Method Overloading in Java Blog</a>。</p><h2 id="总结一些人参经验"><a href="#总结一些人参经验" class="headerlink" title="总结一些人参经验"></a>总结一些人参经验</h2><p>关于造成该问题原因的一些阐述。</p><ol><li>上一篇文章提到的 ProGuard 构建问题其实不是 ProGuard 的 BUG，而是 Android SDK 的 dx 工具的 BUG。</li><li>不是只有在开启 MultiDex 的时候才会出现这个问题，不开启问题也会存在，这个问题与 MultiDex 完全没有关系。</li><li>ProGuard 混淆的是字节码而不是 Java 源码，字节码支持相同形参不同返回值的方法的重载，ProGuard 为了最大限度压缩代码量，对后者的重载提供了支持。</li><li>不仅注解类，普通的类也会出现类似的问题。</li></ol><p>解决该问题的一些方法。</p><ol><li>如果不开启 ProGuard 的 <code>overloadaggressively</code> 功能，ProGuard 不会对字节码中相同形参不同返回值的方法进行重载（这个功能默认不开启）。</li><li>尝试将注解类的 RetentionPolicy 级别降级为 SOURCE 级别。</li><li>不要让注解类出现相同形参不同返回值不同名字的方法，不然可能被混淆成重载的方法。</li><li>Keep 住相应的注解类。</li></ol><p>以下是 ProGuard 开发者给出的建议。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Unfortunately, dx has a bug: it crashes on this overloading. Workarounds:</span><br><span class="line"></span><br><span class="line">- Do not use the option &#39;-overloadaggressively&#39; in your ProGuard configuration.</span><br><span class="line"></span><br><span class="line">- Alternatively, keep the original annotation method names:</span><br><span class="line"></span><br><span class="line">    -keepclassmembernames @interface * &#123; &lt;methods&gt;; &#125;</span><br><span class="line"></span><br><span class="line">The dx tool should then accept the code.</span><br><span class="line"></span><br><span class="line">If it works, you can post this solution in your blog.</span><br></pre></td></tr></table></figure><p>最后，感叹作者的反馈这么迅速。引用作者的一句原话，<code>It&#39;s a fast world!</code>，西方程序员跑的比谁都快。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 西方程序员跑得比谁都快Date = 2017-03-21 00:00:00Published = trueCategory = AndroidTag = ['Android', 'ProGuard', 'Annotation', 'AGP']FileLocate = androidFileName = naughty-proguard-tudukihexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天刚刚发表了一篇文章（&lt;a href=&quot;http://kaedea.com/2017/03/20/android/naughty-proguard/&quot;&gt;ProGuard 又搞了个大新闻&lt;/a&gt;），主要吐槽的是项目里面使用 ProGuard 工具导致的一个诡异的坑。其中根本的原因就是，ProGuard 混淆 Java 注解类的时候，把两个方法混淆成同样的名字，导致 dx 工具在打包 &lt;code&gt;.dex&lt;/code&gt; 文件的时候报错。&lt;/p&gt;
&lt;p&gt;本来以为这件事情算是告一段落了，没想到自己还是太 Naive 了。今天早上突然收到了 ProGuard 开发者发来的一份邮件，Exciting！邮件里谈到了这次的坑出现的真正原因 —— Java 源码和字节码（bytecode）里方法的重载（OverLoading）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="ProGuard" scheme="http://kaedea.com/tags/ProGuard/"/>
    
      <category term="Annotation" scheme="http://kaedea.com/tags/Annotation/"/>
    
      <category term="AGP" scheme="http://kaedea.com/tags/AGP/"/>
    
  </entry>
  
  <entry>
    <title>ProGuard 又搞了个大新闻</title>
    <link href="http://kaedea.com/2017/03/20/android/naughty-proguard/"/>
    <id>http://kaedea.com/2017/03/20/android/naughty-proguard/</id>
    <published>2017-03-20T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，Android 项目经常开启 ProGuard 功能来混淆代码，一方面可以降低应用被反编译后代码的友善度，增加被逆向的难度，另一方面开可以通过精简 Java API 的名字来减少代码的总量，从而精简应用编译后的体积。</p><p>ProGuard 有个比较坑爹的问题。在开发阶段，我们一般不启用 ProGuard，只有在构建 Release 包的时候才开启。因此，如果有一些 API 被混淆了会出现 BUG，那么在开发阶段我们往往无法察觉 BUG，只有在构建发布包的时候才发现，甚至要等发布到线上了才能发现，这种时候解决问题的成本就很大了。<br>不过今天被 ProGuard 坑的不是混淆 API 导致的 BUG，这货在之前相当长的一段时间里一直相安无事，最近突然又搞了个大新闻，而且问题排查起来相当蹊跷、诡异。</p><a id="more"></a><h2 id="新闻发生时候的背景"><a href="#新闻发生时候的背景" class="headerlink" title="新闻发生时候的背景"></a>新闻发生时候的背景</h2><p>最近在给项目的开发一个模块之间通讯用的路由框架，它需要有一些处理注解的 APT 功能，大概是长这个样子的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span> (uri = <span class="string">"action://sing/"</span>, desc = <span class="string">"念两句诗"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PoemAction</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>功能大概是这样的，我先编写一个叫做 <code>PoemAction</code>，它的业务功能主要是帮你念上两句诗。然后客户只需要调用 <code>Router.open (&quot;action://sing/&quot;)</code> 就可以当场念上两句诗，这也是现在一般路由框架的功能。其中的 <code>desc</code> 没有别的功能，只是为了在生成路由表的时候加上一些注释，说明当前的路由地址是干什么的，看起来像是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoGeneratedRouteTable</span> </span>&#123;<span class="function"><span class="keyword">public</span> Route <span class="title">find</span> <span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"action://sing/"</span>.equals (uri)) &#123;<span class="comment">// 念两句诗 return PoemActionRoute;&#125;</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，代码很完美，单元测试和调试阶段都没有发现任何问题，好，合并进 develop 分支了。搞定收工，我都不禁想赞美自己的才能了，先去栖霞路玩会儿先。半个小时候突然收到了工头 <a href="https://yrom.net/" target="_blank" rel="noopener">Yrom・半仙・灵魂架构师・Wang</a> 的电话，我还以为他也想来玩呢，结果他说不知道谁在项目的代码里下毒，导致构建机上有已经有几十个构建任务失败了。我了个去，我刚刚提交的代码，该不会是我的锅吧，赶紧回来。</p><h2 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h2><p>异常看起来是这样的。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &#39;:app:transformClassesWithMultidexlistForRelease&#39;.</span><br><span class="line">&gt; java.lang.UnsupportedOperationException (no error message)</span><br><span class="line"></span><br><span class="line">* Try:</span><br><span class="line">Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.</span><br><span class="line"></span><br><span class="line">BUILD FAILED</span><br></pre></td></tr></table></figure><p>这看起来好像是 MultiDex 的问题啊，但是没道理 Debug 构建没问题，而只有 Release 构建出问题了，<code>transformClassesWithMultidexlistForRelease</code> 任务的源码暂时也没有精力去看了，先解决阻塞同事开发的问题要紧。老规矩，使用 <strong>二分定位法</strong> 挨个回滚到 develop 上面的 commit 记录，逐个查看是那次提交导致的，结果还真是我的提交导致的。</p><p>难道是开了混淆，导致一些类找不到？但是类找不到只是运行时的异常而已，应该只会在运行 APP 的时候抛出 “ClassNotFoundException”，不应该导致构建失败啊。难道是 APT 生成的类格式不对，导致 Javac 在编译该类的时候失败？于是我打开由 APT 工具生成的 <code>AutoGeneratedRouteTable.java</code> 类文件瞧瞧，发文件类的格式很完美，没有问题，甚至由于担心是中文引起的问题，我还把 “念两句诗” 改成 “Sing two poems”，问题依旧。</p><p>总之一时半会无法排查出问题所在，还是赶紧解决 APK 的构建问题，现在因为构建失败的原因，旁边已经有一票同事正在摩拳擦掌准备把我狠狠的批判一番。所以我打算先去掉 APT 功能，不通过自动生成注册类的方式，而是通过手动代码注册的方式让路由工作，就当我以为事情告一段落的时候，我才发现我还是 “too young” 啊，构建机给了同样的错误反馈。</p><p>…………<br>……<br>…</p><p>这 TM 就尴尬了啊，我现在导致构建失败的提交与上一次正常构建的提交之间的差异就是给 <code>PeomAction</code> 加多了注解而已啊，而且这个注解现在都没有用到了，难道是注解本身的存在就会导致构建失败？</p><p>突然我想起来，注解类本身我是没有加入混淆的，因为代码里没有用反射的反射获取注解，而且我设计注解类本身的目的也只是为了帮我自动生成注册类而已，这些类是编译时生成的，所以不会受到混淆功能的影响。抱着死马当活马医的心态，我把注解里面的 <code>desc</code> 字段去掉了，万万没想到构建问题居然就解决了，而且就算我开启 APT 功能，问题还是没有重现，这…… 这与构建出问题的状态的差别只有一段注释的差别啊，没问题的代码看起来是这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoGeneratedRouteTable</span> </span>&#123;<span class="function"><span class="keyword">public</span> Route <span class="title">find</span> <span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"action://sing/"</span>.equals (uri)) &#123;(这里的注释没有了)</span><br><span class="line">            <span class="keyword">return</span> PoemActionRoute;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这难道是真实存在的某种膜法在干扰我的构建过程？突然我又想起来，因为注解类本身不需要写什么代码，所以我创建 <code>Route.java</code> 这个类后基本就没有对它进行过编辑了，我甚至已经忘了我对它写过什么代码，所以我决定看看是不是我写错了些什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Route &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">    <span class="function">String <span class="title">desc</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注解类看起来再普通不过，一般写完之后也不需要再怎么修改了，而且这个类我是直接参 (co) 考 (py) 另外一个优秀的 Java APT 项目 <a href="https://github.com/airbnb/DeepLinkDispatch" target="_blank" rel="noopener">DeepLinkDispatch</a> 的，想必也不会有什么大坑。目前看起来唯一有更改可能性的地方就是 <code>Target</code> 和 <code>Retention</code> 这两个属性，至于这俩的作用不属于此文章的范畴，不做展开。</p><p>首先，** 我试着把 <strong>**<code>Retention</code></strong> <strong>的级别由原来的</strong><strong><code>CLASS</code></strong> <strong>改成</strong><strong><code>SOURCE</code></strong> <strong>级别，没想到就这么一个小改动，编译居然通过了！如果不修改</strong><strong><code>Retention</code></strong> <strong>的级别，把注解里的</strong><strong><code>desc</code></strong> <strong>字段移除，只保留一个</strong><strong><code>value</code></strong> ** 字段，问题也能解决，真是神奇啊 **，顿时我好像感受到了一股来自古老东方的神秘力量。</p><p>在我一直以来的认知里，<code>RetentionPolicy.SOURCE</code> 是源码级别的注解，比如 <code>@Override</code>、<code>@WorkerThread</code>、<code>@VisibleForTest</code> 等这些注解类，这类的注解一般是配合 IDE 工作的，不会给代码造成任何实际影响，IDE 会获取这些注解，并向你提示哪些代码可能有问题，在编译阶段这类注解加与不加没有任何实际的影响。看一下源码的解释吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来如此，<code>RetentionPolicy.CLASS</code> 级别的注解会被保留到 <code>.class</code> 文件里，所以混淆的时候，注解类也会参与混淆，大概是混淆的时候出的问题吧。总之，先看看注解类 <code>Route.java</code> 被混淆后变成什么样子，查看 <code>build/output/release/mapping.txt</code> 文件。</p><figure class="highlight plain"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">moe.studio.router.Route -&gt; bl.buu:</span><br><span class="line">    java.lang.String[] value() -&gt; a</span><br><span class="line">    java.lang.String desc() -&gt; a</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>果然不出我所料，<strong>ProGuard 工具在混淆注解类类 **</strong><code>Route.java</code>** <strong>的时候，把它的两个字段都混淆成</strong><strong><code>a</code></strong> ** 了 **（按道理应该是一个 a 和一个 b，不知道是不是 ProGuard 的 BUG，还是 Route 与其他库冲突了）。</p><p>所以，最后的解决方案就是把 <code>Retention</code> 的级别由原来的 <code>CLASS</code> 降级成 <code>SOURCE</code>，或者把注解类的字段改成一个。顺便一说，现在大多的 Java APT 项目用的还是 <code>CLASS</code>，它们之所以没有遇到类似的问题，大多是因为他们都选择把整个注解类都 KEEP 住，不进行混淆了。</p><h2 id="一些姿势"><a href="#一些姿势" class="headerlink" title="一些姿势"></a>一些姿势</h2><p>通过这个事件我也发现了不少问题。其一，无论单元测试写得再完美，集成进项目之前还是有必要进行一次 Release 构建，以确保避免一些平时开发的时候容易忽略的问题，不然小心自己打自己的脸。以下是一次打脸现场。</p><p><img src="/assets/28777207_file_1489980325292_11b0a.png" alt=""></p><p>所以我决定，给项目的构建机加上一次 <strong>Daily Building</strong> 的功能，每天都定期构建一次，以便尽早发现问题。</p><p>其二，除了构建的问题之外，年轻人果然还是要多多学习，** 提高一下自己的知识水平 **。设想，如果我的 Java 基础够扎实的话，也就不会像这次一样，犯下 <code>RetentionPolicy</code> 错用这样低级的错误。如果有仔细阅读过 <code>transformClassesWithMultidexlistForRelease</code> 任务以及 ProGuard 工具的的源码的话，也许能很快定位到问题发生的根本原因，从而釜底抽薪一举解决问题，不像这次一样，阻塞一大半天开发进度。</p><p>以下放出这次定位问题的大致过程。<br>① 先定位 <code>transformClassesWithMultidexlistForRelease</code> 任务的源码。通过任务名字，可以很快地定位到 <code>MultiDexTransform.java</code> 这个类里面来，以下是这个类在执行任务时候做的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(@NonNull TransformInvocation invocation)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// Re-direct the output to appropriate log levels, just like the official ProGuard task.</span></span><br><span class="line">        LoggingManager loggingManager = invocation.getContext().getLogging();</span><br><span class="line">        loggingManager.captureStandardOutput(LogLevel.INFO);</span><br><span class="line">        loggingManager.captureStandardError(LogLevel.WARN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File input = verifyInputs(invocation.getReferencedInputs());</span><br><span class="line">            shrinkWithProguard(input);</span><br><span class="line">            computeList(input);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException | ProcessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TransformException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，MultiDexTransform 的主要工作是在 <code>shrinkWithProguard</code> 和 <code>computeList</code> 两个方法里面完成的。其中 <code>shrinkWithProguard</code> 的工作可以定位到 ProGuard 工具的 <code>ProGuard#execute</code> 方法里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    System.out.println(VERSION);</span><br><span class="line"></span><br><span class="line">    GPL.check();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configuration.dump != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以定位到 ProGuard 最后执行的 <code>dump ()</code> 方法里面，该方法生成了一个 <code>dump.txt</code> 文件，里面用文本的形式，记录了整个项目用到的所有类（混淆后的）的文件结构。查看任务的 LOG 信息以及 <code>dump.txt</code> 文件的内容，发现所有内容都正常生成，因此可以初步确定问题不是由于 <code>shrinkWithProguard</code> 引起的。</p><p>接着看看 <code>computeList</code> 方法，这个方法可以定位到以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">createMainDexList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull File allClassesJarFile,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull File jarOfRoots,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull EnumSet&lt;MainDexListOption&gt; options)</span> <span class="keyword">throws</span> ProcessException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BuildToolInfo buildToolInfo = mTargetInfo.getBuildTools();</span><br><span class="line">    ProcessInfoBuilder builder = <span class="keyword">new</span> ProcessInfoBuilder();</span><br><span class="line"></span><br><span class="line">    String dx = buildToolInfo.getPath(BuildToolInfo.PathId.DX_JAR);</span><br><span class="line">    <span class="keyword">if</span> (dx == <span class="keyword">null</span> || !<span class="keyword">new</span> File(dx).isFile()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"dx.jar is missing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.setClasspath(dx);</span><br><span class="line">    builder.setMain(<span class="string">"com.android.multidex.ClassReferenceListBuilder"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (options.contains(MainDexListOption.DISABLE_ANNOTATION_RESOLUTION_WORKAROUND)) &#123;</span><br><span class="line">        builder.addArgs(<span class="string">"--disable-annotation-resolution-workaround"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builder.addArgs(jarOfRoots.getAbsolutePath());</span><br><span class="line">    builder.addArgs(allClassesJarFile.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">    CachedProcessOutputHandler processOutputHandler = <span class="keyword">new</span> CachedProcessOutputHandler();</span><br><span class="line"></span><br><span class="line">    mJavaProcessExecutor.execute(builder.createJavaProcess(), processOutputHandler)</span><br><span class="line">            .rethrowFailure()</span><br><span class="line">            .assertNormalExitValue();</span><br><span class="line"></span><br><span class="line">    LineCollector lineCollector = <span class="keyword">new</span> LineCollector();</span><br><span class="line">    processOutputHandler.getProcessOutput().processStandardOutputLines(lineCollector);</span><br><span class="line">    <span class="keyword">return</span> ImmutableSet.copyOf(lineCollector.getResult());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，这里调用了 Android SDK 里面的 <code>dx.jar</code> 工具，入口类是 <code>com.android.multidex.ClassReferenceListBuilder</code>，并传入了两个参数，分别是 <code>jarOfRoots</code> 文件和 <code>allClassesJarFile</code> 文件。</p><p>② 定位到 <code>dx.jar</code> 工具里具体出问题的地方，通过上面的分析以及构建失败输出的 LOG，可以看到 Gradle 插件调用了 <code>dx.jar</code> 并传入了 <code>build/intermediates/multi-dex/release/componentClasses.jar</code> 和 <code>build/intermediates/transforms/proguard/release/jars/3/1f/main.jar</code> 两个文件。直接调用该命令试试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> com.android.dx.cf.iface.ParseException: name already added: string&#123;<span class="string">"a"</span>&#125;</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.parse(AttributeListParser.java:<span class="number">156</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.parseIfNecessary(AttributeListParser.java:<span class="number">115</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.getList(AttributeListParser.java:<span class="number">106</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.parse0(DirectClassFile.java:<span class="number">558</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.parse(DirectClassFile.java:<span class="number">406</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.parseToEndIfNecessary(DirectClassFile.java:<span class="number">397</span>)</span><br><span class="line">        at com.android.dx.cf.direct.DirectClassFile.getAttributes(DirectClassFile.java:<span class="number">311</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.hasRuntimeVisibleAnnotation(MainDexListBuilder.java:<span class="number">191</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.keepAnnotated(MainDexListBuilder.java:<span class="number">167</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.&lt;init&gt;(MainDexListBuilder.java:<span class="number">121</span>)</span><br><span class="line">        at com.android.multidex.MainDexListBuilder.main(MainDexListBuilder.java:<span class="number">91</span>)</span><br><span class="line">        at com.android.multidex.ClassReferenceListBuilder.main(ClassReferenceListBuilder.java:<span class="number">58</span>)</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: name already added: string&#123;<span class="string">"a"</span>&#125;</span><br><span class="line">        at com.android.dx.rop.annotation.Annotation.add(Annotation.java:<span class="number">208</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AnnotationParser.parseAnnotation(AnnotationParser.java:<span class="number">264</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AnnotationParser.parseAnnotations(AnnotationParser.java:<span class="number">223</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AnnotationParser.parseAnnotationAttribute(AnnotationParser.java:<span class="number">152</span>)</span><br><span class="line">        at com.android.dx.cf.direct.StdAttributeFactory.runtimeInvisibleAnnotations(StdAttributeFactory.java:<span class="number">616</span>)</span><br><span class="line">        at com.android.dx.cf.direct.StdAttributeFactory.parse0(StdAttributeFactory.java:<span class="number">93</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeFactory.parse(AttributeFactory.java:<span class="number">96</span>)</span><br><span class="line">        at com.android.dx.cf.direct.AttributeListParser.parse(AttributeListParser.java:<span class="number">142</span>)</span><br><span class="line">        ... <span class="number">11</span> more</span><br></pre></td></tr></table></figure><p>从异常的堆栈可以直接看出，dx 工具在执行 <code>AnnotationParser#parseAnnotation</code> 方法的时候出错了，原因是有两个相同的字段 <code>a</code>，这也刚好印证了上面 <code>mapping.txt</code> 文件里面的错误信息。</p><p>③ 最后定位到源码里具体出问题的地方，查看 dx 工具里的 <code>com.android.dx.rop.annotation.Annotation.java</code> 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;CstString, NameValuePair&gt; elements;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add an element to the set of (name, value) pairs for this instance.</span></span><br><span class="line"><span class="comment">     * It is an error to call this method if there is a preexisting element</span></span><br><span class="line"><span class="comment">     * with the same name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pair &#123;<span class="doctag">@code</span> non-null;&#125; the (name, value) pair to add to this instance</span></span><br><span class="line"><span class="comment">     */</span><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(NameValuePair pair)</span> </span>&#123;</span><br><span class="line">        throwIfImmutable();</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"pair == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        CstString name = pair.getName();</span><br><span class="line">        <span class="keyword">if</span> (elements.get(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name already added: "</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">        elements.put(name, pair);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到此，** 从成功定位到产生异常的具体地方 **。</p><p>④ 此外，从 <code>:app:assembleRelease --debug --stacktrace</code> 的异常堆栈里是无法直接看出具体出异常的地方的错误信息的，不过可以通过 <code>:app:assembleRelease --full-stacktrace</code> 命令输出更多的错误堆栈，从而直观地看出一些猫腻来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Caused by: com.android.ide.common.process.ProcessException: Error <span class="keyword">while</span> executing java process with main <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">android</span>.<span class="title">multidex</span>.<span class="title">ClassReferenceListBuilder</span> <span class="title">with</span> <span class="title">arguments</span> </span>&#123;build/intermediates/multi-dex/release/componentClasses.jar build/intermediates/transforms/proguard/release/jars/<span class="number">3</span>/<span class="number">1f</span>/main.jar&#125;</span><br><span class="line">        at com.android.build.gradle.internal.process.GradleProcessResult.buildProcessException(GradleProcessResult.java:<span class="number">74</span>)</span><br><span class="line">        at com.android.build.gradle.internal.process.GradleProcessResult.assertNormalExitValue(GradleProcessResult.java:<span class="number">49</span>)</span><br><span class="line">        at com.android.builder.core.AndroidBuilder.createMainDexList(AndroidBuilder.java:<span class="number">1384</span>)</span><br><span class="line">        at com.android.build.gradle.internal.transforms.MultiDexTransform.callDx(MultiDexTransform.java:<span class="number">309</span>)</span><br><span class="line">        at com.android.build.gradle.internal.transforms.MultiDexTransform.computeList(MultiDexTransform.java:<span class="number">265</span>)</span><br><span class="line">        at com.android.build.gradle.internal.transforms.MultiDexTransform.transform(MultiDexTransform.java:<span class="number">186</span>)</span><br></pre></td></tr></table></figure><p>从上面的堆栈信息可以直接看出 Gradle 插件在调用 dx 工具的时候出现异常了（Process 的返回值不是 0，也就是 Java 程序里面调用了 System.exit (0) 之外的结束方法），对应的类为 <code>ClassReferenceListBuilder</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> keepAnnotated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (argIndex &lt; args.length -<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args[argIndex].equals(DISABLE_ANNOTATION_RESOLUTION_WORKAROUND)) &#123;</span><br><span class="line">            keepAnnotated = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">"Invalid option "</span> + args[argIndex]);</span><br><span class="line">            printUsage();</span><br><span class="line">            System.exit(STATUS_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        argIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (args.length - argIndex != <span class="number">2</span>) &#123;</span><br><span class="line">        printUsage();</span><br><span class="line">        System.exit(STATUS_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MainDexListBuilder builder = <span class="keyword">new</span> MainDexListBuilder(keepAnnotated, args[argIndex],</span><br><span class="line">                args[argIndex + <span class="number">1</span>]);</span><br><span class="line">        Set&lt;String&gt; toKeep = builder.getMainDexList();</span><br><span class="line">        printList(toKeep);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.err.println(<span class="string">"A fatal error occurred: "</span> + e.getMessage());</span><br><span class="line">        System.exit(STATUS_ERROR);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由其中的 <code>MainDexListBuilder builder = new MainDexListBuilder (keepAnnotated, args [argIndex], args [argIndex + 1])</code> 也能进一步定位到上面的 <code>com.android.dx.rop.annotation.Annotation.java</code> 出问题的地方。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>推荐阅读 <a href="https://www.easydone.cn/2017/01/02/" target="_blank" rel="noopener">ProGuard 在插件化里的应用</a>。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = ProGuard 又搞了个大新闻Date = 2017-03-20 00:00:00Published = trueCategory = AndroidTag = ['Android', 'ProGuard', 'Annotation']FileLocate = androidFileName = naughty-proguardhexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，Android 项目经常开启 ProGuard 功能来混淆代码，一方面可以降低应用被反编译后代码的友善度，增加被逆向的难度，另一方面开可以通过精简 Java API 的名字来减少代码的总量，从而精简应用编译后的体积。&lt;/p&gt;
&lt;p&gt;ProGuard 有个比较坑爹的问题。在开发阶段，我们一般不启用 ProGuard，只有在构建 Release 包的时候才开启。因此，如果有一些 API 被混淆了会出现 BUG，那么在开发阶段我们往往无法察觉 BUG，只有在构建发布包的时候才发现，甚至要等发布到线上了才能发现，这种时候解决问题的成本就很大了。&lt;br&gt;不过今天被 ProGuard 坑的不是混淆 API 导致的 BUG，这货在之前相当长的一段时间里一直相安无事，最近突然又搞了个大新闻，而且问题排查起来相当蹊跷、诡异。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="ProGuard" scheme="http://kaedea.com/tags/ProGuard/"/>
    
      <category term="Annotation" scheme="http://kaedea.com/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 注释优化插件：Comment Formatter</title>
    <link href="http://kaedea.com/2016/12/01/tools/comment-formatter/"/>
    <id>http://kaedea.com/2016/12/01/tools/comment-formatter/</id>
    <published>2016-12-01T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//               +---------------------------------------------+</span></span><br><span class="line"><span class="comment">//               | public static final FiledA mFiledA; // xxx  |</span></span><br><span class="line"><span class="comment">//               | private static final FiledB mFiledB; // xxx |</span></span><br><span class="line"><span class="comment">//               | public FiledC mFiledC; // xxx               |</span></span><br><span class="line"><span class="comment">//               | protected final FiledD mFiledD; // xxx      |</span></span><br><span class="line"><span class="comment">//               | FiledE mFiledE; // xxx                      |</span></span><br><span class="line"><span class="comment">//               |                     |                       |</span></span><br><span class="line"><span class="comment">//               |                     v                       |</span></span><br><span class="line"><span class="comment">//               | public static final FiledA mFiledA;  // xxx |</span></span><br><span class="line"><span class="comment">//               | private static final FiledB mFiledB; // xxx |</span></span><br><span class="line"><span class="comment">//               | public FiledC mFiledC;               // xxx |</span></span><br><span class="line"><span class="comment">//               | protected final FiledD mFiledD;      // xxx |</span></span><br><span class="line"><span class="comment">//               | FiledE mFiledE;                      // xxx |</span></span><br><span class="line"><span class="comment">//               +---------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>Comment Formatter is an IntelliJ IDEA plugin (also works in Android Studio) that formats comments as above. It will force all the comments to align to the longest one.</p><p><strong>Getting Started</strong></p><ol><li>Install <code>CommentFormatter</code> from <a href="https://github.com/kaedea/comment-formatter/releases" target="_blank" rel="noopener">release</a> or <a href="https://plugins.jetbrains.com/plugin/9337?pr=idea" target="_blank" rel="noopener">IntelliJ Plugin Repository</a>.</li><li>Select all the lines which you wanna format.</li><li>Select <code>Tool - Format comment</code> or toggle <code>Ctrl + Cmd + L</code> to format.</li></ol><p><a href="https://github.com/kaedea/comment-formatter" target="_blank" rel="noopener">Check it out</a>.</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = IDEA 注释优化插件：Comment FormatterDate = 2016-12-01Published = trueCategory = UtilityTag = ['生产工具', 'IDEA Plugin']FileLocate = toolsFileName = comment-formatterhexo.comments = truehexo.layout = linkhexo.link = https://github.com/kaedea/comment-formatter-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Utility" scheme="http://kaedea.com/categories/Utility/"/>
    
    
      <category term="生产工具" scheme="http://kaedea.com/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDEA Plugin" scheme="http://kaedea.com/tags/IDEA-Plugin/"/>
    
  </entry>
  
  <entry>
    <title>通过预安装给 MultiDex 加速</title>
    <link href="http://kaedea.com/2016/11/22/android/pre-multidex/"/>
    <id>http://kaedea.com/2016/11/22/android/pre-multidex/</id>
    <published>2016-11-22T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>在 Android Kikat 及以前的 Android 系统上，构建或安装 Apk 会出现 “<strong>65535 方法数超标 **” 以及 “</strong>INSTALL_FAILED_DEXOPT**” 问题，MultiDex 是 Google 为了解决这个问题问题而开发的一个 Support 库。MultiDex 出现的具体背景、使用方式可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>，而 MultiDex Support 库的工作机制、源码分析可以参考 <a href="http://kaedea.com/2016/11/11/android/multidex-source-code/">MultiDex 工作原理分析和优化方案</a>。</p><p>MultiDex 的使用虽然很简单便捷，但是有个比较蛋疼的问题，就是在 App 第一次冷启动的时候会产生明显的卡顿现象。经过测试和统计，根据 Apk 包的大小、Android 系统版本的不同，这个卡顿时间一般是 2000 到 5000 毫秒左右，极端的情况下甚至可以到 20000 + 毫秒。通过之前的分析，我们知道具体的卡顿产生在 MultiDex 解压、优化 dex 这两个过程，而且只在第一次冷启动的时候才会触发这两个过程。那么优化的方式也很简单，在安装 Apk 前先对新版本的 Apk 做好解压和优化工作，就能在安装后第一次冷启动的时候避开这两个耗时的过程了。</p><a id="more"></a><h2 id="MultiDex-是如何判断是否需要重新解压和优化-dex-的"><a href="#MultiDex-是如何判断是否需要重新解压和优化-dex-的" class="headerlink" title="MultiDex 是如何判断是否需要重新解压和优化 dex 的"></a>MultiDex 是如何判断是否需要重新解压和优化 dex 的</h2><p>在之前的章节里面讲到，MultiDex 在第一次做完解压和优化 dex 之后，会保留当前 Apk 的一些信息，下一次启动时候后读取这些配置信息再判断是否需要重新解压和优化 dex 文件。<br>这个判断主要是在 MultiDexExtractor#load (Context, ApplicationInfo, File, boolean) 方法里进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span><span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!forceReload &amp;&amp; !isModified(context, sourceApk, currentCrc)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                files = loadExistingExtractions(context, sourceApk, dexDir);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ...</span><br><span class="line">                files = performExtractions(sourceApk, dexDir);</span><br><span class="line">                putStoredApkInfo(context,</span><br><span class="line">                        getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            files = performExtractions(sourceApk, dexDir);</span><br><span class="line">            putStoredApkInfo(context, getTimeStamp(sourceApk), currentCrc, files.size() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次调用这个方法的时候，forceReload 为 false，则不需要强制重新解压 dex。然后调用了 <code>isModified</code> 这个方法判断当前 App 的 Apk 包是否被修改过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isModified</span><span class="params">(Context context, File archive, <span class="keyword">long</span> currentCrc)</span> </span>&#123;</span><br><span class="line">    SharedPreferences prefs = getMultiDexPreferences(context);</span><br><span class="line">    <span class="keyword">return</span> (prefs.getLong(KEY_TIME_STAMP, NO_VALUE) != getTimeStamp(archive))</span><br><span class="line">            || (prefs.getLong(KEY_CRC, NO_VALUE) != currentCrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isModified</code> 方法主要是判断当前 App 的 Apk 包的 CRC 值是否和上一次解压 dex 时记录的 Apk 包 CRC 一样（CRC 值可以认为是一个稀疏的 MD5 算法，它的时间复杂度低很多，但是计算结果容易产生冲突），以及 Apk 文件的修改时间（文件的 Last Modified Time）是否一致。如果这两项都一致的话就认为 Apk 文件没有产生变化（没有覆盖安装过），因此上一次解压和优化 dex 得到的缓存文件可以复用。</p><p>当然，光 Apk 包没有修改过这一项条件还不够，接下来调用了这个判断主要是在 MultiDexExtractor#loadExistingExtractions (Context, File, File)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;File&gt; <span class="title">loadExistingExtractions</span><span class="params">(Context context, File sourceApk, File dexDir)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line">    <span class="keyword">int</span> totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;File&gt;(totalDexNumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> secondaryNumber = <span class="number">2</span>; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">        String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">        File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">        <span class="keyword">if</span> (extractedFile.isFile()) &#123;</span><br><span class="line">            files.add(extractedFile);</span><br><span class="line">            <span class="keyword">if</span> (!verifyZipFile(extractedFile)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Invalid ZIP file."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing extracted secondary dex file '"</span> +</span><br><span class="line">                    extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先通过 SharePreference 读取上一次 MultiDex 保存的 Apk 包的 dex 数量 totalDexNumber，然后挨个加载预定的文件路径上的 dex 文件，加载文件的的同时还通过 <code>verifyZipFile</code> 方法判断 dex 文件的合法性。如果这个过程出现异常就认为获取上一次缓存的 dex 文件失败，需要重新解压。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verifyZipFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ZipFile zipFile = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zipFile.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to close zip file: "</span> + file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZipException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"File "</span> + file.getAbsolutePath() + <span class="string">" is not a valid zip file."</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Got an IOException trying to open zip file: "</span> + file.getAbsolutePath(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>verifyZipFile</code> 这个方法非常简单，解压 dex 文件的时候，解压出来的文件被保存成 Zip 包，这个方法这是检查缓存的 dex 文件是否是 Zip 包。感觉不靠谱，虽然检查 MD5 值比较耗时不适合这种情景，不过好歹也像检查 Apk 包的 CRC 值和修改时间一样，检查 dex 缓存文件的 CRC 和修改时间啊。不过读取 SharePreference 配置是一个 IO 操作，如果保存的数值太多的话，也是有增加耗时和 IO 异常的风险的。</p><p>到这里我们的方案就清晰了：</p><ol><li>在安装新 Apk 前，先做好 dex 的解压和优化，得到 dex 压缩包（.zip）列表和 dexopt 后的 odex 文件（.dex）列表。</li><li>把 dex/odex 文件保存到一个内部存储路径 PATH_A，同时使用 SP 记录新版本 Apk 的 CRC、dex 数量，以及解压出来的每一个 dex 的 CRC 值。</li><li>安装新版本 Apk 后，启动时在执行 MultiDex 前，把 PATH_A 路径上的缓存文件移动（rename）到 MultiDex 的缓存路径 PATH_B 上，同时保存当前 Apk 的 CRC、修改时间以及 dex 数量到 MultiDex 对应的 SP 配置上。</li><li>执行原有 MultiDex 逻辑，让 MultiDex 以为之前已经做过解压和优化 dex 工作，从而绕开第一次 MultiDex 时候的耗时。</li><li>第一次成功启动新 Apk 后，对 dex 进行校验工作，如果校验失败则清除 dex 缓存，强制让 App 在下一次启动的时候再执行一遍 MultiDex。</li></ol><h2 id="预解压（PreMultiDex）详细的流程图"><a href="#预解压（PreMultiDex）详细的流程图" class="headerlink" title="预解压（PreMultiDex）详细的流程图"></a>预解压（PreMultiDex）详细的流程图</h2><p>注：</p><ol><li>流程图的绿色部分为文件锁（FileLock）操作，主要是为了多进程同步。</li><li>红色部分为耗时的操作。</li><li>Dex 路径为 MultiDex 过程中用于存储解压出来的 dex 文件的路径（/data/data//code_cache）。</li><li>PreDex 路径为存储预解压得到的缓存文件的内部路径（/data/data//code_cache_pre）。</li><li>MultiDex 从 Apk 包解压出来的 dex 文件会被压缩成 Zip 包（.zip），而执行 dexopt 操作后生成的 odex 文件文件名为.dex，这两个容易搞混。</li></ol><h3 id="安装新-Apk-前先解压和优化-dex"><a href="#安装新-Apk-前先解压和优化-dex" class="headerlink" title="安装新 Apk 前先解压和优化 dex"></a>安装新 Apk 前先解压和优化 dex</h3><p>这个环节必须在升级 Apk 前，由旧版本的 Apk 进行，也就是要求 App 拥有 ** 自主更新 ** 的逻辑。</p><p><img src="/assets/006y8lvagw1fam9ukwfv1j30jr0vvgpm.jpg" alt=""></p><h3 id="第一次运行新-Apk-时，移动预先安装好的-dex-文件"><a href="#第一次运行新-Apk-时，移动预先安装好的-dex-文件" class="headerlink" title="第一次运行新 Apk 时，移动预先安装好的 dex 文件"></a>第一次运行新 Apk 时，移动预先安装好的 dex 文件</h3><p>从旧版的 Apk 覆盖安装新的 Apk 后，第一次运行 App 时 MultiDex 主要的耗时过程。这时需要把在旧版本 Apk 预安装得到的 dex 缓存文件移动到 MultiDex 使用的存储路径上。</p><p><img src="/assets/006y8lvagw1fam9pz6n4rj30kr19aq9o.jpg" alt=""></p><h3 id="第一次运行新-Apk-后，检查-dex-文件是否正确"><a href="#第一次运行新-Apk-后，检查-dex-文件是否正确" class="headerlink" title="第一次运行新 Apk 后，检查 dex 文件是否正确"></a>第一次运行新 Apk 后，检查 dex 文件是否正确</h3><p>原有的 MultiDex，dex 文件时同步从 Apk 包里解压出来的，所以不存在 dex 文件和 Apk 版本对不上的问题。而 <strong>PreMultiDex</strong> 的方案的一个问题 ui 是，解压 dex 文件和使用 dex 文件这两个过程是分开的，无论版本控制做得再精确，理论上也存在版本出错的问题（比如从 A 版本解压得到了 dex 文件，而用户却选择覆盖安装了 B 版本，这时候由于代码逻辑的不严谨导致 B 版本的 Apk 使用了 A 版本解压出来的 dex 文件）。如果想要确保 dex 文件的正确性，需要对 Apk 包里面的 dex 文件和解压出来的 dex 文件做一下 MD5 值校验，而这个过程比较耗时，不适合在 App 启动的时候做，不然 <strong>PreMultiDex</strong> 就失去了意义。因此，需要在第一次运行新 Apk 后，启动 dex 的校验工作，在 Worker 线程对 dex 进行校验，如果校验失败则清除 dex 缓存，强制让 App 在下一次启动的时候再执行一遍 MultiDex。</p><p><img src="/assets/006y8lvagw1fam9polrlrj30k313jwjf.jpg" alt=""></p><h3 id="恢复-MultiDex"><a href="#恢复-MultiDex" class="headerlink" title="恢复 MultiDex"></a>恢复 MultiDex</h3><p>在 MultiDex 校验失败后，需要清空 MultiDex 的缓存文件，禁用 <strong>PreMultiDex</strong> 功能，并且强制让 App 在下一次启动的时候再执行一遍 MultiDex。</p><p><img src="/assets/006y8lvagw1fam9pce8p3j30dt0lognc.jpg" alt=""></p><h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><h3 id="dex-文件、odex-文件？"><a href="#dex-文件、odex-文件？" class="headerlink" title="dex 文件、odex 文件？"></a>dex 文件、odex 文件？</h3><p>dex 文件是 Android 虚拟机使用的可执行文件（从 Java 类编译得到），相当于 JVM 虚拟机用的 class 文件。但是与 class 文件不同，Android 系统并不能直接使用 dex 文件，需要先使用 dexopt 工具对 dex 文件进行一次优化工作（Optimize），优化得到的 odex 文件才能被虚拟机加载。不同的 Android 设备需要不同格式的 odex 文件，所以这个过程只能在 Android 设备上进行，而不能在构建 Apk 的时候就处理好。</p><p>dex 文件在 Apk 包里的文件后缀名是 <strong>.dex</strong>，MultiDex 从 Apk 包里解压出 dex 文件后会压缩成 Zip 包，文件后缀名是 <strong>.zip</strong>。对 dex 文件进行 dexopt 操作后，会生成相同文件名的 odex 文件，后缀名是 <strong>.dex</strong>，odex 文件会比 dex 文件大许多，不要搞混这些文件。</p><p>至于为什么 MultiDex 解压 dex 文件时会进行压缩工作，可能是因为压缩后的压缩包会占用比较小的内部存储空间，因为 MultiDex 本来就是给旧版本的 Android 系统使用，一些早期的 Android 设备拥有的内部存储空间非常有限，而这些 dex 文件对于 App 的运行时必须的，所以才需要尽量压缩 dex 的体积。压缩过程会有明显的耗时，经过测试，如果不进行压缩，直接从 Apk 里解压 dex 文件，则 MultiDex 过程会有大约 <strong>1/3</strong> 的加速效果。</p><h3 id="dexopt-缓存"><a href="#dexopt-缓存" class="headerlink" title="dexopt 缓存"></a>dexopt 缓存</h3><p>MultiDex 其实并没有刻意保留 dexopt 后的缓存，如果只保留 dex 文件，而不保留 odex 文件，那么下一次启动执行 MultiDex 的时候，不需要重新解压 dex 文件，但是依然需要 dexopt 并产生 odex 文件，这个过程大概会占用 MultiDex 总耗时的一般左右。如果 odex 文件存在，但是已经损坏了，或者是一个非法的 odex 文件，依然会触发 dexopt 工作。也就是说，加载 dex 文件并创建 DexFile 对象的时候，Android 系统会判断 odex 的缓存，以及缓存文件是否正确，具体过程在 <a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a> 里实现，有兴趣的同学可以找找 dex 文件结构分析的文章，这里就不挖坑了。</p><h3 id="关于-dex-文件校验"><a href="#关于-dex-文件校验" class="headerlink" title="关于 dex 文件校验"></a>关于 dex 文件校验</h3><p>其实，如果 dex 文件和 Apk 的版本对不上的话，一般在启动 App 的时候就会出现 ClassNotFound 异常而导致 App 崩溃，接着再次启动由于没有重新 MultiDex 也会继续崩溃。而崩溃的时候，可能 App 崩溃上报系统还没来得及初始化，所以没有办法发现崩溃的问题。</p><p>为了防止这种问题，可以开发一个 ** 恢复模式 ** 或者 ** 安全模式 ** 的功能，当 App 出现连续的崩溃的时候，会进入恢复模式的状态，清空一些可能导致异常的数据（比如 PreMultiDex 的缓存），这样就能避免 App 因为连续崩溃而不能使用。至于怎么实现恢复，这已经是另一个领域的功能了，这里不再展开。<br>参考链接： <a href="https://android.googlesource.com/platform/frameworks/multidex/" target="_blank" rel="noopener">Google Multidex</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 通过预安装给 MultiDex 加速Date = 2016-11-22 00:00:00Published = trueCategory = AndroidTag = ['Android', 'MultiDex', 'APM', '启动速度']FileLocate = androidFileName = pre-multidexhexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Android Kikat 及以前的 Android 系统上，构建或安装 Apk 会出现 “&lt;strong&gt;65535 方法数超标 **” 以及 “&lt;/strong&gt;INSTALL_FAILED_DEXOPT**” 问题，MultiDex 是 Google 为了解决这个问题问题而开发的一个 Support 库。MultiDex 出现的具体背景、使用方式可以参考 &lt;a href=&quot;http://kaedea.com/2015/09/02/android/enable-multidex/&quot;&gt;给 App 启用 MultiDex 功能&lt;/a&gt;，而 MultiDex Support 库的工作机制、源码分析可以参考 &lt;a href=&quot;http://kaedea.com/2016/11/11/android/multidex-source-code/&quot;&gt;MultiDex 工作原理分析和优化方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;MultiDex 的使用虽然很简单便捷，但是有个比较蛋疼的问题，就是在 App 第一次冷启动的时候会产生明显的卡顿现象。经过测试和统计，根据 Apk 包的大小、Android 系统版本的不同，这个卡顿时间一般是 2000 到 5000 毫秒左右，极端的情况下甚至可以到 20000 + 毫秒。通过之前的分析，我们知道具体的卡顿产生在 MultiDex 解压、优化 dex 这两个过程，而且只在第一次冷启动的时候才会触发这两个过程。那么优化的方式也很简单，在安装 Apk 前先对新版本的 Apk 做好解压和优化工作，就能在安装后第一次冷启动的时候避开这两个耗时的过程了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="APM" scheme="http://kaedea.com/tags/APM/"/>
    
      <category term="MultiDex" scheme="http://kaedea.com/tags/MultiDex/"/>
    
      <category term="启动速度" scheme="http://kaedea.com/tags/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>MultiDex 工作原理分析和优化方案</title>
    <link href="http://kaedea.com/2016/11/11/android/multidex-source-code/"/>
    <id>http://kaedea.com/2016/11/11/android/multidex-source-code/</id>
    <published>2016-11-11T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>动态加载技术（插件化）系列已经坑了有一段时间了，不过 UP 主我并没有放弃治疗哈，相信在不就的未来就可以看到 “系统 Api Hook 模式” 和插件化框架 Frontia 的更新了。今天要讲的是动态加载技术的亲戚 —— MultiDex。他们的核心原理之一都是 dex 文件的加载。</p><p>MultiDex 是 Google 为了解决 “<strong>65535 方法数超标 **” 以及 “</strong>INSTALL_FAILED_DEXOPT**” 问题而开发的一个 Support 库，具体如何使用 MultiDex 现在市面已经有一大堆教程（可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>），这里不再赘述。这篇日志主要是配合源码分析 MultiDex 的工作原理，以及提供一些 MultiDex 优化的方案。</p><a id="more"></a><h2 id="Dex-的工作机制"><a href="#Dex-的工作机制" class="headerlink" title="Dex 的工作机制"></a>Dex 的工作机制</h2><p>等等，这个章节讲的不是 MultiDex 吗，怎么变成 Dex 了？没错哈，没有 Dex，哪来的 MultiDex。在 Android 中，对 Dex 文件操作对应的类叫做 DexFile。在 <a href="http://kaedea.com/2016/02/07/android-dynamical-loading-02-classloader/">CLASSLOADER 的工作机制</a> 中，我们说到：</p><blockquote><p>对于 Java 程序来说，编写程序就是编写类，运行程序也就是运行类（编译得到的 class 文件），其中起到关键作用的就是类加载器 ClassLoader。</p></blockquote><p>Android 程序的每一个 Class 都是由 ClassLoader#loadClass 方法加载进内存的，更准确来说，** 一个 ClassLoader 实例会有一个或者多个 DexFile 实例 **，调用了 ClassLoader#loadClass 之后，ClassLoader 会通过类名，在自己的 DexFile 数组里面查找有没有那个 DexFile 对象里面存在这个类，如果都没有就抛 ClassNotFound 异常。ClassLoader 通过调用 DexFile 的一个叫 defineClass 的 Native 方法去加载指定的类，这点与 JVM 略有不同，后者是直接调用 ClassLoader#defineCLass 方法，反正最后实际加载类的方法都叫 defineClass 就没错了🌝。</p><h3 id="创建-DexFile-对象"><a href="#创建-DexFile-对象" class="headerlink" title="创建 DexFile 对象"></a>创建 DexFile 对象</h3><p>首先来看看造 DexFile 对象的构方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCookie;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mFileName;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(file.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexFile</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mCookie = openDexFile(fileName, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        mFileName = fileName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DexFile</span><span class="params">(String sourceName, String outputName, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        mCookie = openDexFile(sourceName, outputName, flags);</span><br><span class="line">        mFileName = sourceName;</span><br><span class="line">        guard.open(<span class="string">"close"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> DexFile <span class="title">loadDex</span><span class="params">(String sourcePathName, String outputPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DexFile(sourcePathName, outputPathName, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        String slashName = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">return</span> loadClassBinaryName(slashName, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClassBinaryName</span><span class="params">(String name, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, loader, mCookie);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> Class <span class="title">defineClass</span><span class="params">(String name, ClassLoader loader, <span class="keyword">int</span> cookie)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(String sourceName, String outputName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">openDexFile</span><span class="params">(<span class="keyword">byte</span>[] fileContents)</span></span></span><br><span class="line"><span class="function">    ...</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>通过以前分析过的源码，我们知道 ClassLoader 主要是通过 DexFile.loadDex 这个静态方法来创建它需要的 DexFile 实例的，这里创建 DexFile 的时候，保存了 Dex 文件的文件路径 mFileName，** 同时调用了 openDexFile 的 Native 方法打开 Dex 文件 ** 并返回了一个 mCookie 的整型变量（我不知道这个干啥用的，我猜它是一个 C++ 用的资源句柄，用于 Native 层访问具体的 Dex 文件）。在 Native 层的 openDexFile 方法里，主要做了检查当前创建来的 Dex 文件是否是有效的 Dex 文件，还是是一个带有 Dex 文件的压缩包，还是一个无效的 Dex 文件。</p><h3 id="加载-Dex-文件里的类"><a href="#加载-Dex-文件里的类" class="headerlink" title="加载 Dex 文件里的类"></a>加载 Dex 文件里的类</h3><p>加载类的时候，ClassLoader 又是通过 DexFile#loadClass 这个方法来完成的，这个方法里调用了 defineClass 这个 Native 方法，** 看来 DexFile 才是加载 Class 的具体 API，加载 Dex 文件和加载具体 Class 都是通过 Native 方法完成 **，ClassLoader 有点名不副实啊。</p><h2 id="MultiDex-的工作机制"><a href="#MultiDex-的工作机制" class="headerlink" title="MultiDex 的工作机制"></a>MultiDex 的工作机制</h2><p>当一个 Dex 文件太肥的时候（方法数目太多、文件太大），在打包 Apk 文件的时候就会出问题，就算打包的时候不出问题，在 Android 5.0 以下设备上安装或运行 Apk 也会出问题（具体原因可以参考 <a href="http://kaedea.com/2015/09/02/android/enable-multidex/">给 App 启用 MultiDex 功能</a>）。既然一个 Dex 文件不行的话，那就把这个硕大的 Dex 文件拆分成若干个小的 Dex 文件，刚好一个 ClassLoader 可以有多个 DexFile，这就是 MultiDex 的基本设计思路。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>MultiDex 的工作流程具体分为两个部分，一个部分是打包构建 Apk 的时候，将 Dex 文件拆分成若干个小的 Dex 文件，这个 Android Studio 已经帮我们做了（设置 “multiDexEnabled true”），另一部分就是在启动 Apk 的时候，同时加载多个 Dex 文件（具体是加载 Dex 文件优化后的 Odex 文件，不过文件名还是.dex），这一部分工作从 Android 5.0 开始系统已经帮我们做了，但是在 Android 5.0 以前还是需要通过 MultiDex Support 库来支持（MultiDex.install (Context)）。</p><p>所以我们需要关心的是第二部分，这个过程的简单示意流程图如下。</p><p><img src="/assets/4d91c7cd_4563_4391_a0a2_9ef1d8624c9c_untitled.png" alt=""></p><p>（图中红色部分为耗时比较大的地方）</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>现在官方已经部署的 MultiDex Support 版本是 <code>com.android.support:multidex:1.0.1</code>，但是现在仓库的 master 分支已经有了许多新的提交（其中最明显的区别是加入了 FileLock 来控制多进程同步问题），所以这里分析的源码都是最新的 master 分支上的。</p><p>MultiDex Support 的入口是 <code>MultiDex.install (Context)</code>，先从这里入手吧。（这次我把具体的分析都写在代码的注释了，这样看是不是更简洁明了些？）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span> <span class="params">(Context context)</span> </span>&#123;Log.i (TAG, <span class="string">"install"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判读是否需要执行 MultiDex。if (IS_VM_MULTIDEX_CAPABLE) &#123;Log.i (TAG, "VM has multidex support, MultiDex support library is disabled.");</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; MIN_SDK_VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"Multi dex installation failed. SDK"</span> + Build.VERSION.SDK_INT</span><br><span class="line">                    + <span class="string">"is unsupported. Min SDK version is"</span> + MIN_SDK_VERSION + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;ApplicationInfo applicationInfo = getApplicationInfo (context);</span><br><span class="line">            <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;<span class="comment">// Looks like running on a test Context, so just return without patching.return;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 如果这个方法已经调用过一次，就不能再调用了。synchronized (installedApk) &#123;</span></span><br><span class="line">                String apkPath = applicationInfo.sourceDir;</span><br><span class="line">                <span class="keyword">if</span> (installedApk.contains (apkPath)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">                installedApk.add (apkPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果当前 Android 版本已经自身支持了 MultiDex，依然可以执行 MultiDex 操作，// 但是会有警告。if (Build.VERSION.SDK_INT&gt; MAX_SUPPORTED_SDK_VERSION) &#123;</span></span><br><span class="line">                    Log.w (TAG, <span class="string">"MultiDex is not guaranteed to work in SDK version"</span></span><br><span class="line">                            + Build.VERSION.SDK_INT + <span class="string">": SDK version higher than"</span></span><br><span class="line">                            + MAX_SUPPORTED_SDK_VERSION + <span class="string">"should be backed by"</span></span><br><span class="line">                            + <span class="string">"runtime with built-in multidex capabilty but it's not the"</span></span><br><span class="line">                            + <span class="string">"case here: java.vm.version=\""</span></span><br><span class="line">                            + System.getProperty (<span class="string">"java.vm.version"</span>) + <span class="string">"\""</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取当前的 ClassLoader 实例，后面要做的工作，就是把其他 dex 文件加载后，// 把其 DexFile 对象添加到这个 ClassLoader 实例里就完事了。</span></span><br><span class="line">                ClassLoader loader;</span><br><span class="line">                <span class="keyword">try</span> &#123;loader = context.getClassLoader ();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    Log.w (TAG, <span class="string">"Failure while trying to obtain Context class loader."</span> +</span><br><span class="line">                            <span class="string">"Must be running in test mode. Skip patching."</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.e (TAG,</span><br><span class="line">                            <span class="string">"Context class loader is null. Must be running in test mode."</span></span><br><span class="line">                            + <span class="string">"Skip patching."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 5. 清除旧的 dex 文件，注意这里不是清除上次加载的 dex 文件缓存。// 获取 dex 缓存目录是，会优先获取 /data/data/&lt;package&gt;/code-cache 作为缓存目录。// 如果获取失败，则使用 /data/data/&lt;package&gt;/files/code-cache 目录。// 这里清除的是第二个目录。</span></span><br><span class="line">                  clearOldDexDir (context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                  Log.w (TAG, <span class="string">"Something went wrong when trying to clear old MultiDex extraction,"</span></span><br><span class="line">                      + <span class="string">"continuing without cleaning."</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 获取缓存目录（/data/data/&lt;package&gt;/code-cache）。</span></span><br><span class="line">                File dexDir = getDexDir (context, applicationInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 加载缓存文件（如果有）。</span></span><br><span class="line">                List&lt;File&gt; files = MultiDexExtractor.load (context, applicationInfo, dexDir, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 检查缓存的 dex 是否安全 if (checkValidZipFiles (files)) &#123;</span></span><br><span class="line"><span class="comment">// 9. 安装缓存的 dex</span></span><br><span class="line">                    installSecondaryDexes (loader, dexDir, files);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 9. 从 apk 压缩包里面提取 dex 文件</span></span><br><span class="line">                    Log.w (TAG, <span class="string">"Files were not valid zip files.  Forcing a reload."</span>);</span><br><span class="line">                    files = MultiDexExtractor.load (context, applicationInfo, dexDir, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (checkValidZipFiles (files)) &#123;</span><br><span class="line"><span class="comment">// 10. 安装提取的 dex</span></span><br><span class="line">                        installSecondaryDexes (loader, dexDir, files);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"Zip files were not valid."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;Log.e (TAG, <span class="string">"Multidex installation failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">"Multi dex installation failed ("</span> + e.getMessage () + <span class="string">")."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i (TAG, <span class="string">"install done"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体代码的分析已经在上面代码的注释里给出了，从这里我们也可以看出，整个 MultiDex.install (Context) 的过程中，关键的步骤就是 <code>MultiDexExtractor#load</code> 方法和 <code>MultiDex#installSecondaryDexes</code> 方法。</p><p>（这部分是题外话）其中有个 <strong>MultiDex#clearOldDexDir (Context)</strong><strong>方法，这个方法的作用是删除</strong><strong>/data/data//files/code-cache</strong>，一开始我以为这个方法是删除上一次执行 MultiDex 后的缓存文件，不过这明显不对，不可能每次 MultiDex 都重新解压 dex 文件一边，这样每次启动会很耗时，** 只有第一次冷启动的时候才需要解压 dex 文件 <strong>。后来我又想是不是以前旧版的 MultiDex 曾经把缓存文件放在这个目录里，现在新版本只是清除以前旧版的遗留文件？但是我找遍了整个 MultiDex Repo 的提交也没有见过类似的旧版本代码。后面我仔细看 **MultiDex#getDexDir</strong> 这个方法才发现，原来 MultiDex 在获取 dex 缓存目录是，会优先获取 <strong>/data/data//code-cache</strong> 作为缓存目录，如果获取失败，则使用 <strong>/data/data//files/code-cache</strong> 目录，而后者的缓存文件会在每次 App 重新启动的时候被清除。感觉 MultiDex 获取缓存目录的逻辑不是很严谨，而获取缓存目录失败也是 MultiDex 工作工程中少数有重试机制的地方，看来 MultiDex 真的是一个临时的兼容方案，Google 也许并不打算认真处理这些历史的黑锅。</p><p>接下来再看看 MultiDexExtractor#load 这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> List&lt;File&gt; <span class="title">load</span> <span class="params">(Context context, ApplicationInfo applicationInfo, File dexDir,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> forceReload)</span> <span class="keyword">throws</span> IOException </span>&#123;Log.i (TAG, <span class="string">"MultiDexExtractor.load ("</span> + applicationInfo.sourceDir + <span class="string">","</span> + forceReload + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">final</span> File sourceApk = <span class="keyword">new</span> File (applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取当前 Apk 文件的 crc 值。long currentCrc = getZipCrc (sourceApk);</span></span><br><span class="line"><span class="comment">// Validity check and extraction must be done only while the lock file has been taken.</span></span><br><span class="line">        File lockFile = <span class="keyword">new</span> File (dexDir, LOCK_FILENAME);</span><br><span class="line">        RandomAccessFile lockRaf = <span class="keyword">new</span> RandomAccessFile (lockFile, <span class="string">"rw"</span>);</span><br><span class="line">        FileChannel lockChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileLock cacheLock = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;File&gt; files;</span><br><span class="line">        IOException releaseLockException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;lockChannel = lockRaf.getChannel ();</span><br><span class="line">            Log.i (TAG, <span class="string">"Blocking on lock"</span> + lockFile.getPath ());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 加上文件锁，防止多进程冲突。</span></span><br><span class="line">            cacheLock = lockChannel.lock ();</span><br><span class="line">            Log.i (TAG, lockFile.getPath () + <span class="string">"locked"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 先判断是否强制重新解压，这里第一次会优先使用已解压过的 dex 文件，如果加载失败就强制重新解压。// 此外，通过 crc 和文件修改时间，判断如果 Apk 文件已经被修改（覆盖安装），就会跳过缓存重新解压 dex 文件。if (!forceReload &amp;&amp; !isModified (context, sourceApk, currentCrc)) &#123;</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 加载缓存的 dex 文件</span></span><br><span class="line">                    files = loadExistingExtractions (context, sourceApk, dexDir);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                    Log.w (TAG, <span class="string">"Failed to reload existing extracted secondary dex files,"</span></span><br><span class="line">                            + <span class="string">"falling back to fresh extraction"</span>, ioe);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 加载失败的话重新解压，并保存解压出来的 dex 文件的信息。</span></span><br><span class="line">                    files = performExtractions (sourceApk, dexDir);</span><br><span class="line">                    putStoredApkInfo (context,</span><br><span class="line">                            getTimeStamp (sourceApk), currentCrc, files.size () + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 4. 重新解压，并保存解压出来的 dex 文件的信息。</span></span><br><span class="line">                Log.i (TAG, <span class="string">"Detected that extraction must be performed."</span>);</span><br><span class="line">                files = performExtractions (sourceApk, dexDir);</span><br><span class="line">                putStoredApkInfo (context, getTimeStamp (sourceApk), currentCrc, files.size () + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="keyword">if</span> (cacheLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;cacheLock.release ();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;Log.e (TAG, <span class="string">"Failed to release lock on"</span> + lockFile.getPath ());</span><br><span class="line"><span class="comment">// Exception while releasing the lock is bad, we want to report it, but not at//the price of overriding any already pending exception.</span></span><br><span class="line">                    releaseLockException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lockChannel != <span class="keyword">null</span>) &#123;closeQuietly (lockChannel);</span><br><span class="line">            &#125;</span><br><span class="line">            closeQuietly (lockRaf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (releaseLockException != <span class="keyword">null</span>) &#123;<span class="keyword">throw</span> releaseLockException;&#125;</span><br><span class="line">        Log.i (TAG, <span class="string">"load found"</span> + files.size () + <span class="string">"secondary dex files"</span>);</span><br><span class="line">        <span class="keyword">return</span> files;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个过程主要是获取可以安装的 dex 文件列表，可以是上次解压出来的缓存文件，也可以是重新从 Apk 包里面提取出来的。需要注意的时，如果是重新解压，这里会有明显的耗时，而且解压出来的 dex 文件，会被压缩成.zip 压缩包，压缩的过程也会有明显的耗时（这里压缩 dex 文件可能是问了节省空间）。</p><p>如果 dex 文件是重新解压出来的，则会保存 dex 文件的信息，包括解压的 apk 文件的 crc 值、修改时间以及 dex 文件的数目，以便下一次启动直接使用已经解压过的 dex 缓存文件，而不是每一次都重新解压。</p><p>需要特别提到的是，里面的 <strong>FileLock</strong> 是最新的 master 分支里面新加进去的功能，现在最新的 <code>1.0.1</code> 版本里面是没有的。</p><p>无论是通过使用缓存的 dex 文件，还是重新从 apk 中解压 dex 文件，获取 dex 文件列表后，下一步就是安装（或者说加载）这些 dex 文件了。最后的工作在 <code>MultiDex#installSecondaryDexes</code> 这个方法里面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installSecondaryDexes</span><span class="params">(ClassLoader loader, File dexDir, List&lt;File&gt; files)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException, NoSuchFieldException,</span></span><br><span class="line"><span class="function">        InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(loader, files, dexDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(loader, files);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在不同的 SDK 版本上，ClassLoader（更准确来说是 DexClassLoader）加载 dex 文件的方式有所不同，所以这里做了 V4/V14/V19 的兼容（Magic Code）。</p><p>Build.VERSION.SDK_INT &lt; 14</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 4 to 13.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V4</span> </span>&#123;<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span> <span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, IOException </span>&#123;<span class="keyword">int</span> extraSize = additionalClassPathEntries.size ();</span><br><span class="line">            Field pathField = findField (loader, <span class="string">"path"</span>);</span><br><span class="line">            StringBuilder path = <span class="keyword">new</span> StringBuilder ((String) pathField.get (loader));</span><br><span class="line">            String [] extraPaths = <span class="keyword">new</span> String [extraSize];</span><br><span class="line">            File [] extraFiles = <span class="keyword">new</span> File [extraSize];</span><br><span class="line">            ZipFile [] extraZips = <span class="keyword">new</span> ZipFile [extraSize];</span><br><span class="line">            DexFile [] extraDexs = <span class="keyword">new</span> DexFile [extraSize];</span><br><span class="line">            <span class="keyword">for</span> (ListIterator&lt;File&gt; iterator = additionalClassPathEntries.listIterator ();</span><br><span class="line">                    iterator.hasNext ();) &#123;File additionalEntry = iterator.next ();</span><br><span class="line">                String entryPath = additionalEntry.getAbsolutePath ();</span><br><span class="line">                path.append (<span class="string">':'</span>).append (entryPath);</span><br><span class="line">                <span class="keyword">int</span> index = iterator.previousIndex ();</span><br><span class="line">                extraPaths [index] = entryPath;</span><br><span class="line">                extraFiles [index] = additionalEntry;</span><br><span class="line">                extraZips [index] = <span class="keyword">new</span> ZipFile (additionalEntry);</span><br><span class="line">                extraDexs [index] = DexFile.loadDex (entryPath, entryPath + <span class="string">".dex"</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个版本是最简单的。// 只需要创建 DexFile 对象后，使用反射的方法分别扩展 ClassLoader 实例的以下字段即可。</span></span><br><span class="line">            pathField.set (loader, path.toString ());</span><br><span class="line">            expandFieldArray (loader, <span class="string">"mPaths"</span>, extraPaths);</span><br><span class="line">            expandFieldArray (loader, <span class="string">"mFiles"</span>, extraFiles);</span><br><span class="line">            expandFieldArray (loader, <span class="string">"mZips"</span>, extraZips);</span><br><span class="line">            expandFieldArray (loader, <span class="string">"mDexs"</span>, extraDexs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>14 &lt;= Build.VERSION.SDK_INT &lt; 19</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 14, 15, 16, 17 and 18.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V14</span> </span>&#123;<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span> <span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展 ClassLoader 实例的 "pathList" 字段。</span></span><br><span class="line">            Field pathListField = findField (loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get (loader);</span><br><span class="line">            expandFieldArray (dexPathList, <span class="string">"dexElements"</span>, makeDexElements (dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object [] makeDexElements (Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory)</span><br><span class="line">                        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</span><br><span class="line">                        NoSuchMethodException &#123;</span><br><span class="line">            Method makeDexElements =</span><br><span class="line">                    findMethod (dexPathList, <span class="string">"makeDexElements"</span>, ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">File</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Object []) makeDexElements.invoke (dexPathList, files, optimizedDirectory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从 API14 开始，DexClassLoader 会使用一个 DexpDexPathList 类来封装 DexFile 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DexPathList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEX_SUFFIX = <span class="string">".dex"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JAR_SUFFIX = <span class="string">".jar"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZIP_SUFFIX = <span class="string">".zip"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(ArrayList&lt;File&gt; files,</span><br><span class="line">            File optimizedDirectory) &#123;</span><br><span class="line">        ArrayList&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;Element&gt;();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            ZipFile zip = <span class="keyword">null</span>;</span><br><span class="line">            DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">            String name = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line"><span class="comment">// Raw dex file (not inside a zip/jar).try &#123;</span></span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX)</span><br><span class="line">                    || name.endsWith(ZIP_SUFFIX)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    zip = <span class="keyword">new</span> ZipFile(file);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to open zip file: "</span> + file, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(file, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.logW(<span class="string">"Unknown file type for: "</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                elements.add(<span class="keyword">new</span> Element(file, zip, dex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title">loadDexFile</span><span class="params">(File file, File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (optimizedDirectory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DexFile(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String optimizedPath = optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">            <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <strong>DexPathList#makeDexElements</strong> 方法，可以加载我们上面解压得到的 dex 文件，从代码也可以看出，<strong>DexPathList#makeDexElements</strong> 其实也是通过调用 <strong>DexFile#loadDex</strong> 来加载 dex 文件并创建 DexFile 对象的。V14 中，通过反射调用 <strong>DexPathList#makeDexElements</strong> 方法加载我们需要的 dex 文件，在把加载得到的数组扩展到 ClassLoader 实例的 “pathList” 字段，从而完成 dex 文件的安装。</p><p>从 DexPathList 的代码中我们也可以看出，ClassLoader 是支持直接加载.dex/.zip/.jar/.apk 的 dex 文件包的（我记得以前在哪篇日志中好像提到过类似的问题…）。</p><p>19 &lt;= Build.VERSION.SDK_INT</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Installer for platform versions 19.</span></span><br><span class="line"><span class="comment">     */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                File optimizedDirectory)</span></span></span><br><span class="line"><span class="function">                        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span></span><br><span class="line"><span class="function">                        NoSuchFieldException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">            Field pathListField = findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">            Object dexPathList = pathListField.get(loader);</span><br><span class="line">            ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">            expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">                    <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">                    suppressedExceptions));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                    Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                Field suppressedExceptionsField =</span><br><span class="line">                        findField(dexPathList, <span class="string">"dexElementsSuppressedExceptions"</span>);</span><br><span class="line">                IOException[] dexElementsSuppressedExceptions =</span><br><span class="line">                        (IOException[]) suppressedExceptionsField.get(dexPathList);</span><br><span class="line">                <span class="keyword">if</span> (dexElementsSuppressedExceptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dexElementsSuppressedExceptions =</span><br><span class="line">                            suppressedExceptions.toArray(</span><br><span class="line">                                    <span class="keyword">new</span> IOException[suppressedExceptions.size()]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    IOException[] combined =</span><br><span class="line">                            <span class="keyword">new</span> IOException[suppressedExceptions.size() +</span><br><span class="line">                                            dexElementsSuppressedExceptions.length];</span><br><span class="line">                    suppressedExceptions.toArray(combined);</span><br><span class="line">                    System.arraycopy(dexElementsSuppressedExceptions, <span class="number">0</span>, combined,</span><br><span class="line">                            suppressedExceptions.size(), dexElementsSuppressedExceptions.length);</span><br><span class="line">                    dexElementsSuppressedExceptions = combined;</span><br><span class="line">                &#125;</span><br><span class="line">                suppressedExceptionsField.set(dexPathList, dexElementsSuppressedExceptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">                Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">                ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">                        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException,</span><br><span class="line">                        NoSuchMethodException &#123;</span><br><span class="line">            Method makeDexElements =</span><br><span class="line">                    findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">File</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">ArrayList</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory,</span><br><span class="line">                    suppressedExceptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>V19 与 V14 差别不大，只不过 <strong>DexPathList#makeDexElements</strong> 方法多了一个 ArrayList 参数，如果在执行 <strong>DexPathList#makeDexElements</strong> 方法的过程中出现异常，后面使用反射的方式把这些异常记录进 DexPathList 的 <strong>dexElementsSuppressedExceptions</strong> 字段里面。</p><p>无论是 V4/V14 还是 V19，在创建 DexFile 对象的时候，都需要通过 DexFile 的 Native 方法 <strong>openDexFile</strong> 来打开 dex 文件，其具体细节暂不讨论（涉及到 dex 的文件结构，很烦，有兴趣请阅读 <a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a>），这个过程的主要目的是给当前的 dex 文件做 Optimize 优化处理并生成相同文件名的 odex 文件，App 实际加载类的时候，都是通过 odex 文件进行的。因为每个设备对 odex 格式的要求都不一样，所以这个优化的操作只能放在安装 Apk 的时候处理，主 dex 的优化我们已经在安装 apk 的时候搞定了，其余的 dex 就是在 <code>MultiDex#installSecondaryDexes</code> 里面优化的，而后者也是 MultiDex 过程中，另外一个耗时比较多的操作。（在 MultiDex 中，提取出来的 dex 文件被压缩成.zip 文件，又优化后的 odex 文件则被保存为.dex 文件。）</p><p>到这里，MultiDex 的工作流程就结束了。怎么样，是不是觉得和以前谈到动态加载技术（插件化）的时候说的很像？没错，谁叫它们的核心都是 dex 文件呢。Java 老师第一节课就说 “** 类就是编程 **”，搞定类你就能搞定整个世界啊！</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>MultiDex 有个比较蛋疼的问题，就是会产生明显的卡顿现象，通过上面的分析，我们知道具体的卡顿产生在 ** 解压 dex 文件 ** 以及 ** 优化 dex** 两个步骤。不过好在，在 Application#attachBaseContext (Context) 中，UI 线程的阻塞是不会引发 ANR 的，只不过这段长时间的卡顿（白屏）还是会影响用户体验。<br>目前，优化方案能想到的有两种。</p><h3 id="PreMultiDex-方案"><a href="#PreMultiDex-方案" class="headerlink" title="PreMultiDex 方案"></a>PreMultiDex 方案</h3><p>大致思路是，在安装一个新的 apk 的时候，先在 Worker 线程里做好 MultiDex 的解压和 Optimize 工作，安装 apk 并启动后，直接使用之前 Optimize 产生的 odex 文件，这样就可以避免第一次启动时候的 Optimize 工作。</p><p><img src="/assets/02dd6659_1487_4691_a0a6_d9c1ad849079_untitled.png" alt=""></p><p>安装 dex 的时候，核心是创建 DexFile 对象并使用其 Native 方法对 dex 文件进行 opt 处理，同时生产一个与 dex 文件（.zip）同名的已经 opt 过的 dex 文件（.dex）。如果安装 dex 的时候，这个 opt 过的 dex 文件已经存在，则跳过这个过程，这会节省许多耗时。所以优化的思路就是，下载 Apk 完成的时候，预先解压 dex 文件，并预先触发安装 dex 文件以生产 opt 过的 dex 文件。这样覆盖安装 Apk 并启动的时候，如果 MultiDex 能命中解压好的 dex 和 odex 文件，则能避开耗时最大的两个操作。</p><p>不过这个方案的缺点也是明显的，第一次安装的 apk 没有作用，而且事先需要使用内置的 apk 更新功能把新版本的 apk 文件下载下来后，才能做 PreMultiDex 工作。</p><h3 id="异步-MultiDex-方案"><a href="#异步-MultiDex-方案" class="headerlink" title="异步 MultiDex 方案"></a>异步 MultiDex 方案</h3><p>这种方案也是目前比较流行的 *<em>Dex 手动分包方案 *</em>，启动 App 的时候，先显示一个简单的 Splash 闪屏界面，然后启动 Worker 线程执行 MultiDex#install (Context) 工作，就可以避免 UI 线程阻塞。不过要确保启动以及启动 MultiDex#install (Context) 所需要的类都在主 dex 里面（手动分包），而且需要处理好进程同步问题。</p><p>参考资料：</p><ul><li><a href="https://developer.android.com/studio/build/multidex.html" target="_blank" rel="noopener">Configure Apps with Over 64K Methods</a></li><li><a href="https://android.googlesource.com/platform/frameworks/multidex/" target="_blank" rel="noopener">Google Multidex</a></li><li><a href="https://android.googlesource.com/platform/dalvik/+/0dcf6bb/vm/native/dalvik_system_DexFile.cpp" target="_blank" rel="noopener">dalvik_system_DexFile.cpp</a></li></ul><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = MultiDex 工作原理分析和优化方案Date = 2016-11-11 00:00:00Published = trueCategory = AndroidTag = ['Android', 'MultiDex', '源码分析']FileLocate = androidFileName = multidex-source-codehexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动态加载技术（插件化）系列已经坑了有一段时间了，不过 UP 主我并没有放弃治疗哈，相信在不就的未来就可以看到 “系统 Api Hook 模式” 和插件化框架 Frontia 的更新了。今天要讲的是动态加载技术的亲戚 —— MultiDex。他们的核心原理之一都是 dex 文件的加载。&lt;/p&gt;
&lt;p&gt;MultiDex 是 Google 为了解决 “&lt;strong&gt;65535 方法数超标 **” 以及 “&lt;/strong&gt;INSTALL_FAILED_DEXOPT**” 问题而开发的一个 Support 库，具体如何使用 MultiDex 现在市面已经有一大堆教程（可以参考 &lt;a href=&quot;http://kaedea.com/2015/09/02/android/enable-multidex/&quot;&gt;给 App 启用 MultiDex 功能&lt;/a&gt;），这里不再赘述。这篇日志主要是配合源码分析 MultiDex 的工作原理，以及提供一些 MultiDex 优化的方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="源码分析" scheme="http://kaedea.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="MultiDex" scheme="http://kaedea.com/tags/MultiDex/"/>
    
  </entry>
  
  <entry>
    <title>Android Logging 的正确姿势</title>
    <link href="http://kaedea.com/2016/10/02/android/log-utility/"/>
    <id>http://kaedea.com/2016/10/02/android/log-utility/</id>
    <published>2016-10-02T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>LOG 是任何一种编程语言的第一个 API，通常被初学者用来打印 Hello, World!。 有研究显示，不使用 LOG 或者使用姿势错误的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情需要书写，不能是一整张白纸。</p></blockquote><p>LogCat 是 Android 开发者们最熟悉不过的日志打印工具，几乎每一个 Android 项目里面都包含着大量的 Log 相关代码。不过，或许是因为 Log 实在是太过于普通，所以许多人在使用它的时候就显得非常随意，这些错误的使用姿势却会在不经意间给我们带来不少的大坑。</p><a id="more"></a><h2 id="Log-相关的一些问题"><a href="#Log-相关的一些问题" class="headerlink" title="Log 相关的一些问题"></a>Log 相关的一些问题</h2><h3 id="没有关闭调试用的-LOG"><a href="#没有关闭调试用的-LOG" class="headerlink" title="没有关闭调试用的 LOG"></a>没有关闭调试用的 LOG</h3><p>许多同学喜欢在开发阶段用 Log 输出当前的一些环境数据，用于调试代码，但是在调试完成后却忘了关闭这些 Log，导致发版出去的应用里面还会继续输出这些 LOG，这样不仅会造成不必要的性能丢失，也会暴露一些敏感的数据，这些都是我们不愿看到的。</p><p>首先，我们要给 Log 进行分级，规定 “DEBUG 版本输出哪一些级别的 LOG 并屏蔽哪一些级别的 LOG，而 RELEASE 版本又输出另一些级别的 LOG 并屏蔽另一些级别的 LOG”，这样在开发阶段能够输出我们调试需要的 LOG，而同时又能保证放送的版本能够屏蔽这些敏感的 LOG。但是在开发阶段我们不应该特意去注意这些细节，所以必须开发一个 Log 工具库，在框架层级解决这个需求。</p><p>同时，需要注意的是，** 用于作为 “开启 / 关闭 Log” 的开关必须是一个常量 **，而不能是一个变量（使用常量的话，在编译代码的时候，如果常量为 false），编译器会直接把调试部分的 Log 代码直接去掉，而使用变量作为开关的话，这个判断逻辑会继续保留，一方面会造成性能丢失，另一方面在运行时也可以通过 Hack 手段强行开启这部分 Log 代码。</p><p>另外，“开启 / 关闭 Log” 的开关必须写在 Log 方法外部，也就是说必须先判断 “开启 / 关闭 Log” 条件，再调用 Log 方法，因为在调用 Log 方法的时候已经造成了性能丢失，而且调用方法的时候，会先构造好改方法需要的参数（按照参数顺序从右往左），再调用方法，而许多人喜欢在调用 Log 方法的时候计算需要打印出来的内容，这里是最容易造成性能丢失的地方。因此，如果为了图方便，写一个 Log 工具类，在工具类内部去判断是否应该开启或关闭 Log，事实上已经造成了不少的性能丢失。正确的使用姿势应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">  Log.v(TAG, <span class="string">"log something"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在循环体内部打印-LOG"><a href="#在循环体内部打印-LOG" class="headerlink" title="在循环体内部打印 LOG"></a>在循环体内部打印 LOG</h3><p>尽管 Log 造成的性能损失很小，但是如果在循环体内部循环调用 Log 方法的话，那总体的丢失的非常可观了，所以不应该在循环体内部使用 Log，正确的做法是在循环体内部拼接需要打印的内容，等跳出循环体再一次打印出来。</p><p>除了常见的循环体外，还要一个需要注意的场景就是 Adapter。ListView/RecyclerView 是 Android 开发中最常用的控件，因此 Adapter 使用的情景也很多。滚动屏幕的时候，ListView/RecyclerView 会在通过 Adapter 频繁地绑定 ItemView 和数据，而且这些都是在 UI 线程里进行的，所以如果在绑定的过程中调用 Log，可能会造成明显的卡顿。</p><p>至于 Log 到底会丢失多少性能，一般情况下，Log 的性能丢失很小，毕竟是这么常见的系统 Api，肯定是身经百战，早就是 “best performance” 了。不过我曾经有个 RecyclerView 在 <strong>MIUI</strong> 上非常卡，一开始我是 RecyclerView 布局没优化好，最终定位到 Adapter 内部的一处 Log 上，卡顿的地方出现在 Log 的 Native 实现。<strong>MIUI</strong> 到底对用户输出的日志做了什么处理呢？非常神奇。</p><h3 id="无法获取重要-LOG-内容"><a href="#无法获取重要-LOG-内容" class="headerlink" title="无法获取重要 LOG 内容"></a>无法获取重要 LOG 内容</h3><p>在调试代码的时候，我们经常通过 LOG 来定位 Bug。同理，当线上的版本出现问题的时候，我们也希望能通过 LOG 来定位问题所在。但是问题是用户的设备上的打印出来的 LOG 我们根本没有方法获取，唯一的手段就是当用户设备出现问题的时候，把设备借过来连上 IDE 用 LogCat 查看输出的 LOG…… 显然这是不可行的。</p><p>这种时候，我们可以在打印重要 LOG（比如重要路径的触发点、或者一些异常类的信息）的时候，一并把这些信息记录到文件里。在用户反馈系统里面，一并将这些文件上传到我们的用户反馈服务器，这样在处理反馈问题的时候，就能拿到重要的参考日志了。</p><h2 id="BLog"><a href="#BLog" class="headerlink" title="BLog"></a>BLog</h2><p>BLog 是 Android SDK 的 LOG 工具 {@link android.util.Log} 的加强版，以方便在开发时用来 操作调试日志。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>简单易用的 API；</li><li>支持输出线程信息；</li><li>支持设置 LogLevel，方便在生产环境关闭调试用的 LOG；</li><li>支持将 LOG 内容写入文件，以便通过文件 LOG 定位用户反馈的问题；</li></ol><p>注意，尽管 BLog 支持关闭 Log 的输出，但是在你调用 <code>BLog.v (String)</code> 的时候，其实已经造成了性能 丢失，所以请尽量使用正确的姿势来使用 BLog，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (BuildConfig.DEBUG) &#123;</span><br><span class="line">  BLog.v(TAG, <span class="string">"log verbose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><p><a href="https://github.com/kaedea/b-log" target="_blank" rel="noopener">https://github.com/kaedea/b-log</a><br>补充 2016-11-20 因为现在公司项目上也采用了 BLog 这个工具，开源公司项目相关的代码需要安装既定的流程来，所以暂时不公开源码。有兴趣的同学可以试下联系我交♂流。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = Android Logging 的正确姿势Date = 2016-10-02 00:00:00Published = trueCategory = AndroidTag = ['Android', 'Logging', 'APM']FileLocate = androidFileName = log-utilityhexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;LOG 是任何一种编程语言的第一个 API，通常被初学者用来打印 Hello, World!。 有研究显示，不使用 LOG 或者使用姿势错误的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情需要书写，不能是一整张白纸。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LogCat 是 Android 开发者们最熟悉不过的日志打印工具，几乎每一个 Android 项目里面都包含着大量的 Log 相关代码。不过，或许是因为 Log 实在是太过于普通，所以许多人在使用它的时候就显得非常随意，这些错误的使用姿势却会在不经意间给我们带来不少的大坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="APM" scheme="http://kaedea.com/tags/APM/"/>
    
      <category term="Logging" scheme="http://kaedea.com/tags/Logging/"/>
    
  </entry>
  
  <entry>
    <title>黑苹果初体验 - 富士通 LH532</title>
    <link href="http://kaedea.com/2016/09/23/living/living-hackintosh-lh532/"/>
    <id>http://kaedea.com/2016/09/23/living/living-hackintosh-lh532/</id>
    <published>2016-09-23T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/bb50f6df_4c0f_424a_b9b3_04870fa7b35c_untitled.png" alt=""></p><p>高中开始折腾电脑 DIY，当然硬件玩不起，只是折腾系统，一开始折腾重装 Windows 系统，玩腻了就折腾 Linux，到后来开始打算折腾 Mac。在普通 PC 上安装苹果的 OSX 系统（现在叫 MacOS）的行为叫做黑苹果（Mackintosh），相反的，苹果自家产品自带的系统叫做白苹果（Mackintosh）。不过安装黑苹果比起 Windows 和 Linux 实在是难多了，所以那时候看教程看得一脸懵逼就结束了。</p><p>最近在公司开始正式切换到 Mac 系统上进行开发工作，但是回到家里就得用 WIN10（Fujitsu LH532）进行开发，有个非常头疼的问题，就是 Mac 上的快捷键和 Windows 大相径庭，所以又产生了安装黑苹果的想法。看了一周的攻略之后，我迫不及待地开始了。</p><a id="more"></a><h2 id="学习攻略"><a href="#学习攻略" class="headerlink" title="学习攻略"></a>学习攻略</h2><p>首先需要学习一些安装黑苹果中需要用到的基本姿势，目前主要有以下渠道。<br><a href="http://www.tonymacx86.com/" target="_blank" rel="noopener">http://www.tonymacx86.com/</a><br>这个可以说是黑苹果的鼻祖，最前沿的阵地，在这里你可以学习到最新的黑苹果调教姿势，也可以在这里查询哪些 PC 硬件适合安装黑苹果，自己的电脑遇到兼容性问题也可以在这里搜索是不是有别人遇到类似的问题。唯一的要求，就是你的英文要够好。<br><a href="http://bbs.pcbeta.com/forum.php?gid=86" target="_blank" rel="noopener">PCbeta 黑苹果乐园</a><br>PCbeta 是国内 PC 电脑 DIY 强迫患者的集聚地，在这里你也可以找到不少详细的黑苹果安装攻略。<br>在我学习黑苹果基础姿势的时候，最头疼的问题，就是这些攻略教程实在是太多太杂了，而且质量参差不齐，杂乱无序，看来看去，许多术语都没有解释，莫名其妙，所以我才花了一个星期的时间才初步看明白了。</p><h2 id="简单易懂的说明方式"><a href="#简单易懂的说明方式" class="headerlink" title="简单易懂的说明方式"></a>简单易懂的说明方式</h2><p>假设你已经知道了怎么安装 Windows，那你应该知道安装系统无非就是两个步骤：</p><ol><li>先通过安装媒介（光盘或者 U 盘）引导 Windows 安装程序并安装系统；</li><li>进入系统后安装硬件所需要的驱动；</li></ol><p>当然现在的 Windows 系统相对容易安装许多，它自带了许多最新的驱动，所以对于常见的 PC 硬件来说，有可能都不需要自己额外再安装驱动。而且，Windows 有许多 GHOST 版本的安装镜像，里面事先打好了各种驱动和常见的软件、补丁程序，所以有时候你都不用进行第二步。<br>对于安装黑苹果系统来说步骤也差不多，只不过，Mac 系统对硬盘格式有要求，所以首先你可能要处理自己的硬盘的格式问题。其次，因为 Mac 系统是不被允许安装在苹果之外的产品上的，所以不能直接引导 Mac 系统安装程序，需要额外的软件来辅助引导。最后，MacOS 自带的驱动程序许多情况下都不能兼容一般的 PC 硬件，所以安装完系统后，还要进行一系列的安装驱动的工作。<br>简单来说，安装黑苹果需要经过以下步骤。</p><h3 id="确认硬盘的格式"><a href="#确认硬盘的格式" class="headerlink" title="确认硬盘的格式"></a>确认硬盘的格式</h3><p>现在的硬盘主要有 MBR 和 GPT 格式，MacOS 只能安装到 GPT 格式上，如果需要安装到 MBR 格式的硬盘上，需要在安装镜像上打上额外的补丁程序。当然现在有许多别人打好补丁的系统安装镜像，这种镜像叫做 “懒人版” 安装镜像。具体怎么区分硬盘格式和打补丁就不讨论了，请善用搜索工具。<br>我的 LH532 的硬盘是三星的 SSD，是 MBR 格式的，为了图方便使用了懒人版。</p><h3 id="制作启动盘"><a href="#制作启动盘" class="headerlink" title="制作启动盘"></a>制作启动盘</h3><p>搞好了系统安装镜像之后，并不能直接启动安装，需要制作一个用于引导的启动盘，以前启动盘的媒介大多是光驱启动，现在一般制作成 U 盘启动，也可以是硬盘划一个分区出来启动。制作启动盘的过程在 Windows 上和在 MAC 略有差别（后者相对简单），但是基本过程都是一样的，就是将系统安装镜像烧录到指定的媒介上。</p><h3 id="选用对应的引导辅助工具"><a href="#选用对应的引导辅助工具" class="headerlink" title="选用对应的引导辅助工具"></a>选用对应的引导辅助工具</h3><p>以前安装多系统的时候也需要引导辅助工具，比如 EasyBCD，可以方便地引导到 Windows 或者 Linux 系统。引导问题也是黑苹果最核心的问题，现在的引导工具有 Clover（四叶草），一般用来引导安装到 GPT 格式的硬盘上。另外有 Chameleon（变色龙），用来引导安装到 MBR 格式的硬盘上。<br>把相应的引导辅助工具制作成 U 盘启动，就可以启动引导辅助工具来引导 MacOS 的系统镜像了。注意，这里并不像安装 Windows 那样直接引导系统镜像并运行安装程序就完事，除了使用相应的引导辅助工具之外，还需要根据自己电脑的配置，在引导辅助程序里面设置好相应的配置文件（Clover 参考 config.plist，变色龙参考 Boot.plist），这也是安装黑苹果的关键步骤之一，能不能正常完成系统的安装工作就这一步，毕竟只要能成功进入系统，其他驱动问题都可以在系统内解决，如果连安装工作都无法完成，就没法进行下一步工作了。推荐搜索和自己配置（特别是主板）一致的设置方式。<br>这里也有另一种观点，传统使用光盘或者 U 盘引导安装 Windows 系统，都是利用 Bios 自带的引导功能，但是 Bios 的引导功能很有限，不足以引导安装 Mac。所以可以把 EsayBCD、Chameleon、Clover 等引导工具看成一个微型的操作系统，电脑启动的时候 Bios 只负责引导到这些微型操作系统，之后 “引导到 Mac 系统、双系统甚至多系统” 等复杂工作在微型操作系统里面完成。<br>很明显，我的 LH532 用的是变色龙引导，plist 也是在网上找到别人的 LH532 的调教方式。</p><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><p>如果上一步完成了，应该就能成功启动系统安装程序并安装系统了。接下来就是安装驱动程序了，到了这一步就因人而异了，如果有些硬件不能正常工作（比如常见网卡、声卡和显卡，俗称 “三卡” 问题），就搜索改硬件对应型号的驱动吧，现在主流的配置一般都有别人提供的驱动。</p><h2 id="Fujitsu-LH532-OS-X-El-Capitan"><a href="#Fujitsu-LH532-OS-X-El-Capitan" class="headerlink" title="Fujitsu LH532 OS X El Capitan"></a>Fujitsu LH532 OS X El Capitan</h2><p>折腾了一天，我的笔记本的黑苹果总算搞定了，安装了 WIN10 + El Capitan 双系统。怎么说呢，黑苹果用起来比 Windows 还稳定。经过几年的的 “折磨” 后，我的 LH532 用 WIN10 时不时总会蓝屏，但是用 El Capitan 却一直很稳定，当然还是有一些问题的。</p><ol><li>无线网卡 / 蓝牙无法驱动，我自己买了个 USB 无线网卡；</li><li>屏幕亮度无法调节，这个也很坑，好在我现在用的是外接显示器；</li><li>ALPS 触摸板可用但是无法使用双指；</li><li>有时候电脑进入睡眠后无法唤醒；</li></ol><p>好吧，感觉 LH532 能这样续命已经超出我的期待了，性能跑分居然还能顶上中配的 MBP13。虽然安装了双系统，但是用上 El Capitan 之后，我就很少用回 WIN10 了。<br>安装过程中用到的工具和驱动打包：<a href="https://pan.baidu.com/s/1slKVaAp" target="_blank" rel="noopener">Hackintosh/Feya_LH532</a><br>参考链接：<a href="http://osx86.cn/os-x-ei-capitan-10-11-gm1-install.html" target="_blank" rel="noopener">OS X EI Capitan 10.11 GM1 黑苹果懒人版变色龙引导安装教程</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 黑苹果初体验 - 富士通 LH532Date = 2016-09-23 00:00:00Published = trueCategory = LifeTag = ['Hackintosh', '黑苹果']FileLocate = livingFileName = living-hackintosh-lh532hexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/bb50f6df_4c0f_424a_b9b3_04870fa7b35c_untitled.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;高中开始折腾电脑 DIY，当然硬件玩不起，只是折腾系统，一开始折腾重装 Windows 系统，玩腻了就折腾 Linux，到后来开始打算折腾 Mac。在普通 PC 上安装苹果的 OSX 系统（现在叫 MacOS）的行为叫做黑苹果（Mackintosh），相反的，苹果自家产品自带的系统叫做白苹果（Mackintosh）。不过安装黑苹果比起 Windows 和 Linux 实在是难多了，所以那时候看教程看得一脸懵逼就结束了。&lt;/p&gt;
&lt;p&gt;最近在公司开始正式切换到 Mac 系统上进行开发工作，但是回到家里就得用 WIN10（Fujitsu LH532）进行开发，有个非常头疼的问题，就是 Mac 上的快捷键和 Windows 大相径庭，所以又产生了安装黑苹果的想法。看了一周的攻略之后，我迫不及待地开始了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Life" scheme="http://kaedea.com/categories/Life/"/>
    
    
      <category term="Hackintosh" scheme="http://kaedea.com/tags/Hackintosh/"/>
    
      <category term="黑苹果" scheme="http://kaedea.com/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 主题 NEXT</title>
    <link href="http://kaedea.com/2016/09/17/front/front-hexo-theme-next/"/>
    <id>http://kaedea.com/2016/09/17/front/front-hexo-theme-next/</id>
    <published>2016-09-17T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/86859476.jpg" alt=""></p><p>又到了折腾博客主题的时间了，好吧，我承认我用在主题上的时间远比用在写博客上的时间要多多了 (〃ﾉωﾉ)。这次用的是 Hexo 中最受欢迎的主题（没有之一）的 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NEXT</a>。</p><!-- ColumnList start --><!-- Column 0 start --><a id="more"></a><!-- Column end --><!-- Column 1 start --><!-- Column end --><!-- ColumnList end --><p>在原来主题的基础上，做了以下微调：</p><ol><li>修改 <strong>embed</strong> 标签的样式；</li><li>修改 <strong>Header</strong> 样式，加入头部 Banner；</li><li>增加页面加载进度条；</li><li>增加对内部或外部链接的判断，以区别是否打开新 TAB；</li><li>增加中英混排时自动增加空格的功能；</li></ol><p>最后，放出修改后的 repo：<a href="https://github.com/kaedea/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a></p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = Hexo 主题 NEXTDate = 2016-09-17 00:00:00Published = trueCategory = BlogTag = ['Blog', 'Hexo', '主题']FileLocate = frontFileName = front-hexo-theme-nexthexo.comments = true-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/86859476.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;又到了折腾博客主题的时间了，好吧，我承认我用在主题上的时间远比用在写博客上的时间要多多了 (〃ﾉωﾉ)。这次用的是 Hexo 中最受欢迎的主题（没有之一）的 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-next&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NEXT&lt;/a&gt;。&lt;/p&gt;
&lt;!-- ColumnList start --&gt;
&lt;!-- Column 0 start --&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://kaedea.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://kaedea.com/tags/Hexo/"/>
    
      <category term="主题" scheme="http://kaedea.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>设计一个框架化框架 Frontia</title>
    <link href="http://kaedea.com/2016/07/10/android-dynamical-loading-08-satrt-frontia/"/>
    <id>http://kaedea.com/2016/07/10/android-dynamical-loading-08-satrt-frontia/</id>
    <published>2016-07-10T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/4df27cf7_e064_4741_ae49_f4bca8a82724_untitled.png" alt=""></p><p>结合动态加载系列文章的分析，现在开始设计并开发一个 Android 的插件化框架，命名为 Frontia。Frontia 有 “前端” 的意思，寓意着 Android 插件能像前端开发那样动态发版，同时，这一词出自 Macross 动画系列，有 “繁星” 的意思，“我们的征途是星辰大海 KIRA!!(&lt; ゝ ω・)☆”。</p><a id="more"></a><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul><li>Author : <a href="https://github.com/kaedea" target="_blank" rel="noopener">Kaede</a><ul><li>Index : <a href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index">ANDROID 动态加载系列</a></li></ul></li><li>GitHub : <a href="https://github.com/kaedea/android-dynamical-loading" target="_blank" rel="noopener">kaedea/android-dynamical-loading</a></li></ul><p>Frontia 是一个 Android 的插件化框架（基于 ClassLoader 的动态加载技术），相比其他开源项目，Frontia 的特点是扩展性强，更加专注于插件的下载、更新、安装、管理，以及插件和宿主之间的交互。在深入介绍 Frontia 之前，我们先想想开发一个插件化框架需要考虑的问题有哪些。</p><h2 id="满足多种业务需求的插件"><a href="#满足多种业务需求的插件" class="headerlink" title="满足多种业务需求的插件"></a>满足多种业务需求的插件</h2><p>现在的插件化需求有许多花样，首先，有的只需要将一些特定的类（或者接口的实现类）插件化，比如一些游戏的 SDK，需要把登录功能和支付功能的实现插件化，这样 SDK 就能实现动态升级。其次，有一些业务需要将 so 库给做成插件化，因为一些 so 库需要同时内置多个 CPU 类型（x86/arm64 等）的版本，所以会占用非常可观的体积，如果这些 so 库并不是核心的业务，完全可以做成插件，等到需要的时候再动态加载。再则，也有一些相对独立的业务需要独立升级，而不希望随着 APP 一起发版。比如 “游戏广场” 这样的一个业务，APP 只提供一个入口启动游戏广场，启动后接下来就不管了，这样的业务可以做成插件，插件可以动态升级（游戏广场可以自由设计自己的界面，甚至增加新的页面），也可以在多个 APP 之间使用同一插件业务（许多 APP 都有游戏广场的推广业务）。<br>考虑到种种需求，我们的插件有时只需要加载一些普通的类，有时候需要加载 res 资源，有时候需要加载 so 库，有时候需要加载新的组件类（Activity、Service 等）甚至调用宿主 APP 的某些功能（比如获取用户账号信息）。因此，我们的插件化框架在处理插件加载的具体过程时，应该能够灵活地扩展，以满足以上以及将来的各种插件需求。</p><h2 id="插件的更新策略"><a href="#插件的更新策略" class="headerlink" title="插件的更新策略"></a>插件的更新策略</h2><p>除了处理插件的加载问题外，插件化框架还需要处理插件的更新问题，要不然插件化开发就没有意义了。加载插件前，我们需要从服务器下载插件，或者判断是否需要从服务器下载新的插件版本，下载新版本插件失败的时候，我们有又需要判断本地是否有可用的旧版本。因此，插件化框架需要提供一个完善的插件更新策略，以从服务器的插件版本列表和本地的缓存插件版本列表中，挑选出最佳的插件版本（目标插件）。<br>当我们插件的某个版本出现严重问题的时候，我们希望所有的下载过这个版本的插件的 APP 都要抛弃这个插件，所以插件化框架需要有 “及时吊销” 功能。当我们插件的最新版本更新了某些重要的功能，我们希望所有的 APP 都立刻升级到这个插件版本，如果下载最新版本插件失败，需要重新下载或者直接抛弃插件，而不能使用旧版本的插件，也就是说框架需要 “强制升级” 功能。</p><h2 id="插件的安装策略"><a href="#插件的安装策略" class="headerlink" title="插件的安装策略"></a>插件的安装策略</h2><p>同一个版本的插件只需要下载一次就可以了，不能重复下载。插件化框架需要将下载下来的插件需要存放到指定的目录（我们可以把这个过程当作是 “安装插件”），以便于知道当前 APP 已经安装了哪些插件，以及这些插件有哪些版本，这样我们才可以判断需不需要从服务器下载新版本的插件。<br>同时，存放在本地文件系统上的插件是不安全的，可能被其他人恶意修改，但插件被加载进宿主 APP 后，它就是 APP 程序的一部分，可以访问 APP 的所有内存数据，插件化框架还需要提供对本地已安装插件的安全校验功能。</p><h2 id="插件投入生产前需要解决的问题"><a href="#插件投入生产前需要解决的问题" class="headerlink" title="插件投入生产前需要解决的问题"></a>插件投入生产前需要解决的问题</h2><p>上面谈到的问题大致可以归类成插件的更新、安装以及加载问题，这些都是插件化框架应该解决的基本问题。当然除了这些问题之外，在将插件化开发引入实际生产的项目中的时候，还有一些问题不得不考虑，比如在开发插件的时候如何快捷地调试和构建插件，当插件出现 BUG 的时候如何快速定位问题（因为一个插件的 BUG 可能是由 “具体的设备型号 + 具体的宿主 APP 版本号 + 具体的插件版本号” 导致的，这也是插件化开发的诟病，尽量不要吧频繁变动的业务插件化），如何做好数据上报统计以评估插件的工作效果，当然，必不可少的，我们还需要一个可靠的服务器来托管我们插件（理想的情景是，我们调试完把代码推到构建系统，构建系统构建完把插件入库并把插件的版本信息上传到服务器，服务器更新新插件版本的可用信息，整个过程不需要手动操作）。</p><p>类似之前谈到的 Android 动态加载技术需要解决的两个主要问题，插件化开发投入生产需要解决的问题大致可归纳如下：</p><ul><li>插件的更新、安装、加载策略；</li><li>插件的安全性校验；</li><li>插件与宿主的通讯（互调）方式，甚至插件间互相调用的方式；</li><li>插件调试和构建的方法；</li><li>出现 BUG 时定位问题的方法；</li><li>插件数据统计；</li><li>插件托管的服务器（插件的持续集成）；</li></ul><p>一言以蔽之，插件化开发不仅仅需要解决一个开发框架的问题，从整体上来看更像是需要解决一个开发平台的问题，除了解决代码的问题（粗体部分），还需解决生产工具或者效率的问题。</p><p>Frontia 项目致力于解决以上问题，最后，放上项目的地址：<a href="https://github.com/kaedea/android-dynamical-loading/tree/develop/android-frontia" target="_blank" rel="noopener">android-frontia</a> 。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 设计一个框架化框架 FrontiaDate = 2016-07-10 00:00:00Published = trueCategory = AndroidTag = ['Android', '动态化', 'Frontia']FileLocate = FileName = android-dynamical-loading-08-satrt-frontiahexo.comments = truehexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/4df27cf7_e064_4741_ae49_f4bca8a82724_untitled.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;结合动态加载系列文章的分析，现在开始设计并开发一个 Android 的插件化框架，命名为 Frontia。Frontia 有 “前端” 的意思，寓意着 Android 插件能像前端开发那样动态发版，同时，这一词出自 Macross 动画系列，有 “繁星” 的意思，“我们的征途是星辰大海 KIRA!!(&amp;lt; ゝ ω・)☆”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态化" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    
      <category term="Frontia" scheme="http://kaedea.com/tags/Frontia/"/>
    
  </entry>
  
  <entry>
    <title>自动给你的博客的中英文间加上空格</title>
    <link href="http://kaedea.com/2016/06/26/front-auto-space/"/>
    <id>http://kaedea.com/2016/06/26/front-auto-space/</id>
    <published>2016-06-26T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<!-- draft![](/assets/09924d84_d08c_4599_9470_492271d8f6b9_untitled.png)--><p>关于 “是否应该在中文和英文之间加上空格” 的争论在 <code>知乎</code> 上的争论历来已久，我本喜欢加上空格，只是对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。</p><a id="more"></a><blockquote><p>漢學家稱這個空白字元為「盤古之白」，因為它劈開了全形字和半形字之間的混沌。另有研究顯示，打字的時候不喜歡在中文和英文之間加空格的人，感情路都走得很辛苦，有七成的比例會在 34 歲的時候跟自己不愛的人結婚，而其餘三成的人最後只能把遺產留給自己的貓。畢竟愛情跟書寫都需要適時地留白。</p></blockquote><p>吓得我赶紧加上空格了。 (〃ﾉωﾉ)</p><h2 id="自动加空格的工具-pangu-js"><a href="#自动加空格的工具-pangu-js" class="headerlink" title="自动加空格的工具 pangu.js"></a>自动加空格的工具 <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a></h2><p><a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a> 是一个综合的开源项目，包括了各种平台的 “自动加空格” 的工具（库），比如浏览器插件、Java、Object-C、Ruby 等。比如我自己，需要用在自己的博客上，所以选择了 JavaScript。</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>1、先在你的网页里引入以下 JS 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/pangu/3.2.1/pangu.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>2、然后在适当的时刻（比如加载完网页的时候）调用以下语句即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script pangu.spacingPage();</span><br></pre></td></tr></table></figure><p>当然 <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a> 还有其他多种用法，具体使用方式请自行参考 GitHub 项目里的使用教程。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 自动给你的博客的中英文间加上空格Date = 2016-06-26 00:00:00Published = trueCategory = BlogTag = ['JavaScript', '中文排版', 'Blog']FileLocate = FileName = front-auto-spacehexo.comments = truehexo.metaAlignment = centerhexo.autoThumbnailImage = falsehexo.thumbnailImagePosition = "right"hexo.thumbnailImage = /assets/09924d84_d08c_4599_9470_492271d8f6b9_untitled.png-->]]></content>
    
    <summary type="html">
    
      &lt;!-- draft

![](/assets/09924d84_d08c_4599_9470_492271d8f6b9_untitled.png)

--&gt;


&lt;p&gt;关于 “是否应该在中文和英文之间加上空格” 的争论在 &lt;code&gt;知乎&lt;/code&gt; 上的争论历来已久，我本喜欢加上空格，只是对于英文单词频繁穿插的中文句子来说实在是有点繁琐和难看（特别是技术向文章），自从发现了有自动在博客的中英文间加上空格的脚本后，就放弃手动加空格的做法，这些频繁的工作，就交给脚本去做吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="JavaScript" scheme="http://kaedea.com/tags/JavaScript/"/>
    
      <category term="中文排版" scheme="http://kaedea.com/tags/%E4%B8%AD%E6%96%87%E6%8E%92%E7%89%88/"/>
    
      <category term="Blog" scheme="http://kaedea.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 主题 Themia 1.7</title>
    <link href="http://kaedea.com/2016/06/24/hexo-theme-themia-1.7/"/>
    <id>http://kaedea.com/2016/06/24/hexo-theme-themia-1.7/</id>
    <published>2016-06-24T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/23334229.jpg" alt=""></p><p><strong>Themia</strong> 是一个华丽的 Hexo 响应式主题，由 <strong>LouisBarranqueiro</strong> 开发的主题 <a href="https://github.com/LouisBarranqueiro/tranquilpeak-hexo-theme" target="_blank" rel="noopener">TranquiPeak</a> 的基础上改造而来，** 大部分功能都是原有主题的 **，只是为了我自己的需求做了小部分的修改，主要是针对中文适配做的修改。<br>特点</p><ol><li>增加 1080P 等大屏显示器下的 SideBar 样式；</li><li>调整文章的样式，比如字体、字体大小、对齐等；</li><li>中英混排自动加入空格（参考 <a href="https://github.com/vinta/pangu.js" target="_blank" rel="noopener">pangu.js</a>）；</li><li>同步更新至 TranquiPeak 1.7.1；</li></ol><p>将项目根目录的所有文件复制进一个文件夹，并把该文件夹复制进 Hexo 项目的 themes 目录下，再把 Hexo 的配置文件_config.yml 中的 theme 标签的指改为该文件夹的名称即可。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = Hexo 主题 Themia 1.7Date = 2016-06-24 00:00:00Published = trueCategory = BlogTag = ['Blog', 'Hexo', '主题']FileLocate = FileName = hexo-theme-themia-1.7hexo.comments = truehexo.link = https://github.com/kaedea/hexo-theme-themiahexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/assets/23334229.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Themia&lt;/strong&gt; 是一个华丽的 Hexo 响应式主题，由 &lt;strong&gt;LouisBarranqueiro&lt;/strong&gt; 开发的主题 &lt;a hr
      
    
    </summary>
    
    
      <category term="Blog" scheme="http://kaedea.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://kaedea.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://kaedea.com/tags/Hexo/"/>
    
      <category term="主题" scheme="http://kaedea.com/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>动态创建 Activity 模式</title>
    <link href="http://kaedea.com/2016/06/14/android-dynamical-loading-07-dynamic-activity/"/>
    <id>http://kaedea.com/2016/06/14/android-dynamical-loading-07-dynamic-activity/</id>
    <published>2016-06-14T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>还记得我们在代理 Activity 模式里谈到启动插件 APK 里的 Activity 的两个难题吗，由于插件里的 Activity 没在主项目的 Manifest 里面注册，所以无法经历系统 Framework 层级的一系列初始化过程，最终导致获得的 Activity 实例并没有生命周期和无法使用 res 资源。</p><p>使用代理 Activity 能够解决这两个问题，但是有一些限制：</p><ul><li>实际运行的 Activity 实例其实都是 ProxyActivity，并不是真正想要启动的 Activity；</li><li>ProxyActivity 只能指定一种 LaunchMode，所以插件里的 Activity 无法自定义 LaunchMode；</li><li>不支持静态注册的 BroadcastReceiver；</li><li>往往不是所有的 APK 都可作为插件被加载，插件项目需要依赖特定的框架，还有需要遵循一定的 “开发规范”；</li></ul><p>特别是最后一个，无法直接把一个普通的 APK 作为插件使用。这个其实也不算是限制，如果我们需要进行插件化开发，我们总希望能够通过一些框架限制和规范插件的行为，在加载插件前就知道插件大概有哪些功能，这样不仅能方便对插件行为的控制，还能在一定程度上确保插件的安全（运行一个完全未知的可执行文件鬼知道它会做些什么）。不过这样做就要求插件必须依赖特定的框架，这对插件是一种侵入式开发，也就是说，开发插件时不能像开发普通 APP 那样自由。</p><p>那么有办法避开这些限制，做到完全非侵入式开发吗？比如，通过动态加载框架，不用安装就直接运行《Flappy Bird》的 APK 安装包。这听起来好像是只有获得 ROOT 权限才能做到的事情，要不然随便写个空壳的 APK 加载别人的游戏安装包就直接能运行了。不过，确实有人做到了，通过动态生成 Activity 类的方式。</p><a id="more"></a><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul><li>Author : <a href="https://github.com/kaedea" target="_blank" rel="noopener">Kaede</a><ul><li>Index : <a href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index">ANDROID 动态加载系列</a></li></ul></li><li>GitHub : <a href="https://github.com/kaedea/android-dynamical-loading" target="_blank" rel="noopener">kaedea/android-dynamical-loading</a></li></ul><h2 id="动态创建-Activity-模式"><a href="#动态创建-Activity-模式" class="headerlink" title="动态创建 Activity 模式"></a>动态创建 Activity 模式</h2><p>插件的 Activity 不是标准的 Activity 对象才会有上述的这些限制，使其成为标准的 Activity 是解决问题的关键，而要使其成为标准的 Activity，则需要在主项目里注册这些 Activity。总不能把插件 APK 所有的 Activity 都事先注册到宿主项目里面吧，想到代理模式需要注册一个代理的 ProxyActivity，那么能不能在主项目里 ** 注册一个通用的 Activity**（比如 TargetActivity）给插件里所有的 Activity 用呢？解决对策就是，在需要启动插件的某一个 Activity（比如 PlugActivity）的时候，动态创建一个 TargetActivity，新创建的 TargetActivity 会继承 PlugActivity 的所有共有行为，而这个 TargetActivity 的包名与类名刚好与我们事先注册的 TargetActivity 一致，我们就能以标准的方式启动这个 Activity。</p><p>运行时动态创建并编译一个 Activity 类，这种想法不是天方夜谭，动态创建类的工具有 <a href="https://github.com/crittercism/dexmaker" target="_blank" rel="noopener">dexmaker</a> 和 <a href="http://asm.ow2.org/" target="_blank" rel="noopener">asmdex</a>，二者均能实现动态字节码操作，最大的区别是前者是创建 DEX 文件，而后者是创建 CLASS 文件。</p><h2 id="使用-DexMaker-动态创建一个类"><a href="#使用-DexMaker-动态创建一个类" class="headerlink" title="使用 DexMaker 动态创建一个类"></a>使用 DexMaker 动态创建一个类</h2><p>这种运行时创建一个编译好并能运行的类的方式叫做 “动态字节码操作”（runtime bytecode manipulation），使用 DexMaker 工具能创建一个 DEX 文件，之后我们再反编译这个 DEX 看看创建出来的类是什么样子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMakeDex</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">DexMaker dexMaker = <span class="keyword">new</span> DexMaker();</span><br><span class="line"><span class="comment">// Generate a HelloWorld class.</span></span><br><span class="line">TypeId&lt;?&gt; helloWorld = TypeId.get(<span class="string">"LHelloWorld;"</span>);</span><br><span class="line">dexMaker.declare(helloWorld, <span class="string">"HelloWorld.generated"</span>, Modifier.PUBLIC, TypeId.OBJECT);</span><br><span class="line">generateHelloMethod(dexMaker, helloWorld);</span><br><span class="line"><span class="comment">// Create the dex file and load it.</span></span><br><span class="line">File outputDir = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory() + File.separator + <span class="string">"dexmaker"</span>);</span><br><span class="line"><span class="keyword">if</span> (!outputDir.exists())outputDir.mkdir();</span><br><span class="line">ClassLoader loader = dexMaker.generateAndLoad(<span class="keyword">this</span>.getClassLoader(), outputDir);</span><br><span class="line">Class&lt;?&gt; helloWorldClass = loader.loadClass(<span class="string">"HelloWorld"</span>);</span><br><span class="line"><span class="comment">// Execute our newly-generated code in-process.</span></span><br><span class="line">helloWorldClass.getMethod(<span class="string">"hello"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">Log.e(<span class="string">"MainActivity"</span>,<span class="string">"[onMakeDex]"</span>,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generates Dalvik bytecode equivalent to the following method.</span></span><br><span class="line"><span class="comment"> *    public static void hello() &#123;</span></span><br><span class="line"><span class="comment"> *        int a = 0xabcd;</span></span><br><span class="line"><span class="comment"> *        int b = 0xaaaa;</span></span><br><span class="line"><span class="comment"> *        int c = a - b;</span></span><br><span class="line"><span class="comment"> *        String s = Integer.toHexString(c);</span></span><br><span class="line"><span class="comment"> *        System.out.println(s);</span></span><br><span class="line"><span class="comment"> *        return;</span></span><br><span class="line"><span class="comment"> *    &#125;</span></span><br><span class="line"><span class="comment"> */</span><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateHelloMethod</span><span class="params">(DexMaker dexMaker, TypeId&lt;?&gt; declaringType)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Lookup some types we'll need along the way.</span></span><br><span class="line">TypeId&lt;System&gt; systemType = TypeId.get(System<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">TypeId&lt;PrintStream&gt; printStreamType = TypeId.get(PrintStream<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identify the 'hello()' method on declaringType.</span></span><br><span class="line">MethodId hello = declaringType.getMethod(TypeId.VOID, <span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare that method on the dexMaker. Use the returned Code instance// as a builder that we can append instructions to.</span></span><br><span class="line">Code code = dexMaker.declare(hello, Modifier.STATIC | Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare all the locals we'll need up front. The API requires this.</span></span><br><span class="line">Local&lt;Integer&gt; a = code.newLocal(TypeId.INT);</span><br><span class="line">Local&lt;Integer&gt; b = code.newLocal(TypeId.INT);</span><br><span class="line">Local&lt;Integer&gt; c = code.newLocal(TypeId.INT);</span><br><span class="line">Local&lt;String&gt; s = code.newLocal(TypeId.STRING);</span><br><span class="line">Local&lt;PrintStream&gt; localSystemOut = code.newLocal(printStreamType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int a = 0xabcd;</span></span><br><span class="line">code.loadConstant(a, <span class="number">0xabcd</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int b = 0xaaaa;</span></span><br><span class="line">code.loadConstant(b, <span class="number">0xaaaa</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// int c = a - b;</span></span><br><span class="line">code.op(BinaryOp.SUBTRACT, c, a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String s = Integer.toHexString(c);</span></span><br><span class="line">MethodId&lt;Integer, String&gt; toHexString</span><br><span class="line">= TypeId.get(Integer.class).getMethod(TypeId.STRING, "toHexString", TypeId.INT);</span><br><span class="line">code.invokeStatic(toHexString, s, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(s);</span></span><br><span class="line">FieldId&lt;System, PrintStream&gt; systemOutField = systemType.getField(printStreamType, <span class="string">"out"</span>);</span><br><span class="line">code.sget(systemOutField, localSystemOut);</span><br><span class="line">MethodId&lt;PrintStream, Void&gt; printlnMethod = printStreamType.getMethod(</span><br><span class="line">TypeId.VOID, <span class="string">"println"</span>, TypeId.STRING);</span><br><span class="line">code.invokeVirtual(printlnMethod, <span class="keyword">null</span>, localSystemOut, s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return;</span></span><br><span class="line">code.returnVoid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后在 SD 卡的 dexmaker 目录下找到刚创建的文件 “Generated1532509318.jar”，把里面的 “classes.dex” 解压出来，然后再用 “dex2jar” 工具转化成 jar 文件，最后再用 “jd-gui” 工具反编译 jar 的源码。</p><p><img src="/assets/c9b4ef05_95fa_4e01_836e_7f7b47707341_untitled.png" alt=""></p><p>至此，我们已经成功在运行时创建一个编译好的类（的 DEX）。</p><h2 id="修改需要启动的目标-Activity"><a href="#修改需要启动的目标-Activity" class="headerlink" title="修改需要启动的目标 Activity"></a>修改需要启动的目标 Activity</h2><p>接下来的问题是如何把需要启动的、在 Manifest 里面没有注册的 PlugActivity 换成有注册的 TargetActivity。<br>在 Android，虚拟机加载类的时候，是通过 ClassLoader 的 loadClass 方法，而 loadClass 方法并不是 final 类型的，这意味着我们可以创建自己的类去继承 ClassLoader，以重载 loadClass 方法并改写类的加载逻辑，在需要加载 PlugActivity 的时候，偷偷把其换成 TargetActivity。</p><p>大致思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CJClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">loadClass</span> <span class="params">(String className)</span></span>&#123;<span class="keyword">if</span> (当前上下文插件不为空) &#123;<span class="keyword">if</span> ( className 是 TargetActivity)&#123;</span><br><span class="line">             找到当前实际要加载的原始 PlugActivity，动态创建类（TargetActivity extends PlugActivity ）的 dex 文件</span><br><span class="line">             <span class="keyword">return</span>  从 dex 文件中加载的 TargetActivity</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="keyword">return</span>  使用对应的 PluginClassLoader 加载普通类&#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="keyword">super</span>.loadClass ()<span class="comment">// 使用原来的类加载方法</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能把启动插件里的 PlugActivity 变成启动动态创建的 TargetActivity。</p><p>不过还有一个问题，主项目启动插件 Activity 的时候，我们可以替换 Activity，但是如果在插件 Activity（比如 MainActivity）启动另一个 Activity（SubActivity）的时候怎么办？插件时普通的第三方 APK，我们无法更改里面跳转 Activity 的逻辑。其实，从主项目启动插件 MainActivity 的时候，其实启动的是我们动态创建的 TargetActivity（extends MainActivity），而我们知道 Activity 启动另一个 Activity 的时候都是使用其 “startActivityForResult” 方法，所以我们可以在创建 TargetActivity 时，重写其 “startActivityForResult” 方法，让它在启动其他 Activity 的时候，也采用动态创建 Activity 的方式，这样就能解决问题。</p><h2 id="动态创建-Activity-开源项目-android-pluginmgr"><a href="#动态创建-Activity-开源项目-android-pluginmgr" class="headerlink" title="动态创建 Activity 开源项目 android-pluginmgr"></a>动态创建 Activity 开源项目 <a href="https://github.com/houkx/android-pluginmgr/" target="_blank" rel="noopener">android-pluginmgr</a></h2><p>这种脑洞大开的动态加载思路来自于 <strong>houkx</strong> 的开源项目 <strong>android-pluginmgr</strong>。</p><p><img src="/assets/f2613714_411d_4793_8ff0_5e317f1a706d_untitled.png" alt=""></p><p><code>android-pluginmgr</code> 项目中有三种 ClassLoader，一是用于替换宿主 APK 的 Application 的 <code>CJClassLoader</code>，二是用于加载插件 APK 的 <code>PluginClassLoader</code>，再来是用于加载启动插件 Activity 时动态生成的 PlugActivity 的 dex 包的 <code>DexClassLoader</code>（存放在 Map 集合 <code>proxyActivityLoaderMap</code> 里面）。其中 <code>CJClassLoader</code> 是 <code>PluginClassLoader</code> 的 Parent，而 <code>PluginClassLoader</code> 又是第三种 <code>DexClassLoader</code> 的 Parent。</p><p>ClassLoader 类加载 Class 的时候，会先使用 Parent 的 <code>ClassLoader</code>，但 Parent 不能完成加载工作时，才会调用 Child 的 <code>ClassLoader</code> 去完成工作。</p><blockquote><p>java.lang.ClassLoader Loads classes and resources from a repository. One or more class loaders are installed at runtime. These are consulted whenever the runtime system needs a specific class that is not yet available in-memory. Typically, class loaders are grouped into a tree where child class loaders delegate all requests to parent class loaders. Only if the parent class loader cannot satisfy the request, the child class loader itself tries to handle it.</p></blockquote><p>具体分析请参考 <a href="http://segmentfault.com/a/1190000004062880" target="_blank" rel="noopener">Android 动态加载基础 ClassLoader 的工作机制</a>。</p><p>所以每加载一个 Activity 的时候都会调用到最上级的 <code>CJClassLoader</code> 的 <code>loadClass</code> 方法，从而保证启动插件 Activity 的时候能顺利替换成 PlugActivity。当然如何控制着三种 ClassLoader 的加载工作，也是 <code>pluginmgr</code> 项目的设计难度之一。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>动态类创建的方式，使得注册一个通用的 Activity 就能给多给 Activity 使用，对这种做法存在的问题也是明显的：</p><ol><li>使用同一个注册的 Activity，所以一些需要在 Manifest 注册的属性无法做到每个 Activity 都自定义配置；</li><li>插件中的权限，无法动态注册，插件需要的权限都得在宿主中注册，无法动态添加权限；</li><li>插件的 Activity 无法开启独立进程，因为这需要在 Manifest 里面注册；</li><li>动态字节码操作涉及到 Hack 开发，所以相比代理模式起来不稳定；</li></ol><p>其中不稳定的问题出现在对 Service 的支持上，使用动态创建类的方式可以搞定 Activity 和 Broadcast Receiver，但是使用类似的方式处理 Service 却不行，因为 “ContextImpl.getApplicationContext” 期待得到一个非 ContextWrapper 的 context，如果不是则继续下次循环，目前的 Context 实例都是 wrapper，所以会进入死循环。</p><p>据 <strong>houkx</strong> 称他现在有另外的思路实现 “启动为安装的普通第三方 APK” 的目的，而且不是基于动态类创建的原理，期待他的开源项目的更新。</p><h2 id="代理-Activity-模式与动态创建-Activity-模式的区别"><a href="#代理-Activity-模式与动态创建-Activity-模式的区别" class="headerlink" title="代理 Activity 模式与动态创建 Activity 模式的区别"></a>代理 Activity 模式与动态创建 Activity 模式的区别</h2><p>简单地说，最大的不同是代理模式使用了一个 ** 代理的 Activity<strong>，而动态创建 Activity 模式使用了一个 ** 通用的 Activity</strong>。</p><p>代理模式中，使用一个代理 Activity 去完成本应该由插件 Activity 完成的工作，这个代理 Activity 是一个标准的 Android Activity 组件，具有生命周期和上下文环境（ContextWrapper 和 ContextCompl），但是它自身只是一个空壳，并没有承担什么业务逻辑；而插件 Activity 其实只是一个普通的 Java 对象，它没有上下文环境，但是却能正常执行业务逻辑的代码。代理 Activity 和不同的插件 Activity 配合起来，就能完成不同的业务逻辑了。所以代理模式其实还是使用常规的 Android 开发技术，只是在处理插件资源的时候强制调用了系统的隐藏 API（除非某些 ROM 蛋疼修改了这个 API），因此这种模式还是可以稳定工作和升级的。</p><p>动态创建 Activity 模式，被动态创建出来的 Activity 类是有在主项目里面注册的，它是一个标准的 Activity，它有自己的 Context 和生命周期，不需要代理的 Activity。</p><p>(这个系列的下个文章开始介绍插件化框架 “Android Frontia” 的设计和开发过程。)</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://blog.csdn.net/hkxxx/article/details/42194387" target="_blank" rel="noopener">http://blog.csdn.net/hkxxx/article/details/42194387</a></li></ul><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 动态创建 Activity 模式Date = 2016-06-14 00:00:00Published = trueCategory = AndroidTag = ['Android', '动态化']FileLocate = FileName = android-dynamical-loading-07-dynamic-activityhexo.comments = truehexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;还记得我们在代理 Activity 模式里谈到启动插件 APK 里的 Activity 的两个难题吗，由于插件里的 Activity 没在主项目的 Manifest 里面注册，所以无法经历系统 Framework 层级的一系列初始化过程，最终导致获得的 Activity 实例并没有生命周期和无法使用 res 资源。&lt;/p&gt;
&lt;p&gt;使用代理 Activity 能够解决这两个问题，但是有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际运行的 Activity 实例其实都是 ProxyActivity，并不是真正想要启动的 Activity；&lt;/li&gt;
&lt;li&gt;ProxyActivity 只能指定一种 LaunchMode，所以插件里的 Activity 无法自定义 LaunchMode；&lt;/li&gt;
&lt;li&gt;不支持静态注册的 BroadcastReceiver；&lt;/li&gt;
&lt;li&gt;往往不是所有的 APK 都可作为插件被加载，插件项目需要依赖特定的框架，还有需要遵循一定的 “开发规范”；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特别是最后一个，无法直接把一个普通的 APK 作为插件使用。这个其实也不算是限制，如果我们需要进行插件化开发，我们总希望能够通过一些框架限制和规范插件的行为，在加载插件前就知道插件大概有哪些功能，这样不仅能方便对插件行为的控制，还能在一定程度上确保插件的安全（运行一个完全未知的可执行文件鬼知道它会做些什么）。不过这样做就要求插件必须依赖特定的框架，这对插件是一种侵入式开发，也就是说，开发插件时不能像开发普通 APP 那样自由。&lt;/p&gt;
&lt;p&gt;那么有办法避开这些限制，做到完全非侵入式开发吗？比如，通过动态加载框架，不用安装就直接运行《Flappy Bird》的 APK 安装包。这听起来好像是只有获得 ROOT 权限才能做到的事情，要不然随便写个空壳的 APK 加载别人的游戏安装包就直接能运行了。不过，确实有人做到了，通过动态生成 Activity 类的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态化" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>双屏显示器配合机械键盘食用更佳</title>
    <link href="http://kaedea.com/2016/06/11/tool-duplicate-screen-and-mechanical-keyboard/"/>
    <id>http://kaedea.com/2016/06/11/tool-duplicate-screen-and-mechanical-keyboard/</id>
    <published>2016-06-11T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/4f2afbfb_c3c1_4faf_962b_3c1ca9933b2e_untitled.png" alt=""></p><p>我一直计划着打造自己的工作室（工作平台），因为我觉得除了相关姿势扎实以外，优秀的生产工具也是提高办公效率的利器，而且好玩的生产工具还能提高自己工作的积极性，减少咸鱼状态。所以，适当地买一些优质的生产工具犒劳自己，也是我自己为数不多的乐趣。说到开发相关的生产工具，则莫过于大屏显示器和机械键盘了。</p><a id="more"></a><h3 id="双屏显示器"><a href="#双屏显示器" class="headerlink" title="双屏显示器"></a>双屏显示器</h3><p><img src="/assets/fb24bf6b_cb76_4d08_b294_055da2ce452f_untitled.png" alt=""></p><p>写代码的时候，我们当然希望编辑器越大越好，但是 IDE 自身就有几个分区，除了 Editor 之外，还有 Project、Log、Debug 等窗口，所以 Editor 所占的区域并不多，如果电脑屏幕本身尺寸就小的话，就得在多个窗口之间来回切换。而且，开发过程中不止需要写代码，还要看文档，看设计图，上 Google 查资料，那不仅 IDE 自身，我们还得在多个工具之间来回切换。一开始我也觉得没什么，只要熟练了就习惯了，但后来我觉得，解决这些经常需要重复的繁琐动作，是提高作业效率的有效办法，所以便开始琢磨着大屏幕的问题。<br>一开始我打算买一个 2K 的大屏显示器，这样可以在桌面上放多个窗口，不过这个时间段 2K 的显示器的选择可不多（基本也就 DELL 和 AOC 家的），而且性价比不咋滴（囊中羞涩），最主要的，如果只使用一个 2K 的显示器，原本的显示器就得闲置了，所以我选择了双屏的方案。<br>其实我更喜欢 “双屏显示器 + 显示器支架” 的方案，只不过我的办公位空间不够，所以选择了一横一竖的折中方案。刚好手头有一个急着上线的需求，多显示器的魅力一下子就彰显出来。我基本保持着 “一个屏幕写代码，一个屏幕看文档” 的姿势做完了这个需求，只能说这种感觉比我想象中的要好，有种中毒上瘾的感觉，这时候我实在感叹 “在办公方面能剁手就剁手” 这一道理了。我觉得我再也离不开多屏显示器了，立刻在我的 “工作平台企画” 上加上了 “双屏显示器” 这一个 ITEM。</p><h3 id="机械键盘"><a href="#机械键盘" class="headerlink" title="机械键盘"></a>机械键盘</h3><p><img src="/assets/99abf0da_5c31_4ace_a11d_189882698f50_untitled.png" alt=""></p><p>机械键盘对我的吸引力就不再强调了，上个月在日亚买了个 FLICO 忍者青轴，这是我第二个机械键盘，用了一个月感觉还不错，最近也给其换上了 ABS 键帽，相比彩虹浸染之类的，我比较喜欢大二色的主题。</p><p><img src="/assets/647a10ab_36ab_41a4_977d_799de6aaa723_untitled.png" alt=""></p><p>我选的这个键盘是 “百合丁香”。</p><p><img src="/assets/f6656a63_a12c_49f7_b82f_92abf0685f15_untitled.png" alt=""></p><p>关于机械键盘轴体的选择，有这么一个流传的段子：</p><blockquote><p>青轴像少女，夹的紧，下去的时候需要用些力气，深浅你都能感觉得到，虽然叫声很大，总体给人感觉确很兴奋。　　茶轴像少妇，虽然比少女的要松，但很容易下去，而且仔细感觉也能体会到深浅，叫声没有少女那个清脆，但却更趋近于性感的中音，总体给人感觉十分舒畅。　　红轴像泼妇，虽然松，下去的时候不需要太用力就能到见底，插一点爽深插更爽，虽然插到底才有一点声音，但是玩起来很有感觉，让人有种玩了一下还想玩第二下的赶脚！　　黑轴像妓女玩起来很带劲，可以放心的用力插，很少能插到底，力气大它就有叫声，但是插多了你会觉得累！</p></blockquote><p>青轴自然是我的首选（我比较喜欢青蓝色 🌝），那清脆的 “啪啪啪” 的打击感我早已喜欢上。不过青轴比较适合打字，而茶轴比较符合 Geek（忘了从哪听来的说法），而同事的茶轴键盘我用起来感觉手感也挺不错的，刚好我宿舍缺一个键盘（周末把键盘背回家的就我一个么），所以接下来打算入手一个 67 键位的茶轴键盘（是不是打开了剁手的新世界啊）。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 双屏显示器配合机械键盘食用更佳Date = 2016-6-11 00:00:00Published = trueCategory = UtilityTag = ['生产工具', '机械键盘', '显示器']FileLocate = FileName = tool-duplicate-screen-and-mechanical-keyboardhexo.comments = truehexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/assets/4f2afbfb_c3c1_4faf_962b_3c1ca9933b2e_untitled.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我一直计划着打造自己的工作室（工作平台），因为我觉得除了相关姿势扎实以外，优秀的生产工具也是提高办公效率的利器，而且好玩的生产工具还能提高自己工作的积极性，减少咸鱼状态。所以，适当地买一些优质的生产工具犒劳自己，也是我自己为数不多的乐趣。说到开发相关的生产工具，则莫过于大屏显示器和机械键盘了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Utility" scheme="http://kaedea.com/categories/Utility/"/>
    
    
      <category term="生产工具" scheme="http://kaedea.com/tags/%E7%94%9F%E4%BA%A7%E5%B7%A5%E5%85%B7/"/>
    
      <category term="机械键盘" scheme="http://kaedea.com/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"/>
    
      <category term="显示器" scheme="http://kaedea.com/tags/%E6%98%BE%E7%A4%BA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>代理 Activity 模式</title>
    <link href="http://kaedea.com/2016/06/10/android-dynamical-loading-06-proxy-activity/"/>
    <id>http://kaedea.com/2016/06/10/android-dynamical-loading-06-proxy-activity/</id>
    <published>2016-06-10T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<p>简单模式中，使用 ClassLoader 加载外部的 Dex 或 Apk 文件，可以加载一些本地 APP 不存在的类（或者更新本地已存在的类），从而执行一些新的代码逻辑，但是使用这种方法却不能直接启动插件里的 Activity 等组件，也没办法使用 res 资源，如果不解决这两个问题，则使用插件化的方式开发 Android 业务会非常繁琐。</p><a id="more"></a><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><ul><li>Author : <a href="https://github.com/kaedea" target="_blank" rel="noopener">Kaede</a><ul><li>Index : <a href="http://kaedea.com/2016/02/05/android-dynamical-loading-00-index">ANDROID 动态加载系列</a></li></ul></li><li>GitHub : <a href="https://github.com/kaedea/android-dynamical-loading" target="_blank" rel="noopener">kaedea/android-dynamical-loading</a></li></ul><h2 id="启动没有注册的-Activity-的两个主要问题"><a href="#启动没有注册的-Activity-的两个主要问题" class="headerlink" title="启动没有注册的 Activity 的两个主要问题"></a>启动没有注册的 Activity 的两个主要问题</h2><p>Activity 等组件是需要在 Manifest 中注册后才能以标准 Intent 的方式启动的（如果有兴趣强烈推荐你了解下 AMS 和 Activity 生命周期实现的机制），简单来说，通过 ClassLoader 加载并实例化的 Activity 实例只是一个普通的 Java 对象，能调用对象的方法，但是它没有生命周期，而且 Activity 等系统组件是需要 Android 的上下文环境的（也就是我们常说的 Context），没有这些东西 Activity 根本无法工作。</p><p>使用插件 APK 里的 Activity 需要解决 ** 两个问题 **：</p><ol><li>如何使插件 APK 里的 Activity 具有生命周期；</li><li>如何使插件 APK 里的 Activity 具有上下文环境（使用 res 资源）；</li></ol><p>代理 Activity 模式为解决这两个问题提供了一种思路。</p><h2 id="代理-Activity-模式"><a href="#代理-Activity-模式" class="headerlink" title="代理 Activity 模式"></a>代理 Activity 模式</h2><p>这种模式也是我们项目中，继 “简单动态加载模式” 之后，第二种投入实际生产项目的开发方式。其主要思路是：主项目 APK 注册一个代理 Activity（比如命名为 ProxyActivity），ProxyActivity 是一个普通的 Activity，但只是一个空壳，自身并没有什么业务逻辑。每次打开插件 APK 里的某一个 Activity 的时候，都是在主项目里使用标准的方式启动 ProxyActivity，再在 ProxyActivity 的生命周期里同步调用插件中的 Activity 实例的生命周期方法，从而执行插件 APK 的业务逻辑。</p><blockquote><p>ProxyActivity + 没注册的 Activity = 标准的 Activity</p></blockquote><p>下面谈谈代理模式是怎么处理上面提到的两个问题的。</p><h3 id="1-处理插件-Activity-的生命周期"><a href="#1-处理插件-Activity-的生命周期" class="headerlink" title="1. 处理插件 Activity 的生命周期"></a>1. 处理插件 Activity 的生命周期</h3><p>如果不使用任何注入的方式干预 ActivityManagerService 启动 Activity 的过程，目前还真的没什么办法能够处理这个问题。一个 Activity 的启动，如果不采用标准的 Intent 方式，没有经历过 AMS 的一系列注册和初始化过程，它的生命周期方法是不会被系统调用的（除非你能够修改 Android 系统的一些代码，而这已经是另一个领域的话题了，这里不展开）。</p><p>那把插件 APK 里所有 Activity 都注册到主项目的 Manifest 里，再以标准 Intent 方式启动，这样插件的 Activity 就能工作了。但是事先主项目并不知道插件 Activity 里会新增哪些 Activity，如果每次有新加的 Activity 都需要升级主项目的版本，那不是本末倒置了，不如把插件的逻辑直接写到主项目里来得方便，所以事先注册 Activity 组件的做法只适合于 Activity 不多变的业务。</p><p>那就绕绕弯吧，生命周期不就是系统对 Activity 一些特定接口方法的调用嘛，那我们可以在主项目里创建一个 ProxyActivity，再由它去代理调用插件 Activity 的生命周期方法（熟悉设计模式的同学应该知道这种写法叫做代理模式，这也是我代理 Activity 模式叫法的由来）。<br>用 ProxyActivity（一个标准的 Activity 实例）的生命周期同步控制插件 Activity（普通类的实例）的生命周期，同步的方式可以有下面两种：</p><ul><li>在 ProxyActivity 生命周期里用反射调用插件 Activity 相应生命周期的方法，简单粗暴；</li><li>把插件 Activity 的生命周期抽象成接口，在 ProxyActivity 的生命周期里调用；另外，多了这一层接口，也方便主项目控制插件 Activity；</li></ul><p>这里补充说明下，Fragment 自带生命周期，用 Fragment 来代替 Activity 开发可以省去大部分生命周期的控制工作，但是会使得界面跳转比较麻烦。</p><h3 id="2-在插件-Activity-里使用-res-资源"><a href="#2-在插件-Activity-里使用-res-资源" class="headerlink" title="2. 在插件 Activity 里使用 res 资源"></a>2. 在插件 Activity 里使用 res 资源</h3><p>使用代理的方式同步调用生命周期的做法容易理解，也没什么问题，但是要使用插件里面的 res 资源就有点麻烦了。简单的说，res 里的每一个资源都会在 R.java 里生成一个对应的 Integer 类型的 id，APP 启动时会先把 R.java 注册到当前的上下文环境，我们在代码里以 R 文件的方式使用资源时正是通过使用这些 id 访问 res 资源，然而插件的 R.java 并没有注册到当前的上下文环境，所以插件的 res 资源也就无法通过 id 使用了。</p><p>这个问题困扰了我们很久，一开始的项目急于投入生产，所以我们索性抛开 res 资源，插件里需要用到的新资源都通过纯 Java 代码的方式创建（包括 XML 布局、动画、点九图等），蛋疼但有效。直到网上出现了解决这一个问题的有效方法（一开始貌似是在手机 QQ 项目中出现的，但是没有开源所以不清楚，在这里真的佩服这些对技术这么有追求的开发者）。</p><p>记得我们平时怎么使用 res 资源的吗，就是 “getResources ().getXXX (resid)”，看看 “getResources ()”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mResources;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOverrideConfiguration == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mResources = <span class="keyword">super</span>.getResources();</span><br><span class="line">            <span class="keyword">return</span> mResources;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Context resc = createConfigurationContext(mOverrideConfiguration);</span><br><span class="line">            mResources = resc.getResources();</span><br><span class="line">            <span class="keyword">return</span> mResources;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看起来像是通过 mResources 实例获取 res 资源的，再找找 mResources 实例是怎么初始化的，看看上面的代码发现是使用了 super 类 ContextThemeWrapper 里的 “getResources ()” 方法，看进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Context mBase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.getResources();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看样子又调用了 Context 的 “getResources ()” 方法，看到这里，熟悉 Java 的我们应该知道 Context 只是个抽象类，其实际工作都是在 ContextImpl 完成的，赶紧去 ContextImpl 里看看 “getResources ()” 方法吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Resources <span class="title">getResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mResources;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>………… ……<br>你 TM 在逗我么，还是没有 mResources 的创建过程啊！啊，不对，mResources 是 ContextImpl 的成员变量，可能是在构造方法中创建的，赶紧去看看构造方法（这里只给出关键代码）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),</span><br><span class="line">                        packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),</span><br><span class="line">                        packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,</span><br><span class="line">                        overrideConfiguration, compatInfo);</span><br><span class="line">mResources = resources;</span><br></pre></td></tr></table></figure><p>看样子是在 ResourcesManager 的 “getTopLevelResources” 方法中创建的，看进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Resources <span class="title">getTopLevelResources</span><span class="params">(String resDir, String[] splitResDirs,</span></span></span><br><span class="line"><span class="function"><span class="params">           String[] overlayDirs, String[] libDirs, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">           Configuration overrideConfiguration, CompatibilityInfo compatInfo)</span> </span>&#123;</span><br><span class="line">       Resources r;</span><br><span class="line">       AssetManager assets = <span class="keyword">new</span> AssetManager();</span><br><span class="line">       <span class="keyword">if</span> (libDirs != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (String libDir : libDirs) &#123;</span><br><span class="line">               <span class="keyword">if</span> (libDir.endsWith(<span class="string">".apk"</span>)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (assets.addAssetPath(libDir) == <span class="number">0</span>) &#123;</span><br><span class="line">                       Log.w(TAG, <span class="string">"Asset path '"</span> + libDir +</span><br><span class="line">                               <span class="string">"' does not exist or contains no resources."</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       DisplayMetrics dm = getDisplayMetricsLocked(displayId);</span><br><span class="line">       Configuration config ……;</span><br><span class="line">       r = <span class="keyword">new</span> Resources(assets, dm, config, compatInfo);</span><br><span class="line">       <span class="keyword">return</span> r;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>看来这里是关键了，看样子就是通过这些代码从一个 APK 文件加载 res 资源并创建 Resources 实例，经过这些逻辑后就可以使用 R 文件访问资源了。具体过程是，获取一个 AssetManager 实例，使用其 “addAssetPath” 方法加载 APK（里的资源），再使用 DisplayMetrics、Configuration、CompatibilityInfo 实例一起创建我们想要的 Resources 实例。</p><p>最终访问插件 APK 里 res 资源的关键代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    AssetManager assetManager = AssetManager<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">    Method addAssetPath = assetManager.getClass().getMethod(<span class="string">"addAssetPath"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    addAssetPath.invoke(assetManager, mDexPath);</span><br><span class="line">    mAssetManager = assetManager;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">Resources superRes = <span class="keyword">super</span>.getResources();</span><br><span class="line">mResources = <span class="keyword">new</span> Resources(mAssetManager, superRes.getDisplayMetrics(),</span><br><span class="line">        superRes.getConfiguration());</span><br></pre></td></tr></table></figure><p>注意，有的人担心从插件 APK 加载进来的 res 资源的 ID 可能与主项目里现有的资源 ID 冲突，其实这种方式加载进来的 res 资源并不是融入到主项目里面来，主项目里的 res 资源是保存在 ContextImpl 里面的 Resources 实例，整个项目共有，而新加进来的 res 资源是保存在新创建的 Resources 实例的，也就是说 ProxyActivity 其实有两套 res 资源，并不是把新的 res 资源和原有的 res 资源合并了（所以不怕 R.id 重复），** 对两个 res 资源的访问都需要用对应的 Resources 实例 **，这也是开发时要处理的问题。（其实应该有 3 套，Android 系统会加载一套 framework-res.apk 资源，里面存放系统默认 Theme 等资源。）</p><p>额外补充下，这里你可能注意到了我们采用了反射的方法调用 AssetManager 的 “addAssetPath” 方法，而在上面 ResourcesManager 中调用 AssetManager 的 “addAssetPath” 方法是直接调用的，不用反射啊，而且看看 SDK 里 AssetManager 的 “addAssetPath” 方法的源码（这里也能看到具体 APK 资源的提取过程是在 Native 里完成的），发现它也是 public 类型的，外部可以直接调用，为什么还要用反射呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add an additional set of assets to the asset manager.  This can be</span></span><br><span class="line"><span class="comment">     * either a directory or ZIP file.  Not for use by applications.  Returns</span></span><br><span class="line"><span class="comment">     * the cookie of the added asset, or 0 on failure.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAssetPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> res = addAssetPathNative(path);</span><br><span class="line">            makeStringBlocks(mStringBlocks);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里有个误区，SDK 的源码只是给我们参考用的，APP 实际上运行的代码逻辑在 android.jar 里面（位于 android-sdk\platforms\android-XX），反编译 android.jar 并找到 ResourcesManager 类就可以发现这些接口都是对应用层隐藏的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span> </span>&#123;</span><br><span class="line">  AssetManager()&#123;<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title">open</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> InputStream <span class="title">open</span><span class="params">(String fileName, <span class="keyword">int</span> accessMode)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AssetFileDescriptor <span class="title">openFd</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> String[] list(String paramString) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AssetFileDescriptor <span class="title">openNonAssetFd</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AssetFileDescriptor <span class="title">openNonAssetFd</span><span class="params">(<span class="keyword">int</span> cookie, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> XmlResourceParser <span class="title">openXmlResourceParser</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> XmlResourceParser <span class="title">openXmlResourceParser</span><span class="params">(<span class="keyword">int</span> cookie, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Stub!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> String[] getLocales();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，启动插件里的 Activity 的两大问题都有解决的方案了。</p><h2 id="代理模式的具体项目-dynamic-load-apk"><a href="#代理模式的具体项目-dynamic-load-apk" class="headerlink" title="代理模式的具体项目 dynamic-load-apk"></a>代理模式的具体项目 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="noopener">dynamic-load-apk</a></h2><p>上面只是分析了代理模式的关键技术点，如果运用到具体项目中去的话，除了两个关键的问题外，还有许多繁琐的细节需要处理，我们需要设计一个框架，规范插件 APK 项目的开发，也方便以后功能的扩展。<br>这里，<strong>dynamic-load-apk</strong> 向我们展示了许多优秀的处理方法，比如：</p><ol><li>把 Activity 关键的生命周期方法抽象成 DLPlugin 接口，ProxyActivity 通过 DLPlugin 代理调用插件 Activity 的生命周期；</li><li>设计一个基础的 BasePluginActivity 类，插件项目里使用这些基类进行开发，可以以接近常规 Android 开发的方式开发插件项目；</li><li>以类似的方式处理 Service 的问题；</li><li>处理了大量常见的兼容性问题（比如使用 Theme 资源时出现的问题）；</li><li>处理了插件项目里的 so 库的加载问题；</li><li>使用 PluginPackage 管理插件 APK，从而可以方便地管理多个插件项目；</li></ol><h3 id="处理插件项目里的-so-库的加载"><a href="#处理插件项目里的-so-库的加载" class="headerlink" title="处理插件项目里的 so 库的加载"></a>处理插件项目里的 so 库的加载</h3><p>这里需要把插件 APK 里面的 SO 库文件解压释放出来，在根据当前设备 CPU 的型号选择对应的 SO 库，并使用 System.load 方法加载到当前内存中来，具体分析请参考 <a href="https://zhuanlan.zhihu.com/p/21303038" target="_blank" rel="noopener">Android 动态加载补充 加载 SD 卡的 SO 库</a>。</p><h3 id="多插件-APK-的管理"><a href="#多插件-APK-的管理" class="headerlink" title="多插件 APK 的管理"></a>多插件 APK 的管理</h3><p>动态加载一个插件 APK 需要三个对应的 <code>DexClassLoader</code>、<code>AssetManager</code>、<code>Resources</code> 实例，可以用组合的方式创建一个 <code>PluginPackage</code> 类存放这三个变量，再创建一个管理类 <code>PluginManager</code>，用成员变量 <code>HashMap&lt;dexPath,pluginPackage&gt;</code> 的方式保存 <code>PluginPackage</code> 实例。<br>具体的代码请参考原项目的文档、源码以及 Sample 里面的示例代码，在这里感谢 <a href="https://github.com/singwhatiwanna" target="_blank" rel="noopener">singwhatiwanna</a> 的开源精神。</p><h2 id="实际应用中可能要处理的问题"><a href="#实际应用中可能要处理的问题" class="headerlink" title="实际应用中可能要处理的问题"></a>实际应用中可能要处理的问题</h2><h3 id="1-插件-APK-的管理后台"><a href="#1-插件-APK-的管理后台" class="headerlink" title="1. 插件 APK 的管理后台"></a>1. 插件 APK 的管理后台</h3><p>使用动态加载的目的，就是希望可以绕过 APK 的安装过程升级应用的功能，如果插件 APK 是打包在主项目内部的那动态加载纯粹是多次一举。更多的时候我们希望可以在线下载插件 APK，并且在插件 APK 有新版本的时候，主项目要从服务器下载最新的插件替换本地已经存在的旧插件。为此，我们应该有一个管理后台，它大概有以下功能：</p><ol><li>上传不同版本的插件 APK，并向 APP 主项目提供插件 APK 信息查询功能和下载功能；</li><li>管理在线的插件 APK，并能向不同版本号的 APP 主项目提供最合适的插件 APK；</li><li>万一最新的插件 APK 出现紧急 BUG，要提供旧版本回滚吊销功能；</li><li>如果旧版本的插件在有严重 BUG，则需要平台提供强制升级功能；</li><li>出于安全考虑应该对 APP 项目的请求信息做一些安全性校验；</li></ol><h3 id="2-插件-APK-合法性校验"><a href="#2-插件-APK-合法性校验" class="headerlink" title="2. 插件 APK 合法性校验"></a>2. 插件 APK 合法性校验</h3><p>加载外部的可执行代码，一个逃不开的问题就是要确保外部代码的安全性，我们可不希望加载一些来历不明的插件 APK，因为这些插件有的时候能访问主项目的关键数据。<br>最简单可靠的做法就是校验插件 APK 的 MD5 值，如果插件 APK 的 MD5 与我们服务器预置的数值不同，就认为插件被改动过，弃用。当然最好是方式是校验插件 APK 的签名，因为插件是 APK 文件，本身就带有签名信息，如果插件被修改过，签名信息就会变动，我觉得这是检验插件合法性最好的办法。</p><h2 id="是热部署，还是插件化？"><a href="#是热部署，还是插件化？" class="headerlink" title="是热部署，还是插件化？"></a>是热部署，还是插件化？</h2><p>这一部分作为补充说明，如果不太熟悉动态加载的使用姿势，可能不是那么容易理解。<br>谈到动态加载的时候我们经常说到 “热部署” 和 “插件化” 这些名词，它们虽然都和动态加载有关，但是还是有一点区别，这个问题涉及到主项目与插件项目的 ** 交互方式 **。前面我们说到，动态加载方式，可以在 “项目层级” 做到代码分离，按道理我们希望是主项目和插件项目不要有任何交互行为，实际上也应该如此！这样做不仅能确保项目的安全性，也能简化开发工作，所以一般的做法是：</p><h3 id="1-只有在用户使用到的时候才加载插件"><a href="#1-只有在用户使用到的时候才加载插件" class="headerlink" title="1. 只有在用户使用到的时候才加载插件"></a>1. 只有在用户使用到的时候才加载插件</h3><p>主项目还是像常规 Android 项目那样开发，只有用户使用插件 APK 的功能时才动态加载插件并运行，插件一旦运行后，与主项目没有任何交互逻辑，只有在主项目启动插件的时候才触发一次调用插件的行为。比如，我们的主项目里有几款推广的游戏，平时在用户使用主项目的功能时，可以先静默把游戏（其实就是一个插件 APK）下载好，当用户点击游戏入口时，以动态加载的方式启动游戏，游戏只运行插件 APK 里的代码逻辑，结束后返回主项目界面。</p><h3 id="2-一启动主项目就加载插件"><a href="#2-一启动主项目就加载插件" class="headerlink" title="2. 一启动主项目就加载插件"></a>2. 一启动主项目就加载插件</h3><p>另外一种完全相反的情形是，主项目只提供一个启动的入口，以及从服务器下载最新插件的更新逻辑，这两部分的代码都是长期保持不变的，应用一启动就动态加载插件，所有业务逻辑的代码都在插件里实现。比如现在一些游戏市场都要求开发者接入其 SDK 项目，如果 SDK 项目采用这种开发方式，先提供一个空壳的 SDK 给开发者，空壳 SDK 能从服务器下载最新的插件再运行插件里的逻辑，就能保证开发者开发的游戏每次启动的时候都能运行最新的代码逻辑，而不用让开发者在 SDK 有新版本的时候重新更换 SDK 并构建新的游戏 APK。</p><h3 id="3-让插件使用主项目的功能"><a href="#3-让插件使用主项目的功能" class="headerlink" title="3. 让插件使用主项目的功能"></a>3. 让插件使用主项目的功能</h3><p>有些时候，比如，主项目里有一个成熟的图片加载框架 ImageLoader，而插件里也有一个 ImageLoader。如果一个应用同时运行两套 ImageLoader，那会有许多额外的性能开销，如果能让插件也用主项目的 ImageLoader 就好了。另外，如果在插件里需要用到用户登录功能，我们总不希望用户使用主项目时进行一次登录，进入插件时由来一次登录，如果能在插件里使用主项目的登录状态就好了。<br>因此，有些时候我们希望插件项目能调用主项目的功能。怎么处理好呢，由于插件项目与主项目是分开的，我们在开发插件的时候，怎么调用主项目的代码啊？这里需要稍微了解一下 Android 项目间的依赖方式。</p><p>想想一个普通的 APK 是怎么构建和运行的，Android SDK 提供了许多系统类（如 Activity、Fragment 等，一般我们也喜欢在这里查看源码），我们的 Android 项目依赖 Android SDK 项目并使用这些类进行开发，那构建 APK 的时候会把这些类打包进来吗？不会，要是每个 APK 都打包一份，那得有多少冗余啊。所以 Android 项目至少有两种依赖的方式，一种构建时会把被依赖的项目（Library）的类打包进来，一种不会。</p><p>在 Android Studio 打开项目的 Project Structure，找到具体 Module 的 Dependencies 选项卡。</p><p><img src="/assets/a20b2dc8_5144_4987_a46b_55b20b792f90_untitled.png" alt=""></p><p>可以看到 Library 项目有个 Scope 属性，这里的 Compile 模式就是会把 Library 的类打包进来，而 Provided 模式就不会。</p><p>注意，使用 Provided 模式的 Library 只能是 jar 文件，而不能是一个 Android Library 模块（如 appcompat-v7），因为 Provided 模式只需要依赖 Library 的 API，Android Library 模块可能自带了一些 res 资源，这些资源无法一并塞进标准的 jar 文件里面。到这里我们明白，Android SDK 的代码其实是打包进系统 ROM（俗称 Framework 层级）里面的，我们开发 Android 项目的时候，只是以 Provided 模式引用 android.jar，从这个角度也佐证了上面谈到的 “为什么 APP 实际运行时 AssetManager 类的逻辑会与 Android SDK 里的源码不一样”。</p><p>现在好办了，如果要在插件里使用主项目的 ImageLoader，我们可以把 ImageLoader 的相关代码抽离成一个 Android Libary 项目，主项目以 Compile 模式引用这个 Libary，而插件项目以 Provided 模式引用这个 Library（编译出来的 jar），这样能实现两者之间的交互了，当然代价也是明显的。</p><ol><li>我们应该只给插件开放一些必要的接口，不然会有安全性问题；</li><li>作为通用模块的 Library 应该保持不变（起码接口不变），不然主项目与插件项目的版本同步会复杂许多；</li><li>因为插件项目已经严重依赖主项目了，所以插件项目不能独立运行，因为缺少必要的 ** 环境 **；</li></ol><p>最后我们再说说 “热部署” 和 “插件化” 的区别，一般我们把独立运行的插件 APK 叫热部署，而需要依赖主项目的环境运行的插件 APK 叫做插件化。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 代理 Activity 模式Date = 2016-06-10 00:00:00Published = trueCategory = AndroidTag = ['Android', '动态化']FileLocate = FileName = android-dynamical-loading-06-proxy-activityhexo.comments = truehexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单模式中，使用 ClassLoader 加载外部的 Dex 或 Apk 文件，可以加载一些本地 APP 不存在的类（或者更新本地已存在的类），从而执行一些新的代码逻辑，但是使用这种方法却不能直接启动插件里的 Activity 等组件，也没办法使用 res 资源，如果不解决这两个问题，则使用插件化的方式开发 Android 业务会非常繁琐。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://kaedea.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://kaedea.com/tags/Android/"/>
    
      <category term="动态化" scheme="http://kaedea.com/tags/%E5%8A%A8%E6%80%81%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>魔都漫展 ComicCup18 Day1</title>
    <link href="http://kaedea.com/2016/06/09/living-cp18-video/"/>
    <id>http://kaedea.com/2016/06/09/living-cp18-video/</id>
    <published>2016-06-09T00:00:00.000Z</published>
    <updated>2021-08-25T12:01:00.857Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=4982268&bvid=BV19s411e7R2&cid=8092576&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>转眼间来 B 站工作已经有 2 个月了，这是第一天粗来玩，9 号一个人逛 CP18，找基友章鱼的摊位，被安利了一张 CD，现场许多萌妹子，发了不少牢骚（求个妹纸一起吃自助餐、看电影、逛漫展）。</p><!-- Generated by HexoWriternotion-down.version = 0.1.0notion-down.revision = b'349007a'Title = 魔都漫展 ComicCup18 Day1Date = 2016-06-09 00:00:00Published = trueCategory = LifeTag = ['CP18', '漫展']FileLocate = FileName = living-cp18-videohexo.comments = truehexo.link = http://www.bilibili.com/video/av4982268/hexo.metaAlignment = center-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=4982268&amp;bvid=BV19s411e7R2&amp;cid=8092576&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; 
      
    
    </summary>
    
    
      <category term="Life" scheme="http://kaedea.com/categories/Life/"/>
    
    
      <category term="CP18" scheme="http://kaedea.com/tags/CP18/"/>
    
      <category term="漫展" scheme="http://kaedea.com/tags/%E6%BC%AB%E5%B1%95/"/>
    
  </entry>
  
</feed>
