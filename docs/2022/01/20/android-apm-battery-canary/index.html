<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Matrix BatteryCanary 电量优化框架 | Kaede Akatsuki | 中二病也要开发 Android</title>

  
  <meta name="author" content="Kaede Akatsuki">
  

  
  <meta name="description" content="A TASTE OF ACG (Anime/Coding/Games).">
  

  
  
  <meta name="keywords" content="Android,APM,电量优化,BatteryCanary">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Matrix BatteryCanary 电量优化框架">

  <meta property="og:site_name" content="Kaede Akatsuki">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Kaede Akatsuki" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <link href="https://fonts.lug.ustc.edu.cn/css?family=Lato|Rubik" rel="stylesheet">
  <script src="/js/pangu-407.min.js"></script>
</head>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    pangu.autoSpacingPage();
  });
</script>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Kaede Akatsuki</a>
    </h1>
    <p class="site-description">中二病也要开发 Android</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Matrix BatteryCanary 电量优化框架</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2022/01/20/android-apm-battery-canary/" rel="bookmark">
        <time class="entry-date published" datetime="2022-01-20T00:00:00.000Z">
          2022-01-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        

<script type="text/javascript">
    function convertRemToPixels(rem) {    
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }
    window.onscroll = function() {
        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
        if (scrollTop > convertRemToPixels(40)) {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'visible';
        } else {
            document.getElementsByClassName('toc-article')[0].style.visibility = 'hidden';
        }
    }
</script>


<div id="toc" class="toc-article">
      <div class="toc-content">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Matrix-BatteryCanary"><span class="toc-text">Matrix BatteryCanary</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开始-amp-结束监控"><span class="toc-text">开始 &amp; 结束监控</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用场景"><span class="toc-text">使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检测线程功耗异常"><span class="toc-text">检测线程功耗异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-amp-Native-线程"><span class="toc-text">Java &amp; Native 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#野线程-“Thread-xxx”-治理"><span class="toc-text">野线程 “Thread-xxx” 治理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程堆栈采集"><span class="toc-text">线程堆栈采集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检测系统服务调用异常"><span class="toc-text">检测系统服务调用异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SystemService-Hook"><span class="toc-text">SystemService Hook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASM"><span class="toc-text">ASM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断-App-状态-amp-设备状态"><span class="toc-text">判断 App 状态 &amp; 设备状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应用状态-AppStat"><span class="toc-text">应用状态 AppStat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设备状态-DevStat"><span class="toc-text">设备状态 DevStat</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#监听电量相关事件"><span class="toc-text">监听电量相关事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提炼电量优化规则"><span class="toc-text">提炼电量优化规则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他使用姿势"><span class="toc-text">其他使用姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-Load"><span class="toc-text">CPU Load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CpuFreq-采样"><span class="toc-text">CpuFreq 采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#电池温度采样"><span class="toc-text">电池温度采样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppStats"><span class="toc-text">AppStats</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#电量统计报告"><span class="toc-text">电量统计报告</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Battery-Dumper-amp-Printer"><span class="toc-text">Battery Dumper &amp; Printer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Battery-Stats"><span class="toc-text">Battery Stats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#电量事件"><span class="toc-text">电量事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#电量报告"><span class="toc-text">电量报告</span></a></li></ol></li></ol></li></ol>
      </div>
</div>
<style>
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>



        <!-- changelog
2022-03-08
Add:

1. 组合器使用

2022-01-20
初稿
-->
<!-- draft
大纲

1. 接入
1. 使用场景
1. 线程耗电
1. 系统服务调用
1. 易用性支持
    1. CpuLoad
1. 采样
1. 电量统计报告

-->
<p>好了，经过上一篇文章《<a href="https://kaedea.com/2021/08/14/android-apm-battery-stats-opt/">Android App 电量统计原理与优化</a>》的分析，相信你已经完全掌握了 Android App 电量的计算方式，现在可以开始给自己的 App 开发电量异常检测功能了。如果觉得麻烦的话可以先尝试一下我们的开源方案：Matrix 已经实现了类似的功能 —— BatteryCanary，并且在我们的项目上全量稳定运行了一年多，帮我们发现了不少新增 &amp; 隐藏多年的电量问题。</p>
<a id="more"></a>
<h1 id="Matrix-BatteryCanary"><a href="#Matrix-BatteryCanary" class="headerlink" title="Matrix BatteryCanary"></a>Matrix BatteryCanary</h1><p>跟其他 APM 指标优化框架一样，电量优化框架 BatteryCanary 也是作为一个相对独立的 Plugin 功能集成在 Matrix 框架里面。不过电量相关的问题比较复杂，一般来说，比较 “客观” 的异常检测（比如 Crash 或者 ANR），都能做到 “开箱即用”（out-of-box）；而像卡顿反馈（没有 ANR 弹窗但用户感觉卡顿）这类比较 “主观” 的异常检测，就需要做一些额外的自定义配置了。<br>电量异常的判断标准则要比卡顿问题 “主观更多”，而且导致耗电的原因更是多种多样，比如线程问题、WakeLock 问题、Wifi / 蓝牙 / GPS 扫描频繁问题等等。相应的 BatteryCanary 也开发了许多针对以上种种问题的功能模块，从而导致 BatteryCanary 的设计相比其他 APM 框架繁琐了不少，使用前需要根据自己 App 需要指定启用哪些模块以及相应的自定义配置。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>如果你只想使用 BatteryCanary 的核心功能，那么只需要执行一下简单的初始化即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BatteryMonitorPlugin <span class="title">createMonitor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BatteryMonitorPlugin(<span class="keyword">new</span> BatteryMonitorConfig.Builder()</span><br><span class="line">            <span class="comment">// 线程 CPU 功耗监控</span></span><br><span class="line">            .enable(JiffiesMonitorFeature<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">build</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你对 BatteryCanary 的全部功能感兴趣，那么你可以尝试使用以下复杂的初始化配置，并自己尝试折腾一下每个功能的自定义参数配置（一般情况下使用默认配置即可）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BatteryMonitorPlugin <span class="title">createMonitor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Init MMKV only when BatteryStatsFeature is &amp; MMKVRecorder is enabled.</span></span><br><span class="line">    MMKV.initialize(context);</span><br><span class="line">    MMKV mmkv = MMKV.mmkvWithID(<span class="string">"battery-stats.bin"</span>, MMKV.MULTI_PROCESS_MODE);</span><br><span class="line">    registerUIStat((Application) context.getApplicationContext());</span><br><span class="line"></span><br><span class="line">    BatteryMonitorConfig batteryConfig = <span class="keyword">new</span> BatteryMonitorConfig.Builder()</span><br><span class="line">            <span class="comment">// Thread Activities Monitor</span></span><br><span class="line">            .enable(JiffiesMonitorFeature<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enableStatPidProc</span>(<span class="title">true</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">greyJiffiesTime</span>(3 * 1000<span class="title">L</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enableBackgroundMode</span>(<span class="title">false</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">backgroundLoopCheckTime</span>(30 * 60 * 1000<span class="title">L</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enableForegroundMode</span>(<span class="title">true</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">foregroundLoopCheckTime</span>(20 * 60 * 1000<span class="title">L</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">setBgThreadWatchingLimit</span>(5000)</span></span><br><span class="line"><span class="class">            .<span class="title">setBgThreadWatchingLimit</span>(8000)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">            // <span class="title">CPU</span> <span class="title">Stats</span></span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">CpuStatFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">            // <span class="title">App</span> &amp; <span class="title">Device</span> <span class="title">Status</span> <span class="title">Monitor</span> <span class="title">For</span> <span class="title">Better</span> <span class="title">Invalid</span> <span class="title">Battery</span> <span class="title">Activities</span> <span class="title">Configure</span></span></span><br><span class="line"><span class="class">            .<span class="title">setOverHeatCount</span>(1024)</span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">DeviceStatMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">AppStatMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">setSceneSupplier</span>(<span class="title">new</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Current AppScene"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// AMS Activities Monitor:</span></span><br><span class="line">            <span class="comment">// alarm/wakelock watch</span></span><br><span class="line">            .enableAmsHook(<span class="keyword">true</span>)</span><br><span class="line">            .enable(AlarmMonitorFeature<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">WakeLockMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">wakelockTimeout</span>(2 * 60 * 1000<span class="title">L</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">wakelockWarnCount</span>(3)</span></span><br><span class="line">            .addWakeLockWhiteList("Ignore WakeLock TAG1")</span><br><span class="line">            .addWakeLockWhiteList(<span class="string">"Ignore WakeLock TAG2"</span>)</span><br><span class="line">            <span class="comment">// scanning watch (wifi/gps/bluetooth)</span></span><br><span class="line">            .enable(WifiMonitorFeature<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">LocationMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">BlueToothMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            // .<span class="title">enable</span>(<span class="title">NotificationMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">            // <span class="title">BatteryStats</span></span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">BatteryStatsFeature</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">setRecorder</span>(<span class="title">new</span> <span class="title">BatteryRecorder</span>.<span class="title">MMKVRecorder</span>(<span class="title">mmkv</span>))</span></span><br><span class="line"><span class="class">            .<span class="title">setStats</span>(<span class="title">new</span> <span class="title">BatteryStats</span>.<span class="title">BatteryStatsImpl</span>())</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">            // Lab Feature:</span><br><span class="line">            <span class="comment">// network monitor</span></span><br><span class="line">            <span class="comment">// looper task monitor</span></span><br><span class="line">            .enable(TrafficMonitorFeature<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">LooperTaskMonitorFeature</span>.<span class="title">class</span>)</span></span><br><span class="line">            .addLooperWatchList("main")</span><br><span class="line">            .useThreadClock(<span class="keyword">false</span>)</span><br><span class="line">            .enableAggressive(<span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Monitor Callback</span></span><br><span class="line">            .setCallback(<span class="keyword">new</span> BatteryStatsListener())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BatteryMonitorPlugin(batteryConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="开始-amp-结束监控"><a href="#开始-amp-结束监控" class="headerlink" title="开始 &amp; 结束监控"></a>开始 &amp; 结束监控</h2><p>Crash / ANR 等常见的异常，可以通过捕获系统、App 相关的异常信号或者监听回调来判断异常是否发生，而相比之下耗电异常的检测就要麻烦许多。前者一般是瞬时的状态，在异常发生的时候捕获一下异常并 Dump 出异常现场信息（StackTrace、前后台等信息）后就能比较有效地分析和修复问题；后者则是一段时间内发生的事情，比如 App 使用十几分钟后发现这段时间内耗电比较严重…… <strong> 所以检测 App 电量异常，实际上就是监控 App 某一段时间内（结束时间的电量数据 - 起始时间的电量数据）电量的统计数据有没有出现问题。</strong></p>
<p>为了方便计算统计数据 Diff，BatteryCanary 使用一个组合器（CompositeMonitors）来存放每一个电量监控模块（Monitor）的统计数据，封装了比较繁琐的数据 Diff 的计算代码，使用的时候只需要在开始监控的地方调用一下 <code>CompositeMonitors#start ()</code>  并在结束的地方调用一下 <code>CompositeMonitors#finish ()</code> ，即可获得这段时间内的电量统计信息，然后可以根据自身 App 的指标需要，判断出哪些电量监控模块出否出现异常。</p>
<p>例如，你可以通过单独使用每一个启用的监控模块（Monitor），也可以使用组合器来一次性启用多个模块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建组合器</span></span><br><span class="line">CompositeMonitors compositor = <span class="keyword">new</span> CompositeMonitors(core);</span><br><span class="line">CompositeMonitors compositor = existingCompositor.fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 启用线程 Jiffies 监控模块</span></span><br><span class="line">compositor.metric(JiffiesSnapshot<span class="class">.<span class="keyword">class</span>)；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 3. 启用 <span class="title">Jiffies</span> 监控模块 &amp; <span class="title">CPU</span> 监控模块</span></span><br><span class="line"><span class="class"><span class="title">compositor</span></span></span><br><span class="line"><span class="class">    .<span class="title">metric</span>(<span class="title">JiffiesSnapshot</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">metric</span>(<span class="title">CpuStateSnapshot</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 启用所有监控模块</span></span><br><span class="line">compositor.metricAll();</span><br></pre></td></tr></table></figure>
<p>这里需要特别强调的是，正因为耗电检测是一个过程，所以每一个过程（或者说是使用场景）对应的时间窗口是可能出现重叠的。我们可以根据徐存，给每一个使用场景创建一个不同的 CompositeMonitors 来监控（不同场景通过 Scope 来区分）。</p>
<p>例如，以下代码实现了 App 不同使用场景下的电量监控：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 后台电量监控</span></span><br><span class="line">CompositeMonitors compositor = <span class="keyword">new</span> CompositeMonitors(core, <span class="string">"scope_bg"</span>);</span><br><span class="line"><span class="comment">// App 进入后台</span></span><br><span class="line">compositor.start();</span><br><span class="line"><span class="comment">// App 进入前台</span></span><br><span class="line">compositor.finish();</span><br><span class="line"><span class="comment">// 获取线程功耗统计数据</span></span><br><span class="line">Delta&lt;JiffiesSnapshot&gt; appJiffies = compositor.getDelta(JiffiesSnapshot<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 获取功耗 TOP1 的线程信息</span></span><br><span class="line">ThreadJiffiesEntry threadJiffies = appJiffies.dlt.threadEntries.getList().get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 针对某 Activity 的电量监控</span></span><br><span class="line">CompositeMonitors compositor = <span class="keyword">new</span> CompositeMonitors(core, <span class="string">"scope_activity_xxx"</span>);</span><br><span class="line"><span class="comment">// 进入 Activity#onActivityStarted</span></span><br><span class="line">compositor.start();</span><br><span class="line"><span class="comment">// 退出 Activity#onActivityFinished</span></span><br><span class="line">compositor.finish();</span><br><span class="line"><span class="comment">// 获取电量统计数据 ...</span></span><br></pre></td></tr></table></figure>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>目前我们的项目主要使用 BatteryCanary 来检测是否出现线程功耗异常和系统服务调用异常（不符合隐私合规，或者频繁调用）。</p>
<h2 id="检测线程功耗异常"><a href="#检测线程功耗异常" class="headerlink" title="检测线程功耗异常"></a>检测线程功耗异常</h2><p>线程的监控模块主要可以分为一般线程（Java + Native）和线程池线程（Executor + HandlerThread + 其他用来执行多种 Runnable 的线程）。上一篇文章我们提到，一般线程我们可以用线程名来聚合问题，而线程池则需要使用 Runnable 名来聚合问题。</p>
<p>首先记得在 BatteryCanary 初始化的时候开启线程 &amp; 线程池的监控功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BatteryMonitorConfig batteryConfig = <span class="keyword">new</span> BatteryMonitorConfig.Builder()</span><br><span class="line">            .enable(JiffiesMonitorFeature<span class="class">.<span class="keyword">class</span>)     // <span class="title">All</span> <span class="title">threads</span></span></span><br><span class="line"><span class="class">            .<span class="title">enable</span>(<span class="title">YourAbsTaskMonitorFeature</span>.<span class="title">class</span>) // <span class="title">ThreadPool</span>-<span class="title">styled</span> <span class="title">threads</span></span></span><br><span class="line"><span class="class">            .<span class="title">build</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以开始愉快地玩耍了。</p>
<h3 id="Java-amp-Native-线程"><a href="#Java-amp-Native-线程" class="headerlink" title="Java &amp; Native 线程"></a>Java &amp; Native 线程</h3><p>判断一个线程功耗是否出现异常需要先了解一下 Linux Jiffy 的概念，忘了的同学可以先复习一下上节课的内容：<a href="https://kaedea.com/2021/08/14/android-apm-battery-stats-opt/# 线程监控">线程监控</a>。我们通过线程的 Jiffiy 消耗以及线程的运行状态，就可以推断出当前线程在这段时间内有没有异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Delta&lt;JiffiesSnapshot&gt; delta = compositor.getDelta(JiffiesSnapshot<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (delta != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> windowMillis = delta.during;     <span class="comment">// 时间窗口</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadJiffiesEntry threadEntry : delta.dlt.threadEntries.getList()) &#123;</span><br><span class="line">        String name = threadEntry.name;   <span class="comment">// 线程名</span></span><br><span class="line">        <span class="keyword">int</span> tid = threadEntry.tid;        <span class="comment">// tid</span></span><br><span class="line">        String status = threadEntry.stat; <span class="comment">// 线程状态</span></span><br><span class="line">        <span class="keyword">long</span> jiffies = threadEntry.get(); <span class="comment">// 线程在这段时间内的 Jiffy</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，当线程的 Jiffy 开销约等于 6000 jiffies / 分钟的时候，就说线程在这段时间内一直在吃 CPU 资源（CPU 中断），换算下来线程的 CPU Load 约为 100%（App 的 CPU Load 为所有线程的 CPU Load 累加，具体值的区间在 [0, 100 × CPU Core Num]）。当 App 在后台的时候，线程持续这种状态超过 10 分钟以上，就说明已经出现待机功耗异常；当时间超过 30min 甚至 1 hour 以上，就可以在系统电量统计排行上面看到明显的电量曲线的变化。</p>
<p>以上线程异常的规则定义可以根据自身 App 需要灵活定义，不过我们实践发现，如果长时间的后台线程 Jiffies 推算出来的 CPU Load 一直在 100% ，并且该线程没有明显的 Log 输入，则说明当前线程很可能出现了 <strong> 死循环 </strong>（一般是 Bug 导致，而且陈年老代码里更容易出现）；而如果有大量相关的 Log 输出，则说明该线程相关的业务功能在 App 进入待机状态后，可能漏了执行相应的退出和析构逻辑（一般在新开发而没经过测试 &amp; 先上考验的新代码里容易出现）。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池的 Jiffy 开销异常于普通线程的统计方式不太一样，需要把线程池整体的 Jiffy 消耗分摊到每个 Runnable 上面，而且考虑到同一个 Runable 会反复被执行，还需要把相同 Runnable 的 Jiffy 累计起来。</p>
<p>因为每个 App 项目自身的 ThreadPool 库大相径庭，所以 BatteryCanary 并没有直接集成具体的线程池监控模块，而是提供一个基类（AbsTaskMonitorFeature），具体项目需要根据自身实际情况做一下扩展。以下是一个简单的线程池监控拓展样例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolJiffiesMonitor</span> <span class="keyword">extends</span> <span class="title">AbsTaskMonitorFeature</span> </span>&#123;</span><br><span class="line">    ExecutorService yourExecutor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        onTaskStarted(runnable.getClass().getName(), runnable.hashCode());</span><br><span class="line">        yourExecutor.execute(runnable);</span><br><span class="line">        onTaskFinished(runnable.getClass().getName(), runnable.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通线程的异常定义类似，线程池只需要计算每一个 Runnable 的 CPU Load 就能检测出该 Runnable 有没有出现功耗异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取当前线程池所有 Runnable 的 CPU 功耗</span></span><br><span class="line">ThreadPoolJiffiesMonitor feat = BatteryCanary.getMonitorFeature(ThreadPoolJiffiesMonitor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List&lt;Delta&lt;TaskJiffiesSnapshot&gt;&gt; taskDeltas = feat.currentJiffies();</span><br><span class="line"><span class="keyword">for</span> (Delta&lt;TaskJiffiesSnapshot&gt; delta : taskDeltas) &#123;</span><br><span class="line">    <span class="keyword">long</span> windowsMillis = delta.dlt.timeMillis; <span class="comment">// Runnable 执行的时间窗口</span></span><br><span class="line">    String taskName = delta.dlt.name;          <span class="comment">// Runnable 名字</span></span><br><span class="line">    <span class="keyword">long</span> jiffies = delta.dlt.jiffies.get();    <span class="comment">// Runnable 消耗的 Jiify</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取过去一段时间窗口内，当前线程池某个线程的 CPU 功耗分布（Runnable 名字聚合）</span></span><br><span class="line"><span class="keyword">int</span> tid = xxx;         <span class="comment">// 线程池线程 tid</span></span><br><span class="line"><span class="keyword">long</span> deltaJiffy = xxx; <span class="comment">// 线程池线程在这段时间内的 Jiffy 开销</span></span><br><span class="line"><span class="keyword">long</span> currJiffy = xxx;  <span class="comment">// 线程池线程当前累计的 Jitty 开销</span></span><br><span class="line">TimePortions taskPortions = feat.getTaskPortions(tid, deltaJiffy, currJiffy);</span><br><span class="line">Portion top = taskPortions.top1();</span><br><span class="line">String taskName = top.key; <span class="comment">// 功耗 top1 Runnable</span></span><br><span class="line"><span class="keyword">float</span> ratio = top.ratio;   <span class="comment">// 功耗 top1 Runnable Jiffy 开销与线程池线程所有开销的占比</span></span><br></pre></td></tr></table></figure>
<h3 id="野线程-“Thread-xxx”-治理"><a href="#野线程-“Thread-xxx”-治理" class="headerlink" title="野线程 “Thread-xxx” 治理"></a>野线程 “Thread-xxx” 治理</h3><p>一般的线程问题，可以直接通过线程名看出具体是 App 的哪个业务模块出现问题了（复杂点的需要配合线程 StackTrace 来聚合问题）。在这种情形下，“野线程”（没有设置名字的线程）的问题就比较难处理了。</p>
<p>尽管在代码规范上，我们一直强调不要随意 <code>new Thread ()</code> 以及创建新线程一定要设置强业务相关的线程名，不过我们在治理线程功耗上面还是经常能看到一些新增的 “Thread-xxx”，经过仔细排查之后我们有了意外的收获：</p>
<blockquote>
<p>Native 线程回调 Java 代码会导致线程名被重置成 Thread-xxx！</p>
</blockquote>
<p>主要原因是 Native Call Java 的时候，需要先执行一下 AttachCurrentThread，这个调用如果没有显示指定当前线程名的话，就会导致线程名被重置。具体源码可以参考 <a href="https://cs.android.com/android/platform/superproject/+/master:art/runtime/thread.cc;l=1139;drc=master?q=CreatePeer" target="_blank" rel="noopener">thread.cc</a>，其调用链如下：</p>
<figure class="highlight plain"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM-&gt;AttachCurrentThread(&amp;env, nullptr);</span><br><span class="line">    - Thread-&gt;Attach</span><br><span class="line">        - Thread-&gt;CreatePeer</span><br><span class="line">            - Thread-&gt;GetThreadName -&gt; java_lang_Thread_name // 这里因为传入进来的线程名为 null, NDK 会尝试读取 java_lang_Thread_name 作为新的线程名 </span><br><span class="line">            - Thread-&gt;SetThreadName</span><br></pre></td></tr></table></figure>
<p>解决方案也非常简单，记得指定线程名或者使用另一个相同功能的 API：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JavaVMAttachArgs args;</span><br><span class="line">args.name = <span class="string">"native_thread_name"</span>;</span><br><span class="line">JVM-&gt;AttachCurrentThread(&amp;env, &amp;args);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">AttachCurrentThreadWithName();</span><br></pre></td></tr></table></figure>
<h3 id="线程堆栈采集"><a href="#线程堆栈采集" class="headerlink" title="线程堆栈采集"></a>线程堆栈采集</h3><p>通过以上手段可以有效地检测 App 哪些线程出现了异常，而在具体生产项目的应用上，检测哪些线程出现异常往往还不够（只有线程名、Jiffy &amp; CPU Load），更重要的是要检测线程在哪些代码上出现了异常，这里就需要想办法采集到 Android 的线程堆栈信息（包括 native + Java）。</p>
<p>实际上，除了线程名 &amp; Runnable 之外，线程堆栈也是分析和聚合耗电问题的一项关键的数据。不过线程堆栈采集（StackTrace Collect）主要用到的 unwind 技术是一个比较成熟的课题，包括电量优化在内的大部分 APM 优化项目都或多或少需要用到该技术，这里就不做过多展开。简单说一下我们方案大致的思路：通过 <a href="https://cs.android.com/android/platform/superproject/+/master:system/unwinding/libunwindstack/Unwinder.cpp;drc=master;l=124" target="_blank" rel="noopener">libunwindstack</a> 来采集指定 tid 线程的 native 堆栈 &amp; 通过 tgkill 来获取指定 Java 线程的 Thread 引用从而获取 Java 堆栈（具体应用上，我们跟倾向于优先采集 Java 线程堆栈，因为 native 堆栈的干扰数据太多，不太容易聚合问题）。</p>
<h2 id="检测系统服务调用异常"><a href="#检测系统服务调用异常" class="headerlink" title="检测系统服务调用异常"></a>检测系统服务调用异常</h2><p>电量优化另一个比较重要的场景是跟系统服务调用相关的，主要包括 WakeLock/Alarm 的请求，以及 Wifi/BlueTooth/GPS 等需要执行硬件扫描的功能的调用。</p>
<p>一方面，以上服务都是 Android 系统电量统计中权重占比比较高的模块，而且 <a href="https://developer.android.com/topic/performance/vitals" target="_blank" rel="noopener">Google Android Vitals</a> 里功耗相关的适配指导也比较注重这几个模块的内容。另一方面，除了 Vitals 里定义的异常指标之外，<strong> 国产手机的 OEM 系统也针对性地加入了针对以上模块使用情况的合规 &amp; 功耗异常告警 </strong>，这些告警给我们项目增加了许多 App 耗电异常的用户反馈，因此我们也非常重视相关系统服务调用的使用情况。</p>
<p>考虑到稳定性问题，BatteryCanary 主要通过 Hook 以及 ASM 两种方案来实现 App 系统服务调用的监控：Hook 方案接入简单但是在新系统以及个别设备上稳定性较差，比较适合采样监控；ASM 方案兼容性好适合现网全量启用，但是需要配合 ASM 插桩框架使用（每个项目使用的插桩框架不同，为了避免插桩冲突 Matrix 并没有提供内建的插桩功能），而且无法覆盖到动态代码（插桩工作主要在编译环节执行）。</p>
<h3 id="SystemService-Hook"><a href="#SystemService-Hook" class="headerlink" title="SystemService Hook"></a>SystemService Hook</h3><p>Hook 方案的接入方式最简单，只需要在初始化 BatteryCanary 的时候启用 AMS Hook 配置即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BatteryMonitorPlugin <span class="title">createMonitor</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BatteryMonitorPlugin(<span class="keyword">new</span> BatteryMonitorConfig.Builder()</span><br><span class="line">            ...</span><br><span class="line">            .enableAmsHook(<span class="keyword">true</span>)</span><br><span class="line">            .build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以下代码可以从 CompositeMonitors 中获取 GPS 定位服务调用的统计信息（其他模块的访问方式类似）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Delta&lt;LocationSnapshot&gt; delta = compositor.getDelta(LocationSnapshot<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (delta != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> scanCount = delta.dlt.scanCount.get(); <span class="comment">// 时间窗口内 GPS 扫描的调用次数</span></span><br><span class="line">    String stack = delta.dlt.stack;            <span class="comment">// 最后一次调用 GPS 扫描服务的代码堆栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><p>为了避免数据重复，ASM 方案和 Hook 方案只能同时启用一个。在关闭 Hook 功能的时候，需要通过 ASM 框架针对相关的系统服务调用进行插桩，并通过以下方式将插桩数据整合到 BatteryCanary 框架内，这里还是以 GPS 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asmOnLocationScan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BatteryCanary.getMonitorFeature(LocationMonitorFeature<span class="class">.<span class="keyword">class</span>, <span class="title">feat</span> -&gt; </span>&#123;</span><br><span class="line">        feat.getTracing().onStartScan();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断-App-状态-amp-设备状态"><a href="#判断-App-状态-amp-设备状态" class="headerlink" title="判断 App 状态 &amp; 设备状态"></a>判断 App 状态 &amp; 设备状态</h2><p>上面提到，耗电异常是指某一段内发生的异常，因此耗电异常时候的 App 和 Device 状态也必须统计的是一段时间内状态，具体讲就是这端事件内状态的切换细节以及每个状态的时间除以整个时间窗口的占比。</p>
<p>这部分状态的统计工作主要是由 AppStatMonitor 和 DeviceStatMonitor 这两个监控模块完成的。其中 AppStatMonitor 负责监控 App 前台、后台、ForegroundService 以及浮窗 4 种状态的变化，而 DeviceStatMonitor 则负责设备充电、未充电、息屏、Doze（低电耗模式）、App Standby（应用待机模式）这 5 种状态的统计。</p>
<h3 id="应用状态-AppStat"><a href="#应用状态-AppStat" class="headerlink" title="应用状态 AppStat"></a>应用状态 AppStat</h3><p>在启用 App 状态监控模块的时候，可以通过一下方式获取 App 状态的统计数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BatteryCanary.getMonitorFeature(AppStatMonitorFeature<span class="class">.<span class="keyword">class</span>, <span class="title">feat</span> -&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> duringMillis = xxx; <span class="comment">// 时间窗口</span></span><br><span class="line">    AppStatMonitorFeature.AppStatSnapshot stats = feat.currentAppStatSnapshot(duringMillis);</span><br><span class="line">    <span class="keyword">long</span> fgRatio = stats.fgRatio.get();       <span class="comment">// 前台时间占比</span></span><br><span class="line">    <span class="keyword">long</span> bgRatio = stats.bgRatio.get();       <span class="comment">// 后台时间占比</span></span><br><span class="line">    <span class="keyword">long</span> fgSrvRatio = stats.fgSrvRatio.get(); <span class="comment">// 前台服务时间占比</span></span><br><span class="line">    <span class="keyword">long</span> floatRatio = stats.floatRatio.get(); <span class="comment">// 浮窗时间占比</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="设备状态-DevStat"><a href="#设备状态-DevStat" class="headerlink" title="设备状态 DevStat"></a>设备状态 DevStat</h3><p>在启用 Device 状态监控模块的时候，可以通过以下方式获取设备状态的统计数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BatteryCanary.getMonitorFeature(DeviceStatMonitorFeature<span class="class">.<span class="keyword">class</span>, <span class="title">feat</span> -&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> duringMillis = xxx; <span class="comment">// 时间窗口</span></span><br><span class="line">    DeviceStatMonitorFeature.DevStatSnapshot stats = feat.currentDevStatSnapshot(duringMillis);</span><br><span class="line">    <span class="keyword">long</span> unChargingRatio = stats.unChargingRatio.get(); <span class="comment">// 未充电状态时间占比</span></span><br><span class="line">    <span class="keyword">long</span> screenOff = stats.screenOff.get();             <span class="comment">// 息屏状态时间占比</span></span><br><span class="line">    <span class="keyword">long</span> lowEnergyRatio = stats.lowEnergyRatio.get();   <span class="comment">// 低电耗状态时间占比</span></span><br><span class="line">    <span class="keyword">long</span> chargingRatio = stats.chargingRatio.get();     <span class="comment">// 充电状态时间占比</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>AppStat 和 DevStat 是耗电异常判断的重要依据，例如：在 App 开启前台服务或者浮窗的情况下，我们运行 App 出现比较高的功耗，同样在设备出于充电状态的情况下我们也可以适当放宽一些待机功耗的限制；相反在 App 处于后台并且设备处于息屏状态的时候，我们应当最大程度收紧待机功耗的阈值，取消 App 的后台任务或者降低相关线程的优先级，让 App 进入 Standby 状态并且让设备能成功进入 Doze 模式。</p>
<p>根据我们对多份耗电异常的 Battery Historian 的排查，<strong> 我们发现设备无法进入 Doze 模式是系统耗电排行中电量曲线出现明显下降的主要原因 </strong>。而导致设备无法进入 Doze  模式的主要原因基本都是 App  的进程优先级一直没有下降（比如有活跃的线程一直在 Running 导致 CPU Load 负载很高）。</p>
<h2 id="监听电量相关事件"><a href="#监听电量相关事件" class="headerlink" title="监听电量相关事件"></a>监听电量相关事件</h2><p>电量相关系统 &amp; App 的事件的监听是电量优化需要用到的基础功能，BatteryCanary 内部实现主要通过 BatteryEventDelegate 这个类来实现相关事件的监听，并且向外提供相应的接口以便上层业务在需要在时候做出功耗优化的策略调整。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">BatteryEventDelegate.getInstance().addListener(<span class="keyword">new</span> ExListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStateChanged</span><span class="params">(String event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 收到系统电量事件广播</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBatteryStateChanged</span><span class="params">(BatteryState batteryState, <span class="keyword">boolean</span> isLowBattery)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电量状态变化</span></span><br><span class="line">        batteryState.isCharging();</span><br><span class="line">        batteryState.isForeground();</span><br><span class="line">        batteryState.isLowBattery();</span><br><span class="line">        batteryState.isPowerSaveMode();</span><br><span class="line">        batteryState.isScreenOn();</span><br><span class="line">        batteryState.getBackgroundTimeMillis();</span><br><span class="line">        batteryState.getBatteryPercentage();</span><br><span class="line">        batteryState.getBatteryCapacity();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBatteryPowerChanged</span><span class="params">(BatteryState batteryState, <span class="keyword">int</span> levelPct)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电池百分比变化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onBatteryTemperatureChanged</span><span class="params">(BatteryState batteryState, <span class="keyword">int</span> temperature)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 电池温度变化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onAppLowEnergy</span><span class="params">(BatteryState batteryState, <span class="keyword">long</span> backgroundMillis)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// App 进入后台一段时间后的回调, backgroundMillis 为进入后台的持续时间(5, 10, 30min)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="提炼电量优化规则"><a href="#提炼电量优化规则" class="headerlink" title="提炼电量优化规则"></a>提炼电量优化规则</h2><p>正如上篇文章提及的一样，<code>如何检测各种类型的耗电异常，以及如何提炼耗电问题的规则（划红线）是优化电量指标的关键所在</code>。从电量专项指标立项以来，我们项目在与 Android App 电量异常这项 “疑难杂症” 日常斗智斗勇的过程中，根据我们项目自身需要、Android Vitals 最佳实践指导 &amp; 国内厂商自定义实现的系统电量异常告警功能的规则细节等，提炼出一套比较稳定的电量优化规则：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 待机功耗</span></span><br><span class="line"><span class="section">## 普通异常</span></span><br><span class="line"><span class="bullet">1. </span>App 待机情况下（进程优先级为后台 + 设备未充电），进程持续 10min Jiffy 开销超过 5000 jiffies/min（CPU Load ≈ 100%）</span><br><span class="line"><span class="bullet">2. </span>App 待机情况下（进程优先级为后台 + 设备未充电），进程持续 60min Jiffy 开销超过 1000 jiffies/min（CPU Load ≈ 20%）</span><br><span class="line"><span class="section">## 高耗异常</span></span><br><span class="line"><span class="bullet">1. </span>App 待机情况下（进程优先级为后台 + 设备未充电），进程持续 30min Jiffy 开销超过 5000 jiffies/min（CPU Load ≈ 100%）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 系统服务调用</span></span><br><span class="line"><span class="section">## 休眠唤醒</span></span><br><span class="line"><span class="bullet">1. </span>App 待机情况下（进程优先级为后台），WakeLock 持有时间累计超过 5min</span><br><span class="line"><span class="bullet">2. </span>App 待机情况下（进程优先级为后台），Alarm 唤醒服务次数超过 12 次</span><br><span class="line"><span class="section">## 扫描服务</span></span><br><span class="line"><span class="bullet">1. </span>App 待机情况下（进程优先级为后台），GPS 扫描时间累计超过 5min</span><br><span class="line"><span class="bullet">2. </span>App 待机情况下（进程优先级为后台），Wifi 扫描时间平均超过 3min/hour，扫描次数不超过 4 次/hour</span><br><span class="line"><span class="bullet">3. </span>App 待机情况下（进程优先级为后台），BlueTooth 扫描时间平均超过 5min/hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 隐私合规</span></span><br><span class="line"><span class="section">## 访问设备信息</span></span><br><span class="line"><span class="bullet">1. </span>App 在后台时，禁止访问设备信息：TelephonyManager#getImei, #getMeid, #getDeviceId</span><br><span class="line"><span class="bullet">2. </span>App 在后台时，禁止访问营运商信息： TelephonyManager#getSimOperator</span><br><span class="line"><span class="section">## 访问位置信息</span></span><br><span class="line"><span class="bullet">1. </span>App 在后台时，如果需要定位功能，应该尽量使用 Android 的持续定位功能，避免直接获取位置信息</span><br><span class="line"><span class="bullet">2. </span>App 在后台时，禁止访问设备位置：TelephonyManager#getCellLocation</span><br><span class="line"><span class="bullet">3. </span>App 在后台时，避免或者减少直接使用 LocationManager/WifiManaer/BluetoohAdapter 获取位置信息</span><br></pre></td></tr></table></figure>
<h1 id="其他使用姿势"><a href="#其他使用姿势" class="headerlink" title="其他使用姿势"></a>其他使用姿势</h1><p>上面着重强调的 “线程待机功耗异常” 以及 “系统服务调用异常” 则是电量指标中比较好制定的异常规则，其他规则的提炼（比如 App 整体前台功耗，或者使用使用某一业务功能时的功耗），则需要根据 App 自身实际情况，通过以上监控模块统计到的数据做进一步的拿捏。</p>
<p>BatteryCanary 把一些电量规则提炼中比较重要的数据做了易用性的封装，可以通过以下方式获取。</p>
<h3 id="CPU-Load"><a href="#CPU-Load" class="headerlink" title="CPU Load"></a>CPU Load</h3><p>CPU Load 是判断 App 当前功耗大小的一个重要依据，通过 <code>adb top</code> 命令我们可以轻松地获取 App 进程 &amp; 线程的 CPU Load 数据，而在 App 内获取这个数据却不容易，通常我们只有在 ANR 的时候才会看到 App 把这个数据 Dump 出来。</p>
<p>根据类似的计算方式，BatteryCanary 提供了相应的 CPU Load 获取接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cpuLoad = compositor.getCpuLoad(); <span class="comment">// [0, 100 * cpu_core_num]</span></span><br></pre></td></tr></table></figure>
<h3 id="CpuFreq-采样"><a href="#CpuFreq-采样" class="headerlink" title="CpuFreq 采样"></a>CpuFreq 采样</h3><p>CpuFreq 也是跟 CPU 功耗相关的一个主要的依据。一个 CPU 往往由几个集群（Cluster）组成，每个集群里面的 CPU Core 的规格都是一样的，比如我的手机就是由大（2 core）、中（4 core）、小（2 core）三个集群共 8 CPU Core 组成。CPU 工作时，每个 Core 会运行在不同的 CpuFreq，工作频率（Step）越高则功耗越大，相应的设备发烫也就更严重。</p>
<p>获取 App 当前瞬时的 CpuFreq 意义不大，我们需要通过监控 CpuFreq 的变化，来大抵推断出 App 在某个使用场景下 CPU 功耗的变化情况，如果 CpuFreq 变化太大且长时间处于比较高的 Step，则我们应该着重关注该场景下用户发热发烫的反馈情况，必要时候做出相应的降频策略。</p>
<p>首先，指定需要采集的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建组合器</span></span><br><span class="line">CompositeMonitors compositor = <span class="keyword">new</span> CompositeMonitors(core);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 指定采样数据类型</span></span><br><span class="line">compositor.sample(CpuFreqSnapshot<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 指定采样数据类型 &amp; 采样周期（默认 5 秒）</span></span><br><span class="line">compositor.sample(CpuFreqSnapshot<span class="class">.<span class="keyword">class</span>， 10<span class="title">L</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>Battery 提供以下的方式来采样 CpuFreq 的变化数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Result sampling = compositor.getSamplingResult(CpuFreqSnapshot<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sampling != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> duringMillis = sampling.duringMillis; <span class="comment">// 时间窗口</span></span><br><span class="line">    <span class="keyword">long</span> interval = sampling.interval   ;      <span class="comment">// 采样周期</span></span><br><span class="line">    <span class="keyword">int</span> count = sampling.count;                <span class="comment">// 采样次数</span></span><br><span class="line">    <span class="keyword">double</span> sampleFst = sampling.sampleFst;     <span class="comment">// 第一次采样</span></span><br><span class="line">    <span class="keyword">double</span> sampleLst = sampling.sampleLst;     <span class="comment">// 最后一次采样</span></span><br><span class="line">    <span class="keyword">double</span> sampleMax = sampling.sampleMax;     <span class="comment">// 最大采样值</span></span><br><span class="line">    <span class="keyword">double</span> sampleMin = sampling.sampleMin;     <span class="comment">// 最小采样值</span></span><br><span class="line">    <span class="keyword">double</span> sampleAvg = sampling.sampleAvg;     <span class="comment">// 平均采样值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="电池温度采样"><a href="#电池温度采样" class="headerlink" title="电池温度采样"></a>电池温度采样</h3><p>我们认为设备机身温度也是电量优化的一个重要指标，遗憾的是 Android Framework 并没有提供相应的 API 来获取该数据（需要系统 App 权限）。好在电池温度变化与设备温度正相关性比较强，而且当设备整体功耗比较大的时候，电池的输出功率也比较大，从而电池温度也会上升得比较快，在一定程度上我们可以用电池温度作为依据来判断设备机身的发烫状况（不过快充等充电场景也会导致电池升温，需要做好相关的状态判断和过滤）。</p>
<p>类似 CpuFreq，当前电池温度也应该通过采样的方式来判断其变化状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Result sampling = compositor.getSamplingResult(BatteryTmpSnapshot<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sampling != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">long</span> duringMillis = sampling.duringMillis; <span class="comment">// 时间窗口</span></span><br><span class="line">    <span class="keyword">long</span> interval = sampling.interval   ;      <span class="comment">// 采样周期</span></span><br><span class="line">    <span class="keyword">int</span> count = sampling.count;                <span class="comment">// 采样次数</span></span><br><span class="line">    <span class="keyword">double</span> sampleFst = sampling.sampleFst;     <span class="comment">// 第一次采样</span></span><br><span class="line">    <span class="keyword">double</span> sampleLst = sampling.sampleLst;     <span class="comment">// 最后一次采样</span></span><br><span class="line">    <span class="keyword">double</span> sampleMax = sampling.sampleMax;     <span class="comment">// 最大采样值</span></span><br><span class="line">    <span class="keyword">double</span> sampleMin = sampling.sampleMin;     <span class="comment">// 最小采样值</span></span><br><span class="line">    <span class="keyword">double</span> sampleAvg = sampling.sampleAvg;     <span class="comment">// 平均采样值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AppStats"><a href="#AppStats" class="headerlink" title="AppStats"></a>AppStats</h3><p>为了方便统一管理数据，BatteryCanary 把电量问题相关的 App 状态、Device 状态、Activity 切换信息等数据都封装到 AppStats 这个类里，可以通过以下方式来获取当前时间窗口内的 AppStats：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> duringMillis = xxx; <span class="comment">// 时间窗口</span></span><br><span class="line">AppStats appStats = AppStats.current(duringMillis);</span><br><span class="line"><span class="keyword">if</span> (appStats.isValid) &#123;</span><br><span class="line">    <span class="keyword">long</span> minute = appStats.getMinute();  <span class="comment">// 时间窗口(分钟)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> appStat = appStats.getAppStat();         <span class="comment">// App 状态</span></span><br><span class="line">    <span class="keyword">long</span> fgRatio = appStats.fgRatio.get();       <span class="comment">// 前台时间占比</span></span><br><span class="line">    <span class="keyword">long</span> bgRatio = appStats.bgRatio.get();       <span class="comment">// 后台时间占比</span></span><br><span class="line">    <span class="keyword">long</span> fgSrvRatio = appStats.fgSrvRatio.get(); <span class="comment">// 前台服务时间占比</span></span><br><span class="line">    <span class="keyword">long</span> floatRatio = appStats.floatRatio.get(); <span class="comment">// 浮窗时间占比</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> devStat = appStats.getDevStat();                   <span class="comment">// Device 状态</span></span><br><span class="line">    <span class="keyword">long</span> unChargingRatio = appStats.unChargingRatio.get(); <span class="comment">// 未充电状态时间占比</span></span><br><span class="line">    <span class="keyword">long</span> screenOff = appStats.screenOff.get();             <span class="comment">// 息屏状态时间占比</span></span><br><span class="line">    <span class="keyword">long</span> lowEnergyRatio = appStats.lowEnergyRatio.get();   <span class="comment">// 低电耗状态时间占比</span></span><br><span class="line">    <span class="keyword">long</span> chargingRatio = appStats.chargingRatio.get();     <span class="comment">// 充电状态时间占比</span></span><br><span class="line"></span><br><span class="line">    String scene = appStats.sceneTop1;        <span class="comment">// Top1 Activity</span></span><br><span class="line">    <span class="keyword">int</span> sceneRatio = appStats.sceneTop1Ratio; <span class="comment">// Top1 Activity 占比</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="电量统计报告"><a href="#电量统计报告" class="headerlink" title="电量统计报告"></a>电量统计报告</h1><p>除了以上介绍的各种异常的检测之外，如何将各种监控模块统计到的异常数据以一种 “read-friendly” 的方式展示出来也是个麻烦的事情。BatteryCanary 通过两种方式来展示统计数据：logcat 日志 &amp; 时间轴 UI。</p>
<h2 id="Battery-Dumper-amp-Printer"><a href="#Battery-Dumper-amp-Printer" class="headerlink" title="Battery Dumper &amp; Printer"></a>Battery Dumper &amp; Printer</h2><p>待机功耗监控的 CompositeMonitors（SCOPE_CANARY）会通过默认的 Dumper &amp; Printer 来往 logcat 输出以下统计报告（其他监控场景 App 可以根据需要自定义自己的 Dumper），这里以开启全部监控功能的待机场景为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Printer printer = <span class="keyword">new</span> Printer();</span><br><span class="line">printer.writeTitle();</span><br><span class="line"><span class="keyword">new</span> Dumper().dump(compositor, printer);</span><br><span class="line">printer.writeEnding();</span><br><span class="line"></span><br><span class="line">Log.i(TAG, <span class="string">"dump battery report: \n"</span> + printer.toString());</span><br></pre></td></tr></table></figure>
<p>Logcat 会输出以下格式化的文本：</p>
<figure class="highlight plain"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">****************************************** PowerTest *****************************************</span><br><span class="line">| pid=12773		fg=fg		during(min)=1		diff(jiffies)=10828		avg(jiffies/min)=10828</span><br><span class="line">+ --------------------------------------------------------------------------------------------</span><br><span class="line">| jiffies(13) :</span><br><span class="line">|   -&gt; desc	= (status)name(tid)	avg/total</span><br><span class="line">|   -&gt; inc_thread_num	= 2</span><br><span class="line">|   -&gt; cur_thread_num	= 30</span><br><span class="line">|   -&gt; (+/R)Benchmark(12833)	10436/10436	jiffies</span><br><span class="line">|   -&gt; (~/S)RenderThread(12808)	135/135	jiffies</span><br><span class="line">|   -&gt; (~/R).tencent.matrix(12773)	126/126	jiffies</span><br><span class="line">|   -&gt; (+/S)JDWP Transport (12908)	38/38	jiffies</span><br><span class="line">|   -&gt; (~/S)Jit thread pool(12787)	33/33	jiffies</span><br><span class="line">|   -&gt; (~/S)default_matrix_(12802)	26/26	jiffies</span><br><span class="line">|   -&gt; (~/S)matrix_time_upd(12800)	8/8	jiffies</span><br><span class="line">|   -&gt; (~/S)Binder:12773_2(12794)	7/7	jiffies</span><br><span class="line">|		......</span><br><span class="line">|   #overHeat</span><br><span class="line">+ --------------------------------------------------------------------------------------------</span><br><span class="line">| awake :</span><br><span class="line">|   &lt;alarm&gt;</span><br><span class="line">|   -&gt; 104732(mls)	1(min)</span><br><span class="line">|   -&gt; inc_alarm_count	= 0</span><br><span class="line">|   -&gt; inc_trace_count	= 0</span><br><span class="line">|   -&gt; inc_dupli_group	= 0</span><br><span class="line">|   -&gt; inc_dupli_count	= 0</span><br><span class="line">|   &lt;wake_lock&gt;</span><br><span class="line">|   -&gt; 104732(mls)	1(min)</span><br><span class="line">|   -&gt; inc_lock_count	= 0</span><br><span class="line">|   -&gt; inc_time_total	= 0</span><br><span class="line">+ --------------------------------------------------------------------------------------------</span><br><span class="line">| scanning :</span><br><span class="line">|   &lt;bluetooh&gt;</span><br><span class="line">|   -&gt; 104719(mls)	1(min)</span><br><span class="line">|   -&gt; inc_regs_count	= 0</span><br><span class="line">|   -&gt; inc_dics_count	= 0</span><br><span class="line">|   -&gt; inc_scan_count	= 0</span><br><span class="line">|   &lt;wifi&gt;</span><br><span class="line">|   -&gt; 104648(mls)	1(min)</span><br><span class="line">|   -&gt; inc_scan_count	= 0</span><br><span class="line">|   -&gt; inc_qury_count	= 0</span><br><span class="line">|   &lt;location&gt;</span><br><span class="line">|   -&gt; 104646(mls)	1(min)</span><br><span class="line">|   -&gt; inc_scan_count	= 0</span><br><span class="line">+ --------------------------------------------------------------------------------------------</span><br><span class="line">| dev_stats :</span><br><span class="line">|   &lt;cpu_load&gt;</span><br><span class="line">|   -&gt; 104715(mls)	1(min)</span><br><span class="line">|   -&gt; usage	= 103%</span><br><span class="line">|   -&gt; cpu0	= [0, 0, 0, 1832, 0, 0, 3, 4675, 1194, 434, 412, 91, 37, 77, 59, 48, 45, 1564]</span><br><span class="line">|   -&gt; cpu1	= [0, 0, 0, 1832, 0, 0, 3, 4675, 1194, 434, 412, 91, 37, 77, 59, 48, 45, 1564]</span><br><span class="line">|   -&gt; cpu2	= [0, 0, 0, 1832, 0, 0, 3, 4675, 1194, 434, 412, 91, 37, 77, 59, 48, 45, 1565]</span><br><span class="line">|   -&gt; cpu3	= [0, 0, 0, 1832, 0, 0, 3, 4675, 1194, 434, 412, 91, 37, 77, 59, 48, 45, 1565]</span><br><span class="line">|   -&gt; cpu4	= [7190, 37, 31, 32, 17, 429, 405, 254, 128, 25, 19, 13, 9, 8, 4, 6, 1868]</span><br><span class="line">|   -&gt; cpu5	= [7190, 37, 31, 32, 17, 429, 405, 254, 128, 25, 19, 13, 9, 8, 4, 6, 1868]</span><br><span class="line">|   -&gt; cpu6	= [7190, 37, 31, 32, 17, 429, 405, 254, 128, 25, 19, 13, 9, 8, 4, 6, 1868]</span><br><span class="line">|   -&gt; cpu7	= [1603, 11, 0, 0, 79, 4, 4, 11, 4, 5, 8, 2, 0, 0, 2, 0, 0, 0, 0, 8738]</span><br><span class="line">|   &lt;cpu_sip&gt;</span><br><span class="line">|   -&gt; inc_cpu_sip	= 21.34(mAh)</span><br><span class="line">|   -&gt; cur_cpu_sip	= 66720.12(mAh)</span><br><span class="line">|   -&gt; inc_prc_sip	= 3.58(mAh)</span><br><span class="line">|   -&gt; cur_prc_sip	= 4.81(mAh)</span><br><span class="line">|   &lt;cpufreq&gt;</span><br><span class="line">|   -&gt; 104686(mls)	1(min)</span><br><span class="line">|   -&gt; inc	= [0, 0, 0, 0, -192, -192, -96, 0]</span><br><span class="line">|   -&gt; cur	= [1785, 1785, 1785, 1785, 2227, 2227, 2323, 2841]</span><br><span class="line">|   &lt;cpufreq_sampling&gt;</span><br><span class="line">|   -&gt; 104719(mls)	1000(itv)</span><br><span class="line">|   -&gt; max	= 2419.0</span><br><span class="line">|   -&gt; min	= 2419.0</span><br><span class="line">|   -&gt; avg	= 2419.0</span><br><span class="line">|   -&gt; cnt	= 17</span><br><span class="line">|   &lt;batt_temp&gt;</span><br><span class="line">|   -&gt; 104719(mls)	1(min)</span><br><span class="line">|   -&gt; inc	= 0</span><br><span class="line">|   -&gt; cur	= 273</span><br><span class="line">|   &lt;batt_temp_sampling&gt;</span><br><span class="line">|   -&gt; 104720(mls)	1000(itv)</span><br><span class="line">|   -&gt; max	= 273.0</span><br><span class="line">|   -&gt; min	= 273.0</span><br><span class="line">|   -&gt; avg	= 273.0</span><br><span class="line">|   -&gt; cnt	= 17</span><br><span class="line">+ --------------------------------------------------------------------------------------------</span><br><span class="line">| app_stats :</span><br><span class="line">|   &lt;stat_time&gt;</span><br><span class="line">|   -&gt; time	= 1(min)</span><br><span class="line">|   -&gt; fg	= 100</span><br><span class="line">|   -&gt; bg	= 0</span><br><span class="line">|   -&gt; fgSrv	= 0</span><br><span class="line">|   -&gt; devCharging	= 100</span><br><span class="line">|   -&gt; devScreenOff	= 0</span><br><span class="line">|   -&gt; sceneTop1	= Current AppScene/100</span><br><span class="line">|   &lt;run_time&gt;</span><br><span class="line">|   -&gt; time	= 1(min)</span><br><span class="line">|   -&gt; fg	= 100</span><br><span class="line">|   -&gt; bg	= 0</span><br><span class="line">|   -&gt; fgSrv	= 0</span><br><span class="line">**********************************************************************************************</span><br></pre></td></tr></table></figure>
<h2 id="Battery-Stats"><a href="#Battery-Stats" class="headerlink" title="Battery Stats"></a>Battery Stats</h2><p>启用 BatteryStatsFeature 功能的时候，BatteryCanary 会通过 <a href="https://github.com/Tencent/MMKV" target="_blank" rel="noopener">MMKV</a> 持久化电量统计数据，并通过 BatteryStatsActivity 以时间轴的形式展示相关的电量事件 &amp; 电量报告，以便于快速排查并定位异常现场。</p>
<h3 id="电量事件"><a href="#电量事件" class="headerlink" title="电量事件"></a>电量事件</h3><p>电量事件是判断 App 有没有出现电量问题的重要数据，主要包括以下事件：</p>
<figure class="highlight plain"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">App 前后切换</span><br><span class="line"></span><br><span class="line">Intent.ACTION_SCREEN_ON 亮屏</span><br><span class="line">Intent.ACTION_SCREEN_OFF 息屏</span><br><span class="line">Intent.ACTION_POWER_CONNECTED 充电</span><br><span class="line">Intent.ACTION_POWER_DISCONNECTED 解除充电</span><br><span class="line"></span><br><span class="line">Intent.ACTION_BATTERY_CHANGED 电量变化（电池百分比，电池温度）</span><br><span class="line">Intent.ACTION_BATTERY_LOW 低电量</span><br><span class="line">Intent.ACTION_BATTERY_OKAY 从低电量恢复</span><br><span class="line"></span><br><span class="line">PowerManager.ACTION_POWER_SAVE_MODE_CHANGED App 进入待机模式</span><br><span class="line">PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED 系统进入 Doze 模式</span><br></pre></td></tr></table></figure>
<h3 id="电量报告"><a href="#电量报告" class="headerlink" title="电量报告"></a>电量报告</h3><p>电量报告主要包括是以上提及的各种监控场景的 CompositeMonitors 统计到的电量数据，以一种比较直观的方式展示数据，用于快速定位某个 App 使用场景下的电量问题。</p>
<!-- ColumnList BGN -->
<p><img src="/assets/41a9576d_8960_4b02_9946_d3e9e5d9767b_untitled.png" alt><br><img src="/assets/d3d64e55_3dcb_4ef1_b072_db9f11978109_untitled.png" alt></p>
<!-- ColumnList END -->
<hr>
<p>参考链接：</p>
<ol>
<li><a href="https://github.com/Tencent/matrix" target="_blank" rel="noopener">Matrix 开源项目</a></li>
<li><a href="https://github.com/Tencent/matrix/blob/master/matrix/matrix-android/matrix-battery-canary/src/androidTest/java/com/tencent/matrix/batterycanary/Examples.java" target="_blank" rel="noopener">BatteryCanary 使用 Example</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals" target="_blank" rel="noopener">Android Vitals</a></li>
</ol>
<!-- Generated by HexoWriter
notion-down.version = 0.2.2
notion-down.revision = b'808ded4'
Title = Matrix BatteryCanary 电量优化框架
Date = 2022-01-20
Published = true
Category = Android
Tag = ['Android', 'APM', '电量优化', 'BatteryCanary']
FileLocate = 
FileName = android-apm-battery-canary
hexo.comments = true
-->

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Android/">Android</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Android/">Android</a><a href="/tags/APM/">APM</a><a href="/tags/电量优化/">电量优化</a><a href="/tags/BatteryCanary/">BatteryCanary</a>
    </span>
    

    </div>

    
  </div>
</article>

  



	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'kidhaibara';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Deployed by <a href="https://github.com/kaedea/notion-down" target="_blank">notion-down</a> and
    Theme by <a href="https://github.com/kaedea/hexo-theme-hacker" target="_blank">hexo-theme-hacker</a>
    </br>
    
    &copy; 2025 Kaede Akatsuki
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'G-J38N5N288S', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>